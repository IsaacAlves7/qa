[![License](https://img.shields.io/badge/license-Apache%20License%202.0-blue.svg)](https://opensource.org/licenses/Apache-2.0)
[![Java](https://img.shields.io/badge/java-17%2B-blue)](https://www.oracle.com/java/technologies/javase/jdk17-archive-downloads.html)
[![Release](https://img.shields.io/github/release/rife2/tests-badge.svg)](https://github.com/rife2/tests-badge/releases/latest)
[![GitHub CI](https://github.com/rife2/tests-badge/actions/workflows/bld.yml/badge.svg)](https://github.com/rife2/tests-badge/actions/workflows/bld.yml)
[![Tests](https://rife2.com/tests-badge/badge/com.uwyn/tests-badge)](https://github.com/rife2/tests-badge/actions/workflows/bld.yml)

<a href="https://github.com/IsaacAlves7/qa"><img width="1920" height="500" alt="image" src="https://github.com/user-attachments/assets/7675c835-51aa-4d5d-b46b-8d8b81d948a8" /></a>

> Vers√≠culo chave: "Consagre ao Senhor tudo o que voc√™ faz, e os seus planos ser√£o bem-sucedidos." - Prov√©rbios 16:3

# QA/QC - Quality Assurance and Quality Control üë®üèæ‚Äçüî¨
<img src="https://img.shields.io/badge/Python-3.10.7-3776AB?style=flat&logo=Python&logoColor=white"> <img src="https://img.shields.io/badge/Node.js-16.17.0-339933?style=flat&logo=Node.js&logoColor=white"> <img src="https://img.shields.io/badge/Ruby-3.3-CC342D?style=flat&logo=Ruby&logoColor=white"> <img src="https://img.shields.io/badge/Go-1.21-00ADD8?style=flat&logo=Go&logoColor=white"> <img src="https://img.shields.io/badge/PHP-8.2-777BB4?style=flat&logo=PHP&logoColor=white"> <img src="https://img.shields.io/badge/C++-23-F5455C?style=flat&logo=CPlusPlus&logoColor=white"> <img src="https://img.shields.io/badge/Java-22.0.1-chocolate?style=flat&logo=OpenJDK&logoColor=white"> <img src="https://img.shields.io/badge/.NET-8.0.300-512BD4?style=flat&logo=DotNet&logoColor=white"> <img src="https://img.shields.io/badge/Rust-1.82.0-dda584?style=flat&logo=Rust&logoColor=white"> 

<a href=""><img src="https://em-content.zobj.net/source/microsoft-teams/363/man-scientist-medium-dark-skin-tone_1f468-1f3fe-200d-1f52c.png" align="right" height="77"></a>

Imagine-se como um entusiasta da tecnologia, ansioso por entender como um software pode ser eficaz e confi√°vel. Como garantir que um software atenda √†s expectativas dos usu√°rios e funcione sem falhas? Esse dilema cria um conflito cognitivo que nos impulsiona a mergulhar mais fundo.

A hist√≥ria da **Qualidade de Software** nos mostra a evolu√ß√£o dos processos, desde as abordagens mais tradicionais at√© as metodologias √°geis modernas. Aprender sobre modelos de qualidade, como o ISO 25000, e as dimens√µes da qualidade, como funcionalidade e usabilidade, enriquece nossa compreens√£o. As pe√ßas se encaixam, transformando a quest√£o inicial em um quebra-cabe√ßa conceitual.

Imagine que voc√™ √© um membro de uma equipe de desenvolvimento de software. Voc√™ √© desafiado a aplicar os conceitos aprendidos em um cen√°rio real. Voc√™ participa de revis√µes, que s√£o an√°lises colaborativas do c√≥digo, e auditorias, que avaliam os processos utilizados. Essa simula√ß√£o o coloca no ambiente profissional, onde as decis√µes t√™m impacto direto na qualidade do software.

Ao concluir as revis√µes e auditorias, voc√™ reflete sobre os processos e a efic√°cia das t√©cnicas aplicadas. Reconhece a import√¢ncia de identificar falhas cedo e como as revis√µes sistem√°ticas podem prevenir erros custosos. Voc√™ compreende que, assim como o software, o aprendizado √© um processo cont√≠nuo (Continuous Learning). E √† medida que voc√™ assimila esses conceitos, torna-se mais apto a contribuir para o desenvolvimento de software de alta qualidade, solidificando sua jornada na compreens√£o da Qualidade de Software

> [!Note]
> Esse conte√∫do √© geralmente abordado no final das gradua√ß√µes da √°rea de TI, ou seja, √© um m√≥dulo avan√ßado e atua com boas pr√°ticas do mercado. Ent√£o eu vou supor que todos j√° sabem desenvolver softwares e pular toda a parte de codifica√ß√£o com metodologias √°geis e ciclo de vida de desenvolvimento para partir pro ponto de qualidade de software.

> [!Tip]
> Vamos recordar a import√¢ncia das boas pr√°ticas de programa√ß√£o como um elemento essencial na busca pela qualidade de software. Revisitarmos a no√ß√£o de c√≥digo limpo e bem estruturado, que n√£o s√≥ facilita a manuten√ß√£o, mas tamb√©m reduz erros e falhas futuras. Recordar como padr√µes de nomenclatura consistentes, coment√°rios claros e modulariza√ß√£o do c√≥digo s√£o cruciais para criar um produto de software robusto e de f√°cil compreens√£o. Isso nos lembrar√° que a qualidade n√£o se limita apenas aos processos de teste, mas come√ßa desde a concep√ß√£o do c√≥digo-fonte.

Primeiro, precisamos entender que a qualidade de software √© uma √°rea de grande import√¢ncia no mercado de tecnologia da informa√ß√£o. E para garantir a qualidade de um software, √© preciso conhecer seus fundamentos, entender sua hist√≥ria, compreender os custos envolvidos, realizar atividades de apoio, seguir padr√µes e avaliar seus atributos. A seguir, apresentamos alguns desses atributos:

> [!Important]
> **Defini√ß√£o**: Qualidade √© a caracter√≠stica ou atributo que define algo ou algu√©m em termos de excel√™ncia, valor, ou n√≠vel de desempenho. Pode se referir a propriedades como durabilidade, efici√™ncia, efic√°cia, ou valor percebido. ‚ÄúQualidade √© a medida de quanto um projeto atende aos requisitos especificados no escopo.‚Äù

> [!Note]
> **FUNDAMENTOS DA QUALIDADE DE SOFTWARE**: Incluem a defini√ß√£o de requisitos, o planejamento de testes e a execu√ß√£o de testes de forma sistem√°tica. Esses processos s√£o essenciais para garantir que o software desenvolvido atenda √†s necessidades do usu√°rio e atinja a qualidade esperada.

No antigo Egito, h√° aproximadamente 4 mil anos, para que as constru√ß√µes fossem feitas com **qualidade**, definiu-se o c√∫bito, que era a dist√¢ncia do cotovelo √† ponta do indicador do fara√≥. Uma das primeiras tentativas da humanidade de _padronizar_ as medidas, gerando qualidade nas constru√ß√µes.

Nesta escultura, temos na base um compilado com as regras e leis a serem seguidas, impostas por Hamurabi, Rei da Babil√¥nia, que era aplicada a cidad√£os livres, comerciantes, escravos, etc. Uma das primeiras tentativas de _padronizar_ as regras de conv√≠vio da sociedade, h√° aproximadamente 3.800 anos atr√°s.

Historicamente, o conceito de qualidade est√° ligado √† ideia de atender padr√µes e requisitos acordados, com base em comunica√ß√£o clara e objetivos definidos, seja na qualidade do ar, qualidade da √°gua, da qualidade de vida ou qualidade do software. Portanto, a qualidade de software √© a investiga√ß√£o do software a fim de fornecer informa√ß√µes sobre sua qualidade em rela√ß√£o ao contexto em que ele deve operar.

A busca por qualidade n√£o √© algo novo. Desde os prim√≥rdios, o ser humano busca aprimorar suas cria√ß√µes e produ√ß√µes, seja para torn√°-las mais dur√°veis, funcionais ou esteticamente agrad√°veis. Com o advento da Revolu√ß√£o Industrial, essa busca se intensificou, principalmente no que diz respeito √† produ√ß√£o em massa. 

Mas foi somente com a Segunda Guerra Mundial que a qualidade passou a ser vista como uma quest√£o estrat√©gica, com a necessidade de se produzir em larga escala produtos de alta qualidade para suprir as demandas militares. A partir da√≠, a qualidade come√ßou a ser tratada como um processo e a ser estudada de forma mais sistem√°tica. A evolu√ß√£o hist√≥rica da qualidade de software pode ser dividida em v√°rias fases:

1. **PRIMEIRA FASE**: Conhecida como era dos ‚Äúprogramadores her√≥is‚Äù, ocorreu na d√©cada de 1940 a 1950, quando o foco era na programa√ß√£o manual e n√£o havia processos formais de garantia de qualidade.

2. **SEGUNDA FASE**: Foi a era dos ‚Äúprodutos de software‚Äù, que teve in√≠cio nos anos 1960 e trouxe a necessidade de se preocupar com a qualidade dos softwares produzidos, mas ainda sem muita formaliza√ß√£o.

3. **TERCEIRA FASE**: A era da ‚Äúengenharia de software‚Äù, teve in√≠cio nos anos 1970 e marcou o surgimento de processos formais de desenvolvimento de software e de metodologias para garantir a qualidade do produto final. Nesta fase, foi criada a ISO 9000, que estabeleceu padr√µes de qualidade para empresas e servi√ßos em geral.

4. **QUALIDADE TOTAL**: Teve in√≠cio na d√©cada de 1980, trouxe a ideia de que a qualidade n√£o √© responsabilidade apenas da √°rea de desenvolvimento de software, mas sim de toda a organiza√ß√£o. Foram estabelecidos processos de melhoria cont√≠nua e a necessidade de se envolver todos os departamentos e funcion√°rios na busca pela qualidade.

5. **QUALIDADE DE SOFTWARE**: Teve in√≠cio nos anos 1990, trouxe a necessidade de se preocupar com a qualidade do processo de desenvolvimento do software, e n√£o apenas com o produto final. Surgiram novas metodologias e modelos de maturidade, como o Capability Matu
rity Model Integration (CMMI) e o ISO/IEC 12207, que buscam garantir a qualidade do processo de desenvolvimento.

No in√≠cio da d√©cada de 1980, o governo dos Estados Unidos reconheceu a necessidade de padronizar a qualidade do software. Em 1986, foi publicado o padr√£o IEEE 610.12, que definiu a terminologia b√°sica usada em engenharia de software, incluindo defini√ß√µes de qualidade de software. Essas defini√ß√µes incluem ‚Äúqualidade de software‚Äù como o grau em que um sistema, componente ou processo atende aos requisitos especificados e/ou impl√≠citos e √†s necessidades ou expectativas do usu√°rio.

A partir de ent√£o, a qualidade de software se tornou um foco importante na ind√∫stria de TI e foi acompanhada pelo surgimento de v√°rias ferramentas e t√©cnicas de teste e garantia de qualidade de software. A demanda por softwares confi√°veis e de alta qualidade √© cada vez maior, uma vez que muitos neg√≥cios e servi√ßos dependem de sistemas de software em seus processos di√°rios.

Hoje em dia, a busca pela qualidade de software continua em constante evolu√ß√£o, com a introdu√ß√£o de novas tecnologias e metodologias, como a integra√ß√£o cont√≠nua e o desenvolvimento √°gil, e intelig√™ncia artificial que buscam garantir a qualidade do software de forma mais eficiente e r√°pida.

No entanto, a busca pela qualidade de software ainda √© um desafio constante. Novas tecnologias e metodologias surgem a cada dia, e os desenvolvedores de software devem estar atualizados sobre as novas tend√™ncias e ferramentas dispon√≠veis. Al√©m disso, a complexidade dos sistemas de software modernos tamb√©m torna o controle de qualidade mais dif√≠cil, exigindo uma abordagem mais estruturada e orientada a processos.

Portanto, os aspectos hist√≥ricos da qualidade de software nos mostram como essa √°rea evoluiu ao longo do tempo. Desde a d√©cada de 1970, a qualidade de software vem sendo debatida e estudada, e hoje em dia √© um tema muito importante em empresas de desenvolvimento de software.

Para aprofundar seus conhecimentos sobre qualidade de software, voc√™ pode se perguntar: como garantir que um software seja de qualidade? Uma resposta √© adotar processos de garantia de qualidade, que englobam atividades como revis√µes, testes e inspe√ß√µes para identificar e corrigir defeitos. Al√©m disso, √© importante definir crit√©rios de qualidade e medir a qualidade do software com base nesses crit√©rios.
 
Uma ilustra√ß√£o que pode ajudar a entender a import√¢ncia da qualidade de software √© pensar em um aplicativo de banco que apresenta erros constantemente. Isso certamente afetaria a confian√ßa do usu√°rio no aplicativo e, consequentemente, na institui√ß√£o financeira. Por isso, a qualidade do software √© fundamental para garantir a satisfa√ß√£o e fideliza√ß√£o do usu√°rio.

Os fundamentos de **teste de software** (Software Testing) se referem a um conjunto de pr√°ticas e t√©cnicas utilizadas para garantir que um software seja capaz de atender aos requisitos e expectativas dos usu√°rios, al√©m de estar livre de erros e falhas. Para ser eficaz, o teste de software deve ser planejado, executado e gerenciado de forma adequada. Isso envolve identificar e definir os objetivos do teste, estabelecer crit√©rios de aceita√ß√£o, selecionar as t√©cnicas e ferramentas adequadas e documentar todo o processo.

Entre os fundamentos do teste de software est√£o:

1. **Identifica√ß√£o de requisitos**: Os requisitos s√£o funcionalidades que o produto precisa ter para atender √†s expectativas e necessidades das partes interessadas. √â importante que todos os requisitos do software estejam claramente definidos e documentados antes do in√≠cio do teste. Essa etapa √© crucial para garantir que o software atenda √†s expectativas dos usu√°rios. O escopo √© o conjunto de caracter√≠sticas desejadas que descrevem o resultado final do projeto.

2. **Planejamento de teste**: o planejamento do teste deve ser feito de forma estruturada e detalhada, incluindo a defini√ß√£o dos objetivos, recursos, cronograma, t√©cnicas e crit√©rios de aceita√ß√£o.

3. **Projeto de casos de teste**: os casos de teste devem ser projetados de acordo com os requisitos e objetivos do teste, de forma a garantir a cobertura de todos os aspectos do software.

4. **Execu√ß√£o de testes**: a execu√ß√£o dos testes deve ser feita de forma sistem√°tica e controlada, registrando todas as falhas encontradas.

5. **Avalia√ß√£o de resultados**: os resultados dos testes devem ser avaliados de acordo com os crit√©rios de aceita√ß√£o para determinar se o software atendeu aos requisitos.

6. **Relat√≥rios e documenta√ß√£o**: todos os resultados e conclus√µes do teste devem ser documentados de forma clara e concisa para permitir que outras pessoas entendam e repliquem o processo.

Al√©m desses fundamentos b√°sicos, existem diversas t√©cnicas e ferramentas de teste que podem ser utilizadas para tornar o processo mais eficiente e eficaz. Essas incluem testes funcionais, testes de desempenho, testes de seguran√ßa, testes de usabilidade, dentre outros. √â importante que o testador esteja familiarizado com as diferentes t√©cnicas e saiba selecionar a mais adequada para cada situa√ß√£o. 

Outro aspecto importante dos fundamentos de qualidade de software √© a colabora√ß√£o entre as equipes envolvidas no desenvolvimento. √â preciso que todos os membros trabalhem em conjunto para garantir a qualidade do produto final. Isso inclui desde a comunica√ß√£o eficiente entre os desenvolvedores e os testadores at√© a participa√ß√£o do usu√°rio em testes de aceita√ß√£o.

<img src="https://github.com/user-attachments/assets/e2a8279f-4b9e-44f5-aea4-278ae9cc5bfe" align="right" height="177">

> [!Important]
> **Software Engineering: A Practitioner's Approach**: Para aprofundar seus conhecimentos sobre qualidade de software, voc√™ pode recorrer a materiais como artigos cient√≠ficos, livros e cursos on-line. Uma indica√ß√£o de leitura √© o livro Software Engineering: A Practitioner's Approach, de Roger Pressman, que aborda temas como garantia de qualidade, medi√ß√£o de qualidade e processos de software. Em resumo, entender os fundamentos de qualidade de software √© essencial para garantir o sucesso de projetos de desenvolvimento. Isso inclui a compreens√£o do conceito de qualidade, a ado√ß√£o de processos de garantia de qualidade, a defini√ß√£o de crit√©rios de qualidade e a colabora√ß√£o entre as equipes. Aprofundar seus conhecimentos neste tema √© fundamental para se destacar no mercado de trabalho e garantir a satisfa√ß√£o do usu√°rio.

Portanto, o teste de software (Software testing) para os profissionais de QA‚Äôs √© a forma que utilizamos para avaliar um software, com um objetivo de assegurar e garantir a qualidade do mesmo, nos pontos de vista t√©cnico e funcional. 

<img height="277" align="right" src="https://github.com/user-attachments/assets/156de8a8-38de-4fc1-9920-aa8cb2c75f38" />

O *teste de software* √© a pr√°tica concreta que os profissionais de QA (no papel de testers, engenheiros de teste ou SDETs) usam para avaliar se o produto realmente cumpre o que deveria cumprir, tanto sob o ponto de vista t√©cnico (estabilidade, performance, seguran√ßa) quanto funcional (se as regras de neg√≥cio e requisitos do usu√°rio est√£o atendidos).

> "Descobrir o inesperado √© mais importante do que confirmar o conhecido." - George E.P.Box

Quando falamos de testes de software usamos bastante os conceitos de dois pontos de vista: o _caminho test√°vel_ e _caminho feliz_, mas cada um tem um prop√≥sito diferente dentro da estrat√©gia de valida√ß√£o do sistema. O chamado ‚Äúcaminho feliz‚Äù (ou ‚Äúhappy path‚Äù) √© aquele fluxo idealizado em que tudo acontece como esperado, sem erros, exce√ß√µes ou desvios. √â o cen√°rio perfeito, onde o usu√°rio ou o sistema segue exatamente o que foi planejado, com entradas v√°lidas, comportamento conforme os requisitos e sa√≠da correta. √â fundamental porque garante que a funcionalidade principal est√° realmente atendendo ao objetivo esperado quando usada da maneira correta, e por isso √© quase sempre o primeiro caso de teste escrito, seja em testes manuais, automatizados, unit√°rios ou de integra√ß√£o.

J√° o ‚Äúcaminho test√°vel‚Äù (alternativo ou inesperado) pode ter interpreta√ß√µes ligeiramente diferentes dependendo do contexto, mas normalmente √© usado para se referir a qualquer rota dentro do c√≥digo ou do fluxo da aplica√ß√£o que pode ser exercitada por um teste. √â o conjunto de caminhos poss√≠veis que o teste consegue alcan√ßar, incluindo o caminho feliz e tamb√©m as rotas alternativas, os cen√°rios de exce√ß√£o, entradas inv√°lidas, erros de neg√≥cio, falhas de integra√ß√£o, entre outros. Em outras palavras, n√£o √© s√≥ garantir que a fun√ß√£o principal funciona, mas tamb√©m que o sistema se comporta corretamente quando algo sai do esperado. √â a√≠ que entram testes negativos, de borda, de falha, de performance ou at√© mesmo de seguran√ßa, que exercitam a aplica√ß√£o de forma mais ampla e realista.

Portanto, quando voc√™ ouve falar de ‚Äúcaminho feliz‚Äù, √© um subconjunto do ‚Äúcaminho test√°vel‚Äù. O caminho feliz prova que o b√°sico funciona; o caminho test√°vel inclui todas as outras possibilidades para dar robustez √† aplica√ß√£o. Ou seja, o usu√°rio √© inesperado, ent√£o vamos precisar "preparar" a aplica√ß√£o para coisas inesperadas.

Dentro da distin√ß√£o cl√°ssica entre *QA (Quality Assurance)* e **QC (Quality Control)**, os testes de software se enquadram como atividades de QC, porque est√£o no n√≠vel da inspe√ß√£o e verifica√ß√£o do produto final. QA olha mais para os processos, prevenindo defeitos ao longo do ciclo (defini√ß√£o de padr√µes, auditorias de qualidade, pr√°ticas de engenharia), enquanto QC foca em detectar e validar defeitos no resultado tang√≠vel ‚Äî o software em execu√ß√£o, as integra√ß√µes funcionando, os requisitos sendo cumpridos.

Portanto, sim: quando falamos em **testes manuais, automatizados, de integra√ß√£o, de aceita√ß√£o, de regress√£o, de performance, etc.**, estamos atuando dentro da **camada de QC**. Eles s√£o o mecanismo pelo qual conseguimos transformar ‚Äúexpectativas de qualidade‚Äù em **evid√™ncias objetivas** de que o software funciona (ou n√£o) como esperado.

<img src="https://github.com/user-attachments/assets/bcc83195-9916-4d3a-8fe9-22a87ccf18f8" align="right" height="177">

> [!Important]
> Vantagens dos testes de software: Se voc√™ quer evoluir em testes de software e entender como integrar qualidade de forma colaborativa e cont√≠nua em equipes √°geis, o livro **"Agile Testing: A Practical Guide for Testers and Agile Teams"**, escrito por Lisa Crispin e Janet Gregory, √© uma leitura essencial para transformar a teoria em pr√°tica.
> 
> - Qualidade
> - Suporte ao time
> - Feedback constante
> - Produtividade
> - Documenta√ß√£o viva
> - Alinhamento com o neg√≥cio
> - Dissemina√ß√£o de conhecimento
> - Preven√ß√£o de bugs: Evitar a continua√ß√£o dos bugs
> - Redu√ß√£o de Custos

A defini√ß√£o de ‚Äúpronto‚Äù nada mais √© do que um contrato firmado entre o time e o PO, que lista de forma clara os requisitos que determinam que uma User Story est√° completa.

> E a resposta √© simples: normalmente, quando perguntam se uma funcionalidade ou story est√° pronta, respondem: ‚Äúsim, mas falta testar‚Ä¶‚Äù.

Isso significa que ao definir o conceito de ‚Äúpronto‚Äù, √© importante que o QA ‚Äì que faz parte do time ‚Äì esteja envolvido e possa sensibilizar os membros do time e PO para que os testes fa√ßam parte deste conceito.

Dessa forma, garantimos:

- Integra√ß√£o entre desenvolvedores e QA;
- Maior qualidade do time;
- Que n√£o haja desentendimentos desnecess√°rios;
- Story testada e com aceite formal.¬†

As atividades de apoio da qualidade de software, como revis√µes, auditorias e inspe√ß√µes, s√£o essenciais para garantir que o software seja produzido de acordo com os padr√µes de qualidade estabelecidos. Essas atividades podem ser realizadas em diferentes momentos do ciclo de vida do software, desde a an√°lise de requisitos at√© a manuten√ß√£o.
 
As **revis√µes** s√£o uma das atividades de apoio mais comuns e envolvem a an√°lise do software por um grupo de pessoas para detectar erros e poss√≠veis me
lhorias. Existem diferentes tipos de revis√µes, como revis√µes de c√≥digo (Code Reviews), revis√µes de documentos e revis√µes de design.
 
As **auditorias** s√£o semelhantes √†s revis√µes, mas geralmente s√£o realizadas por equipes independentes de pessoas com habilidades espec√≠ficas para avaliar o software em rela√ß√£o a padr√µes e regulamenta√ß√µes espec√≠ficos. As auditorias podem ser internas ou externas e podem ser realizadas em diferentes fases do ciclo de vida do software (BRITO, 2006).

J√° as **inspe√ß√µes** s√£o atividades mais formais e estruturadas, que seguem um processo espec√≠fico para avaliar o software em rela√ß√£o a determinados padr√µes e especifica√ß√µes. As inspe√ß√µes geralmente envolvem uma equipe multidisciplinar e podem ser realizadas em diferentes fases do ciclo de vida do software.

Essas atividades de apoio da qualidade de software s√£o importantes porque ajudam a identificar problemas no software antes que ele seja lan√ßado, reduzindo assim os custos e os riscos associados a falhas no software. Al√©m disso, elas tamb√©m podem ajudar a melhorar a efici√™ncia e a efic√°cia do processo de desenvolvimento de software (SHAMA, 2016).

Para aprofundar seu conhecimento sobre atividades de apoio da qualidade de software, voc√™ pode se perguntar: 

‚ñ† Quais s√£o as diferen√ßas entre as atividades de revis√£o, auditoria e inspe√ß√£o? 

‚ñ† Como as atividades de apoio podem ser integradas ao processo de desenvolvimento de software? 

‚ñ† Qual √© o papel dos diferentes membros da equipe na execu√ß√£o dessas atividades?

Al√©m disso, uma ilustra√ß√£o √∫til pode ser um diagrama que mostre a rela√ß√£o entre as atividades de apoio da qualidade de software e outras atividades do ciclo de vida do software, como desenvolvimento, teste e implanta√ß√£o. Isso pode ajudar a entender como as atividades de apoio se encaixam no processo geral de desenvolvimento de software e como elas podem contribuir para a melhoria da qualidade do produto final.

<div align="center"><img width="551" height="351" alt="image" src="https://github.com/user-attachments/assets/d9decc9c-a526-4733-bf66-c5cd63aaba1e" /></div>

√â importante destacar que a observabilidade (observability) n√£o √© exatamente parte do QA no sentido tradicional, mas ela se conecta de forma muito natural com a qualidade do software. QA (Quality Assurance) historicamente √© voltado para preven√ß√£o de defeitos, valida√ß√£o e verifica√ß√£o de requisitos, testes funcionais, n√£o funcionais e processos que garantem que o produto atenda ao que foi especificado. Observabilidade, por outro lado, nasceu com foco na opera√ß√£o e na confiabilidade: √© a capacidade de entender o que est√° acontecendo em um sistema, em tempo real, a partir de sinais como logs, m√©tricas e traces. Ela vai al√©m de simplesmente monitorar: √© sobre ser capaz de responder perguntas desconhecidas sobre o comportamento do sistema.

A rela√ß√£o entre as duas √°reas est√° no fato de que quanto mais observ√°vel um sistema √©, mais f√°cil fica detectar, diagnosticar e corrigir problemas que impactam a qualidade. QA tradicional muitas vezes termina antes da aplica√ß√£o ir para produ√ß√£o, mas bugs e falhas ainda podem aparecer em ambientes reais. Com observabilidade, voc√™ complementa os testes com uma vis√£o cont√≠nua, onde √© poss√≠vel acompanhar a sa√∫de, a performance, os gargalos e at√© o comportamento do usu√°rio. Para equipes modernas, especialmente em DevOps e SRE, a linha entre QA e observabilidade se mistura um pouco, pois qualidade n√£o √© mais s√≥ ‚Äútestar antes de subir‚Äù, mas tamb√©m garantir que o produto em execu√ß√£o esteja saud√°vel, rastre√°vel e confi√°vel.

Portanto, observabilidade pode ser vista como complementar ao QA, n√£o substitui testes e processos de qualidade, mas amplia a seguran√ßa e o controle. Muitas equipes de alto desempenho hoje tratam a observabilidade como parte essencial da estrat√©gia de qualidade, especialmente quando o sistema √© distribu√≠do, usa microsservi√ßos, filas, integra√ß√µes externas ou precisa de alta disponibilidade.

## [QA] Custos x Fases
<img width="524" height="241" align="right" src="https://github.com/user-attachments/assets/a3aaded7-0fad-4ba5-9b0a-9d664bf0dc8e" />

Voc√™ sabia que a qualidade de um software pode impactar diretamente nos custos de uma empresa? Os **Custos de controle** em qualidade de software se referem aos gastos necess√°rios para prevenir defeitos e garantir a qualidade dos produtos de software, bem como para corrigir quaisquer defeitos encontrados durante as fases de desenvolvimento 
e teste. 

Esses custos podem incluir investimentos em treinamento, ferramentas de teste, testes manuais e automatizados, revis√µes de c√≥digo e outras atividades de garantia de qualidade. 

Ao investir em custos de controle, as organiza√ß√µes podem reduzir o n√∫mero de defeitos encontrados nos produtos de software (custos de preven√ß√£o) e, consequentemente, minimizar os custos associados a falhas de software, como retrabalho, atrasos no cronograma, perda de receita e reputa√ß√£o negativa (custos de avalia√ß√£o).
 
As falhas internas s√£o aquelas que acontecem dentro da empresa, antes do produto final ser entregue ao cliente. Elas podem ser causadas por diversos motivos, como falta de capacita√ß√£o da equipe, problemas de comunica√ß√£o, dentre outros. Essas falhas podem levar a retrabalho, atrasos na entrega e insatisfa√ß√£o do cliente.

J√° as **falhas externas** s√£o aquelas que ocorrem ap√≥s a entrega do produto final ao cliente. Elas podem ser causadas por problemas na codifica√ß√£o, falhas de seguran√ßa, dentre outros fatores. Essas falhas podem gerar custos alt√≠ssimos para a empresa, como a necessidade de retrabalho, de suporte t√©cnico, de processos judiciais e at√© mesmo a perda de clientes

> [!Warning]
> Para aprofundar seu conhecimento sobre os custos de qualidade de software, voc√™ pode se perguntar: quais s√£o as principais causas de falhas internas e externas? Como a qualidade do software pode influenciar nos custos da empresa? Como √© poss√≠vel reduzir esses custos e melhorar a qualidade do produto final?

<img height="177" align="right" src="https://github.com/user-attachments/assets/4d60adb8-9629-4605-ae7f-8b97798f7699" />

A **Regra 10 de Myers**, criada em 2004 por Glenford Myers, √© uma importante diretriz para os analistas de teste de software. Essa regra afirma que toda falha no software deve ser rastre√°vel a uma a√ß√£o ou decis√£o espec√≠fica tomada durante o desenvolvimento do software.

> A ilustra√ß√£o mostra um gr√°fico que representa os custos de corre√ß√£o associados a cada est√°gio do ciclo de desenvolvimento de software. No lado esquerdo, h√° uma linha vertical que corresponde ao eixo Y, onde est√° inscrito "Custo da corre√ß√£o do defeito". Na parte inferior, h√° uma linha horizontal que se junta √† linha vertical, formando uma grade para marcar os est√°gios do ciclo no eixo X. Abaixo dessa linha vertical est√° escrito da esquerda para a direita: An√°lise, Especifica√ß√£o, Constru√ß√£o, Testes e Produ√ß√£o. No interior do gr√°fico h√° uma linha vermelha com cinco c√≠rculos amarelos.

Em outras palavras, a Regra 10 de Myers enfatiza  que o custo da corre√ß√£o de defeitos √© bem mais custoso quanto mais tarde o defeito √© encontrado, ou seja, um defeito encontrado em produ√ß√£o custa muito mais do que se fosse encontrado na fase de an√°lise ou em modelos de dados.

Uma boa gest√£o de qualidade pode ser a chave para minimizar os custos relacionados √†s falhas em software. Investir em capacita√ß√£o da equipe, em boas pr√°ticas de desenvolvimento e em testes constantes pode ajudar a evitar falhas internas e externas e, consequentemente, reduzir os custos para a empresa.

O **Shift Left Testing** √© um conceito dentro da engenharia de software e de testes que significa **trazer as atividades de teste para mais cedo no ciclo de desenvolvimento**. Tradicionalmente, em modelos como o *waterfall*, os testes s√≥ aconteciam no fim, depois que o c√≥digo j√° estava implementado. Isso levava a atrasos, altos custos de corre√ß√£o e ac√∫mulo de defeitos. O movimento de ‚Äúshift left‚Äù (deslocar para a esquerda, no cronograma) √© justamente antecipar a valida√ß√£o de qualidade para as fases iniciais ‚Äî an√°lise de requisitos, design e at√© antes de escrever c√≥digo ‚Äî com o objetivo de encontrar problemas cedo, quando ainda s√£o baratos de corrigir.

E isso se conecta com a famosa Regra de 10 de Myers (ou Myers‚Äô Rule of Ten). A regra, proposta por Glenford Myers, diz que:

> ‚ÄúO custo para corrigir um defeito aumenta em uma ordem de grandeza (10x) a cada fase posterior do ciclo de desenvolvimento em que ele √© encontrado.‚Äù

Na pr√°tica, **shift left** se traduz em v√°rias pr√°ticas modernas. Envolve escrever crit√©rios de aceita√ß√£o e testes antes da implementa√ß√£o (TDD, ATDD, BDD), fazer testes unit√°rios e de integra√ß√£o cont√≠nuos, usar pipelines de CI/CD para rodar automaticamente baterias de testes a cada commit, e at√© aplicar ferramentas de an√°lise est√°tica e valida√ß√µes de seguran√ßa durante o desenvolvimento. Tamb√©m pode incluir colabora√ß√£o mais pr√≥xima entre desenvolvedores, QAs e analistas de neg√≥cio logo no in√≠cio, evitando que requisitos mal entendidos s√≥ sejam percebidos no final.

O grande benef√≠cio √© que, quanto mais cedo um bug √© descoberto, menor o impacto t√©cnico e financeiro para o projeto. Por isso, ‚Äúshift left testing‚Äù n√£o significa apenas testar antes, mas criar uma cultura de **qualidade incorporada desde o in√≠cio**, em vez de tratada como etapa final. √â um complemento direto de metodologias √°geis e DevOps, porque apoia ciclos r√°pidos, entregas frequentes e feedback constante.

<img align="right" height="177" alt="image" src="https://github.com/user-attachments/assets/b99bfaa0-07bf-4497-b544-d45d91f1fe50" />

> [!Important]
> **Qualidade De Software Na Pr√°tica - Como Reduzir O Custo De Manuten√ß√£o**: Para aprofundar seus conhecimentos sobre avalia√ß√£o de atributos de qualidade, recomendamos a leitura do livro Qualidade De Software Na Pr√°tica - Como Reduzir O Custo De Manuten√ß√£o √© um livro escrito por Alexandre Kherroubi e Adalberto Cavalcanti. O livro aborda a import√¢ncia da qualidade de software na redu√ß√£o dos custos de manuten√ß√£o e explora estrat√©gias pr√°ticas para melhorar a qualidade do software, resultando em um impacto positivo nos custos de manuten√ß√£o ao longo do ciclo de vida do software.

## [QA] Padr√µes de Qualidade de Software
Os padr√µes de qualidade de software s√£o conjuntos de pr√°ticas, regras e diretrizes que visam garantir a qualidade do software produzido. Eles s√£o uma refer√™ncia para desenvolvedores e equipes de qualidade, ajudando a garantir que o software produzido seja confi√°vel, seguro e atenda aos requisitos do usu√°rio.

Os padr√µes de qualidade de software podem ser baseados em normas internacionais , como a ISO/IEC 12207 e a ISO/IEC 9126, ou podem ser espec√≠ficos para uma ind√∫stria ou empresa. Eles podem cobrir todos os aspectos do ciclo de vida do software, desde a especifica√ß√£o de requisitos at√© a manuten√ß√£o e evolu√ß√£o do software.

Os padr√µes de qualidade de software podem ser baseados em normas internacionais.

> VOC√ä SABE RESPONDER? Como os padr√µes de qualidade de software podem ajudar a melhorar a confiabilidade e seguran√ßa do software?

Um dos principais benef√≠cios dos padr√µes de qualidade de software √© que eles fornecem uma base s√≥lida para a avalia√ß√£o da qualidade do software (GALINAC, 2013). Os padr√µes de qualidade de software, como o **CMM (Capability Maturity Model)** e o **MPS-BR  (Melhoria de Processo do Software Brasileiro)**, foram desenvolvidos para melhorar a qualidade dos processos e produtos de software.

O CMM foi criado pelo SEI (Software Engineering Institute) nos anos 1990, com o objetivo de estabelecer um modelo de maturidade para avaliar a capacidade dos processos de software em uma organiza√ß√£o (CMMI-DEV V2.0, 2018). 

O modelo √© baseado em cinco n√≠veis, que representam um aumento gradual da maturidade do processo, desde o n√≠vel 1, que √© o mais baixo, at√© o n√≠vel 5, que √© o mais alto. Cada n√≠vel tem seus pr√≥prios objetivos, pr√°ticas e √°reas de processo. 

O CMM √© amplamente utilizado para avaliar a maturidade dos processos de software em organiza√ß√µes governamentais e privadas em todo o mundo.

## [QA] Self testing
![Jest](https://img.shields.io/badge/-Jest-EF2D5E?style=badge&logo=jest&logoColor=white)
![Mocha](https://img.shields.io/badge/-Mocha-EF2D5E?style=badge&logo=mocha&logoColor=white)
![JUnit5](https://img.shields.io/badge/-JUnit5-EF2D5E?style=badge&logo=JUnit5&logoColor=white) 
![xUnit](https://img.shields.io/badge/-xUnit-EF2D5E?style=badge&logo=.NET&logoColor=white) 
![Cucumber](https://img.shields.io/badge/-Cucumber-23D96C?style=badge&logo=cucumber&logoColor=white)
![Selenium](https://img.shields.io/badge/-Selenium-limegreen?style=badge&logo=Selenium&logoColor=white)
![Appium](https://img.shields.io/badge/-Appium-EE376D?style=badge&logo=Appium&logoColor=white)
![Apache JMeter](https://img.shields.io/badge/-Apache_JMeter-D22128?style=badge&logo=apachejmeter&logoColor=white)
![Cypress](https://img.shields.io/badge/-Cypress-505050?style=badge&logo=cypress&logoColor=white)
![Robot Framework](https://img.shields.io/badge/-Robot_Framework-000000?style=badge&logo=robotframework&logoColor=white)

<a href="https://martinfowler.com/articles/practical-test-pyramid.html"><img src="https://www.pcloudy.com/wp-content/uploads/2019/07/functional-testing.png" align="right" height="277"></a>

O conceito de **self-testing** em software vem da ideia de que o pr√≥prio sistema deve ter meios embutidos para validar se est√° funcionando corretamente, sem depender de verifica√ß√µes externas e ocasionais. Em ess√™ncia, √© a no√ß√£o de que a aplica√ß√£o deve trazer consigo a capacidade de se ‚Äúautoavaliar‚Äù. 

Isso pode se manifestar de formas diferentes dependendo do contexto: em n√≠vel de c√≥digo, por meio de uma su√≠te de testes automatizados que √© executada sempre que o sistema √© constru√≠do ou implantado; em n√≠vel operacional, com health checks, m√©tricas, logs e alertas que confirmam se o servi√ßo est√° √≠ntegro; ou ainda em processos de QA, onde o produto √© constantemente validado contra crit√©rios de aceita√ß√£o definidos.

Dentro desse conceito, **testes automatizados** s√£o o n√∫cleo natural do self-testing, porque permitem verificar de forma cont√≠nua e repet√≠vel se o c√≥digo ainda atende √†s especifica√ß√µes √† medida que evolui. √â nesse ponto que pr√°ticas como **TDD** se encaixam perfeitamente: ao escrever primeiro o teste e depois o c√≥digo, o desenvolvedor garante que cada parte do sistema j√° nasce coberta por verifica√ß√µes, criando um software que j√° vem com seus pr√≥prios ‚Äúexames de sa√∫de‚Äù. Al√©m disso, TDD gera uma rede de seguran√ßa de regress√£o, que torna o sistema mais resistente a falhas ao longo do tempo.

> "Descobrir o inesperado √© mais importante do que confirmar o conhecido." - George E.P.Box

J√° os **testes manuais** tamb√©m podem existir em um cen√°rio de self-testing, mas n√£o cumprem totalmente a proposta. Eles servem bem em situa√ß√µes explorat√≥rias, de usabilidade ou de descoberta de casos n√£o previstos, mas n√£o garantem a automa√ß√£o e a repetibilidade que o conceito prega. Em outras palavras, um sistema pode at√© contar com testes manuais complementares, mas n√£o se considera realmente ‚Äúself-testing‚Äù se depende s√≥ deles, porque n√£o h√° como o software se validar sozinho sem a interven√ß√£o humana.

Portanto, podemos dizer que o self-testing **aceita testes manuais como complemento**, mas a ess√™ncia dele est√° nos **testes automatizados**, preferencialmente guiados por boas pr√°ticas como TDD ou ATDD, que d√£o disciplina e cobertura consistente ao ciclo de desenvolvimento.

Estudamos os branches, os workflows e conclu√≠mos que dentro da pr√°tica da integra√ß√£o cont√≠nua, devemos nos afastar o m√≠nimo poss√≠vel do nosso trunk master principal.

Com as altera√ß√µes que realizamos o tempo todo em nosso software, como podemos garantir a qualidade do c√≥digo? Testes. No caso da integra√ß√£o cont√≠nua, precisaremos utilizar testes automatizados. O ideal √© que a cada altera√ß√£o, seja realizado um novo teste automatizado, para termos certeza de nenhum problema ser√° gerado.

- Testes fazem parte da constru√ß√£o do software;
- Devem ser realizados antes do commit;
- TDD pode ajudar neste processo;
- Desempenho bom em testes;
- Os testes demorados podem ser uma barreira para a integra√ß√£o cont√≠nua, por isso precisamos ficar atentos.

## [QA] Automation testing
![Jest](https://img.shields.io/badge/-Jest-EF2D5E?style=badge&logo=jest&logoColor=white)
![Mocha](https://img.shields.io/badge/-Mocha-EF2D5E?style=badge&logo=mocha&logoColor=white)
![JUnit5](https://img.shields.io/badge/-JUnit5-EF2D5E?style=badge&logo=JUnit5&logoColor=white) 
![xUnit](https://img.shields.io/badge/-xUnit-EF2D5E?style=badge&logo=.NET&logoColor=white) 
![Cucumber](https://img.shields.io/badge/-Cucumber-23D96C?style=badge&logo=cucumber&logoColor=white)
![Selenium](https://img.shields.io/badge/-Selenium-limegreen?style=badge&logo=Selenium&logoColor=white)
![Appium](https://img.shields.io/badge/-Appium-EE376D?style=badge&logo=Appium&logoColor=white)
![Apache JMeter](https://img.shields.io/badge/-Apache_JMeter-D22128?style=badge&logo=apachejmeter&logoColor=white)
![Cypress](https://img.shields.io/badge/-Cypress-505050?style=badge&logo=cypress&logoColor=white)
![Robot Framework](https://img.shields.io/badge/-Robot_Framework-000000?style=badge&logo=robotframework&logoColor=white)

<img src="https://github.com/IsaacAlves7/DevSecOps/assets/61624336/7ae43145-a45f-49a5-98ae-693912faae5d" align="right" height="77">

Conforme o tempo passa a tecnologia segue avan√ßando e os sistemas que s√£o desenvolvidos por pessoas da √°rea de TI est√£o cada vez mais completos. Antigamente os testes manuais eram os mais utilizados, mas eles j√° n√£o suprem mais √†s demandas das empresas e acabam sendo suscet√≠veis a erros. Ent√£o, as organiza√ß√µes precisam desenvolver mais e com melhor qualidade, √© a√≠ que entram os **testes automatizados** que s√£o programas que executam testes em softwares que est√£o em constru√ß√£o de uma forma padronizada, sem ser necess√°rio a interven√ß√£o humana.

Pois, tais testes possuem funcionalidades capazes de testar de forma autom√°tica todos os aspectos de uma plataforma, com o intuito de assegurar um desempenho adequado. Ou seja, a automa√ß√£o de teste √© o uso de software para controlar a execu√ß√£o do teste de software, a compara√ß√£o dos resultados esperados com os resultados reais, a configura√ß√£o das pr√©-condi√ß√µes de teste e outras fun√ß√µes de controle e relat√≥rio de teste. 

Tal procedimento, gera muito mais efic√°cia e agilidade na etapa de testes, permitindo que o profissional encontre de uma maneira mais f√°cil as falhas de seguran√ßa, bugs e demais erros que possam comprometer o uso da aplica√ß√£o.

> Quando o profissional notar que est√° gastando muito tempo com tarefas repetitivas e quando o software est√° muito grande, pode ser a hora de automatizar. Mas, √© necess√°rio tamb√©m questionar a viabilidade dessa a√ß√£o, sendo essencial analisar se com a automa√ß√£o a equipe ir√° obter ganho de tempo e se conseguir√£o reduzir custos e manter a qualidade.

Testes automatizados s√£o uma das pr√°ticas mais fundamentais no desenvolvimento de software moderno, pois garantem confiabilidade, reduzem bugs em produ√ß√£o, facilitam refatora√ß√µes e melhoram a documenta√ß√£o viva do sistema. Para construir testes automatizados realmente bons, √© preciso compreender n√£o s√≥ as ferramentas, mas tamb√©m o processo como um todo ‚Äî desde a fase de planejamento at√© a execu√ß√£o cont√≠nua. Tudo come√ßa pela compreens√£o dos **n√≠veis de teste**: 

<img src="https://user-images.githubusercontent.com/61624336/128188070-c1fff724-f895-4501-bdca-dbab78dca6b1.png" height="277" align="right"> 

1. **Testes de unidade** (isolam pequenas partes do c√≥digo),

2. **Testes de integra√ß√£o** (verificam a comunica√ß√£o entre partes),

3. **Testes de sistema** (validam o sistema como um todo) e

4. **Testes end-to-end** (simulam o comportamento real do usu√°rio).

Cada n√≠vel exige aten√ß√£o diferente e ferramentas espec√≠ficas:

No in√≠cio do ciclo, o **desenho dos testes** precisa ser baseado em crit√©rios claros de cobertura: o que est√° sendo testado, por que est√° sendo testado e o que n√£o precisa ser testado. Bons testes n√£o s√£o s√≥ aqueles que passam, mas aqueles que falham quando o comportamento do c√≥digo foge do esperado. Para isso, as asser√ß√µes precisam ser claras, espec√≠ficas e rastre√°veis. Boas pr√°ticas incluem escrever testes que sejam r√°pidos, isolados, determin√≠sticos e leg√≠veis. Um teste bom √© aquele que algu√©m consegue entender o que ele verifica s√≥ de ler o seu nome e o corpo, sem necessidade de ir at√© a implementa√ß√£o testada.

A fase de ferramentas √© t√£o importante quanto o planejamento. Para testes de unidade, temos ferramentas como **JUnit** (Java), **xUnit** (C#), **pytest** (Python), **Jest** e **Vitest** (JavaScript/TypeScript), **Elixir ExUnit**, entre outras. Para mocks e test doubles, usamos bibliotecas como **Moq**, **Sinon**, **Mockito** ou **NSubstitute**, que ajudam a isolar depend√™ncias externas, como chamadas a APIs, bancos de dados e arquivos. Em testes de integra√ß√£o, frameworks como **TestContainers**, **WireMock** ou bancos de dados em mem√≥ria ajudam a montar ambientes realistas. Para testes de aceita√ß√£o e end-to-end, ferramentas como **Cypress**, **Playwright**, **Selenium** e **Puppeteer** s√£o as mais utilizadas, permitindo testes que interagem com o navegador ou sistema completo, validando fluxos reais.

<img src="https://github.com/IsaacAlves7/DevSecOps/assets/61624336/52a5bb6f-070c-4635-8de1-43db6d07500d" height="277" align="right"> 

Na constru√ß√£o de um bom teste automatizado, o primeiro passo √© **nomear corretamente o que est√° sendo testado**, depois criar um ambiente previs√≠vel para que os testes n√£o tenham falsos positivos ou negativos. Um teste que falha √†s vezes √© um teste ruim. Depois, **seguir o padr√£o AAA** (Arrange, Act, Assert) √© uma boa pr√°tica: configurar os dados e depend√™ncias, executar o comportamento que est√° sendo testado, e por fim verificar o resultado. Tamb√©m √© essencial n√£o testar l√≥gica interna demais (isso gera testes fr√°geis), mas focar no comportamento observ√°vel da fun√ß√£o ou componente.

Outro pilar crucial √© a **integra√ß√£o com pipelines de CI/CD**. Automatizar os testes via GitHub Actions, GitLab CI, Jenkins ou Azure DevOps garante que os testes rodam a cada push ou PR, evitando regress√µes. Um teste que s√≥ roda localmente √© praticamente in√∫til em um time com m√∫ltiplos desenvolvedores.

Al√©m disso, n√£o se deve esquecer do **relato dos testes**. Ferramentas de coverage (cobertura de c√≥digo) como **Istanbul**, **Coverlet** ou **Codecov** ajudam a visualizar o quanto do c√≥digo est√° sendo testado, embora **cobertura alta n√£o signifique qualidade alta** ‚Äî √© poss√≠vel ter 100% de cobertura e testes in√∫teis. O ideal √© buscar cobertura √∫til, ou seja, testes que validam fluxos importantes, limites, erros e casos reais de uso.

Por fim, construir um teste automatizado bom exige pr√°tica, disciplina e conhecimento. N√£o √© s√≥ sobre ferramentas, mas sobre escrever c√≥digo de teste que seja confi√°vel, f√°cil de manter e que reflita as regras de neg√≥cio do sistema. √â preciso ter clareza sobre o que vale a pena testar, manter a su√≠te de testes r√°pida e identificar o ponto de equil√≠brio entre cobertura e custo de manuten√ß√£o. Testes automatizados s√£o investimento ‚Äî e como todo investimento, precisam de foco, consist√™ncia e revis√£o cont√≠nua para darem retorno real.

O desenvolvimento, inspe√ß√£o e o teste de unidade s√£o as tr√™s partes do teste de c√≥digos. Numa era onde tudo √© automatizado, testadores de software tem demandado cada vez mais ferramentas de automa√ß√£o de testes. Veja algumas ferramentas para automa√ß√£o de testes:

<img src="https://github.com/user-attachments/assets/3c87b05b-6715-4178-8166-9bf528c4e3ff" height="77" align="right"> 

1. **Selenium**: √© um framework port√°til para testar aplicativos web. O Selenium fornece uma ferramenta de reprodu√ß√£o para a cria√ß√£o de testes funcionais sem a necessidade de aprender uma linguagem de script de teste. √â provavelmente a ferramenta de automa√ß√£o de testes mais conhecida e utilizada no mundo, especialmente quando o foco s√£o aplica√ß√µes web. Diferente de solu√ß√µes comerciais como Ranorex, UFT ou TestComplete, ele √© open source, o que significa que n√£o h√° custo de licen√ßa e ele pode ser adaptado de acordo com as necessidades do time. Esse fator, aliado √† sua flexibilidade, fez do Selenium uma esp√©cie de padr√£o de fato em automa√ß√£o de testes web, sendo adotado desde startups at√© grandes corpora√ß√µes.

2. **Robot Framework**: √© uma estrutura gen√©rica de automa√ß√£o de teste para testes de aceita√ß√£o e desenvolvimento orientado a testes de aceita√ß√£o. √â uma estrutura de teste orientada por palavras-chave que usa a sintaxe de dados de teste tabular. 

3. **Robotium**: √© um framework open source de automa√ß√£o de testes voltado especificamente para aplica√ß√µes Android. Ele surgiu como uma resposta √† necessidade de se criar testes funcionais e de interface de forma mais pr√°tica e menos trabalhosa do que o que era oferecido nativamente pela API de testes do Android. Diferente de solu√ß√µes que focam em testes unit√°rios ou apenas em pequenas partes da aplica√ß√£o, o Robotium foi desenhado para permitir que voc√™ crie testes que simulam a intera√ß√£o real de um usu√°rio com o aplicativo, clicando em bot√µes, digitando em campos, navegando por telas e validando os resultados exibidos. Ele funciona essencialmente como uma camada que se apoia no JUnit e traz uma API mais rica e amig√°vel para lidar com a interface de usu√°rio.

4. **Cucumber**: √© uma ferramenta de automa√ß√£o de testes que se popularizou por trazer uma abordagem muito forte de BDD (Behavior-Driven Development) para o dia a dia do desenvolvimento de software. Diferente de frameworks mais t√©cnicos, que focam em testes unit√°rios ou funcionais a partir do c√≥digo, o Cucumber tem como diferencial a ideia de que os testes devem ser escritos em uma linguagem acess√≠vel a todos do time ‚Äî n√£o apenas a desenvolvedores. Ele utiliza a sintaxe Gherkin, que √© baseada em descri√ß√µes de comportamento no formato de cen√°rios, usando estruturas como Dado‚ÄìQuando‚ÄìEnt√£o. Isso permite que pessoas de neg√≥cio, analistas de QA e desenvolvedores conversem sobre o sistema usando a mesma forma de especifica√ß√£o, diminuindo ambiguidades e garantindo que todos entendam da mesma maneira o que est√° sendo implementado.

5. **Playwright**: √© uma ferramenta criada com foco em testes automatizados de aplica√ß√µes web, mas seu prop√≥sito vai um pouco al√©m disso, porque ele tamb√©m pode ser usado como uma biblioteca de automa√ß√£o de navega√ß√£o. A origem dele est√° na mesma equipe que desenvolveu o Puppeteer, do Google, mas a Microsoft o criou para oferecer mais robustez, abrang√™ncia e recursos modernos. O Playwright permite em testes com Cross-browser (Chrome Firefox etc) para aplica√ß√µes web, emula√ß√£o Mobile para simular dispositivos m√≥veis, e testes de API trata requisi√ß√µes HTTP.

6. TestComplete: √© uma ferramenta comercial de automa√ß√£o de testes desenvolvida pela SmartBear que tem como foco facilitar a cria√ß√£o, execu√ß√£o e manuten√ß√£o de testes funcionais em diferentes tipos de aplica√ß√µes, desde desktop, web at√© mobile. A grande proposta dela √© oferecer uma plataforma robusta que permite tanto a quem tem experi√™ncia em programa√ß√£o quanto a quem n√£o programa criar testes de forma eficiente. Isso √© poss√≠vel porque ela oferece duas formas de trabalho: por um lado, h√° a possibilidade de construir scripts completos em linguagens como Python, JavaScript, VBScript e outras suportadas, o que d√° liberdade total para quem tem familiaridade com c√≥digo; por outro lado, ela tamb√©m disponibiliza recursos de grava√ß√£o e reprodu√ß√£o, em que o testador interage com a aplica√ß√£o e o TestComplete grava essas intera√ß√µes para gerar um script automaticamente, que depois pode ser reutilizado e refinado.

7. Telerik Test Studio: √© uma ferramenta de automa√ß√£o de testes desenvolvida pela Progress, criada para simplificar e acelerar o processo de valida√ß√£o de software em diferentes tipos de aplica√ß√µes, desde web, desktop at√© aplicativos responsivos e mobile. O grande diferencial dela √© o foco em ser acess√≠vel para equipes que n√£o necessariamente t√™m profundo conhecimento em programa√ß√£o, ao mesmo tempo em que entrega recursos avan√ßados que podem ser explorados por engenheiros de testes mais experientes. Assim como outras solu√ß√µes comerciais, a proposta √© unir praticidade, estabilidade e integra√ß√£o com o ciclo de desenvolvimento.

8. HPE Unified Functional Testing: anteriormente conhecido como HP QuickTest Professional (QTP), √© uma das ferramentas mais tradicionais e consolidadas de automa√ß√£o de testes funcionais. Ele foi desenvolvido pela Hewlett-Packard (hoje Micro Focus, depois da aquisi√ß√£o da divis√£o de software da HPE) e √© amplamente utilizado em grandes corpora√ß√µes que precisam validar aplica√ß√µes complexas, que muitas vezes envolvem uma mistura de sistemas legados, aplica√ß√µes web modernas e at√© integra√ß√µes entre diferentes tecnologias. O grande diferencial do UFT sempre foi a abrang√™ncia tecnol√≥gica: ele suporta automa√ß√£o em aplica√ß√µes desktop, web, SAP, Oracle, PeopleSoft, aplica√ß√µes client-server, APIs e at√© mobile, tudo em uma √∫nica plataforma, reduzindo a necessidade de v√°rias ferramentas diferentes.

9. Ranorex: √© uma ferramenta comercial de automa√ß√£o de testes que ganhou bastante destaque justamente por tentar simplificar e unificar a automa√ß√£o em diferentes tipos de aplica√ß√µes, cobrindo desde softwares desktop, sistemas web at√© aplicativos mobile. Ele √© muito utilizado em ambientes corporativos onde existe a necessidade de automatizar aplica√ß√µes complexas, que muitas vezes envolvem tecnologias legadas misturadas com plataformas modernas. Seu grande diferencial √© oferecer uma interface visual poderosa, que permite a cria√ß√£o de testes sem exigir conhecimento avan√ßado em programa√ß√£o, mas ao mesmo tempo dar liberdade para quem domina c√≥digo escrever scripts mais sofisticados em linguagens como C# e VB.NET, j√° que o Ranorex √© baseado no ecossistema .NET.

10. Visual Studio Test Professional: √© uma edi√ß√£o do Visual Studio voltada especificamente para gest√£o e execu√ß√£o de testes de software dentro do ecossistema da Microsoft. Ele n√£o √© apenas um IDE, mas uma su√≠te de ferramentas pensada para equipes de QA e de desenvolvimento que precisam trabalhar de forma integrada em projetos com pr√°ticas √°geis e DevOps. Enquanto vers√µes como o Visual Studio Enterprise s√£o mais amplas e englobam todo o ciclo de desenvolvimento, o Test Professional √© um produto direcionado para o ciclo de vida de testes, oferecendo recursos de planejamento, acompanhamento e execu√ß√£o.

11. TestingWhiz: √© uma ferramenta de automa√ß√£o de testes voltada principalmente para equipes que buscam praticidade e velocidade na cria√ß√£o de testes, sem depender fortemente de programa√ß√£o. Diferente de frameworks open source como Selenium, que exigem bastante conhecimento t√©cnico e montagem de infraestrutura, o TestingWhiz aposta em uma abordagem codeless, baseada em uma interface visual intuitiva onde o testador pode construir fluxos de teste arrastando e configurando blocos de a√ß√µes pr√©-definidas. Isso o torna bastante atraente para equipes de QA funcionais ou para empresas que querem introduzir automa√ß√£o de forma r√°pida, sem exigir que todo o time saiba programar.

Existem muitas ferramentas de testes automatizados dispon√≠veis para diversas linguagens de programa√ß√£o e tipos de testes. Aqui est√£o algumas das mais populares, categorizadas por seu prop√≥sito principal:

<img height="377" align="right" src="https://github.com/user-attachments/assets/48562bf1-72a0-453b-aa21-cc58155a6a3c" />

1. **Frameworks de Teste Unit√°rio**:
   - **JUnit**: Framework de testes unit√°rios para Java. 
  
   - **NUnit**: Framework de testes unit√°rios para .NET.

   - **PyTest**: Framework de testes para Python.

   - **Mocha**: Framework de testes para JavaScript e Node.js.
  
   - **RSpec**: Framework de testes para Ruby.

   - **TestNG**: Outro framework de testes para Java.

2. **Ferramentas de Teste de Integra√ß√£o e Funcional**:

   - **Selenium**: Automa√ß√£o de navegadores para testes de aplica√ß√µes web.
  
   - **Cypress**: Ferramenta de teste de front-end para aplica√ß√µes web modernas.
   
   - **Protractor**: Ferramenta de teste de end-to-end para aplica√ß√µes Angular.

   - **Watir**: Ferramenta de automa√ß√£o de testes para aplica√ß√µes web.

3. **Ferramentas de Teste de Interface de Usu√°rio (UI)**:
  
   - **Appium**: Framework de automa√ß√£o para aplica√ß√µes m√≥veis (iOS e Android).
   
   - **TestComplete**: Ferramenta de automa√ß√£o de testes para aplica√ß√µes desktop, web e m√≥veis.
  
   - **Ranorex**: Ferramenta de automa√ß√£o de testes para desktop, web e dispositivos m√≥veis.

4. **Ferramentas de Teste de Performance e Carga**:
  
   - **JMeter**: Ferramenta para testes de carga e performance.
  
   - **Gatling**: Ferramenta de teste de carga focada em aplica√ß√µes web.
  
   - **LoadRunner**: Ferramenta de teste de carga e performance da Micro Focus.

5. **Ferramentas de Teste de Seguran√ßa**:
  
   - **OWASP ZAP**: Ferramenta para testes de penetra√ß√£o de aplica√ß√µes web.
  
   - **Burp Suite**: Ferramenta de teste de seguran√ßa para aplica√ß√µes web.
  
   - **Acunetix**: Ferramenta de varredura de seguran√ßa para aplica√ß√µes web.

6. **Ferramentas de Teste de APIs**:
  
   - **Postman**: Ferramenta para teste de APIs RESTful.
  
   - **SoapUI**: Ferramenta de teste para servi√ßos web SOAP e REST.
  
   - **RestAssured**: Biblioteca para teste de APIs REST em Java.

7. **Ferramentas de Integra√ß√£o Cont√≠nua**:
  
   - **Jenkins**: Ferramenta de integra√ß√£o cont√≠nua que pode ser usada para executar testes automatizados.
  
   - **GitHub Actions**: Servi√ßo de integra√ß√£o e entrega cont√≠nua integrado ao GitHub.

   - **GitLab CI/CD**: Ferramenta de integra√ß√£o cont√≠nua e entrega cont√≠nua do GitLab.

   - **CircleCI**: Servi√ßo de integra√ß√£o cont√≠nua e entrega cont√≠nua.

8. **Ferramentas de An√°lise de C√≥digo e Cobertura de Testes**:

   - **SonarQube**: Ferramenta de an√°lise est√°tica de c√≥digo que tamb√©m mede a cobertura de testes.

   - **JaCoCo**: Ferramenta de cobertura de testes para Java.

   - **Cobertura**: Ferramenta de cobertura de testes para Java.

   - **Istanbul**: Ferramenta de cobertura de testes para JavaScript.

Essas ferramentas ajudam a automatizar diferentes tipos de testes, desde testes unit√°rios b√°sicos at√© testes de performance e seguran√ßa, garantindo a qualidade e a estabilidade do software durante todo o ciclo de desenvolvimento.

## [QA] Unit testing
<img src="https://img.shields.io/badge/Jest-fail-%23C21325?style=flat&logo=jest&logoColor=white"> <img src="https://img.shields.io/badge/Mock-pass-chocolate?style=flat&logo=Mock&logoColor=white"> <img src="https://img.shields.io/badge/Go-passing-00ADD8?style=flat&logo=Go&logoColor=white"> <img src="https://img.shields.io/badge/PHPUnit-8.2-777BB4?style=flat&logo=PHP&logoColor=white"> <img src="https://img.shields.io/badge/-Pytest-blue?style=badge&logo=Pytest&logoColor=white"> <img src="https://img.shields.io/badge/JUnit5-passing-25A162?style=flat&logo=JUnit5&logoColor=white"> <img src="https://img.shields.io/badge/xUnit.net-8_pass_0_fail-512BD4?style=flat&logo=DotNet&logoColor=white">

<img src="https://em-content.zobj.net/source/microsoft-teams/363/test-tube_1f9ea.png" height="77" align="right">

Os **testes unit√°rios** ou **testes de unidade** (unit tests) √© toda a aplica√ß√£o de teste nas assinaturas de entrada e sa√≠da de um sistema. Consiste em validar dados v√°lidos e inv√°lidos via I/O (entrada/sa√≠da) sendo aplicado por desenvolvedores ou analistas de teste (QA). Testes unit√°rios s√£o m√©todos que verificam o funcionamento de unidades de c√≥digo, vulgo m√©todos, e seus objetos associados. O grande objetivo, por incr√≠vel que pare√ßa, n√£o √© ter uma grande cobertura, e sim resultar em uma arquitetura melhor, menos acoplada, e de melhor manuten√ß√£o. Classes com muitas dep√™ndencias s√£o muito dif√≠ceis de testar. M√©trica utilizada: cobertura de c√≥digo. 

Portanto, s√£o testes que verificam se uma parte espec√≠fica do c√≥digo, costumeiramente a n√≠vel de fun√ß√£o, est√° funcionando corretamente. Em um ambiente orientado a objetos (OOP) √© usualmente a n√≠vel de classes e a m√≠nima unidade de testes inclui construtores e destrutores. 

> üß™ Os testes de unidade verificam unidades, como m√©todos, fun√ß√µes e componentes dentro do software. S√£o os testes mais r√°pidos, baratos de escrever e sua manuten√ß√£o √© simples. Para verificar o <a href="">comportamento</a> dessas pequenas partes isoladas do sistema sem depend√™ncias externas como banco de dados, APIs, arquivos ou rede. Por isso, eles s√£o r√°pidos de executar, baratos de manter e oferecem feedback imediato durante o desenvolvimento. Como testam unidades isoladas, s√£o fundamentais para garantir a estabilidade do c√≥digo √† medida que ele evolui.

Uma **unidade** (unit) √© a menor parte test√°vel de um programa de computador, no programa√ß√£o procedural uma unidade pode ser uma fun√ß√£o individual ou um procedimento do nosso c√≥digo, imagine que toda fun√ß√£o √© uma pequena f√°brica que fabrica alguma coisa que pode sair, sem a necessidade de entrar algo. Idealmente, cada teste de unidade √© independente dos demais, o que possibilita ao programador testar cada m√≥dulo isoladamente.

Rela√ß√£o de conceitos de testes de unidade: 

**I/O Input-Output** (Entrada e Sa√≠da): s√£o todas as entradas e sa√≠das existentes na programa√ß√£o. Portanto, os testes de unidade servem para front-end e back-end. Eles s√£o uma pr√°tica essencial no desenvolvimento de software, pois ajudam a garantir a qualidade do c√≥digo e a facilitar a manuten√ß√£o. Os testes de unidade s√£o realizados em pequenas unidades de c√≥digo, como fun√ß√µes, componentes ou m√≥dulos. Eles s√£o projetados para testar a funcionalidade e a l√≥gica dessas unidades de forma isolada. Isso significa que os testes de unidade n√£o dependem de outros componentes ou m√≥dulos para funcionar.

No **front-end**, os testes de unidade s√£o usados para testar a funcionalidade e a l√≥gica de componentes de interface do usu√°rio, como bot√µes, formul√°rios e listas. Eles tamb√©m s√£o usados para testar a intera√ß√£o entre componentes.

No **back-end**, os testes de unidade s√£o usados para testar a funcionalidade e a l√≥gica de servi√ßos, APIs e outros componentes de back-end. Eles tamb√©m s√£o usados para testar a integra√ß√£o entre componentes de back-end.

Os testes de unidade oferecem uma s√©rie de benef√≠cios, incluindo:

<img src="https://uploads.toptal.io/blog/image/91302/toptal-blog-image-1434578005589-4e6897ec04cc0b3c7075b9b011ee915c.gif" height="377" align="right">

- Aumento da qualidade do c√≥digo: Os testes de unidade ajudam a identificar erros e bugs no c√≥digo antes que eles sejam integrados ao sistema. Isso resulta em um c√≥digo mais confi√°vel e est√°vel.

- Facilidade de manuten√ß√£o: Os testes de unidade facilitam a manuten√ß√£o do c√≥digo, pois permitem verificar se as altera√ß√µes n√£o afetaram o funcionamento de outras partes do c√≥digo.

- Agilidade no desenvolvimento: Os testes de unidade permitem que os desenvolvedores tenham mais confian√ßa ao realizar refatora√ß√µes ou adicionar novos recursos. Isso permite que as equipes desenvolvam de forma mais r√°pida e eficiente.

Portanto, os testes de unidade s√£o uma pr√°tica importante para qualquer desenvolvedor, independentemente da √°rea de atua√ß√£o. 

Sobre os processos de desenvolvimento de software, no terceiro passo no n√≠vel de queda do modelo cascata e no quarto passo do modelo RAPID, entramos na parte de codifica√ß√£o e testes unit√°rios. Ou seja, √© a constru√ß√£o do sistema em si. Ent√£o, s√≥ depois de eu entender todo o problema, s√≥ depois de eu saber das necessidades e se √© poss√≠vel ou vi√°vel para come√ßar a desenvolver. Muitas vezes, para come√ßar a gente se pergunta se √© para pegar logo no processo de codifica√ß√£o, ou seja, a desenvolver logo a aplica√ß√£o o mais r√°pido poss√≠vel. No entanto, percebe-se que o tanto de retrabalho que isso gerava, fazia n√£o valer a pena. E fazia com que estourasse muito o or√ßamento nesse custo. Ent√£o, depois deu definir os requisitos, depois de realizar meus modelos de projetos e provar que aquilo √© vi√°vel, eu ent√£o come√ßo o desenvolvimento do meu software em si.

Ap√≥s o desenvolvimento e junto com o desenvolvimento, entram os testes unit√°rios (unit tests - testes de unidade) que s√£o definidos pelo pr√≥prio desenvolvedor onde eles tendem a testar a menor unidade do sistema. Por exemplo: Se eu estou desenvolvendo um sistema de cadastro de cliente, n√£o importa o tipo do sistema (mercadinho, farm√°cia, padaria, com√©rcio ou de uma grande empresa) e esse desenvolvedor que est√° escrevendo essas linhas de c√≥digo de cadastrar um √∫nico usu√°rio ou funcion√°rio, por exemplo, ele vai desenvolver um caso de teste para que dado uma entrada (input), ele possa receber uma sa√≠da (output) esperada que seria: "usu√°rio cadastrado com sucesso".

Os frameworks de teste de unidade mais populares para **React.js** s√£o:

- <a href="">Jest</a>: O Jest √© um framework de teste de unidade JavaScript criado pelo Facebook. Ele √© r√°pido, f√°cil de usar e oferece uma variedade de recursos, como testes de snapshot, mocking e asser√ß√µes.

- <a href="">Testing Library</a>: A Testing Library √© uma biblioteca de utilit√°rios para testes de componentes React. Ela fornece uma API simples e intuitiva que permite testar componentes sem depender dos detalhes de implementa√ß√£o.

- <a href="">Enzyme</a>: O Enzyme √© uma biblioteca de teste de componentes React que fornece uma API poderosa e flex√≠vel para manipular o DOM e testar eventos.

A escolha do framework de teste de unidade mais adequado depende das necessidades espec√≠ficas do projeto. O Jest √© uma boa op√ß√£o para projetos simples, enquanto frameworks como a Testing Library ou o Enzyme podem ser mais adequados para projetos mais complexos.

Os frameworks de teste de unidade mais populares para **Vue.js** s√£o:

- <a href="">Vue Test Utils</a>: O Vue Test Utils √© um conjunto de utilit√°rios para testes de componentes Vue.js. Ele fornece uma API simples e intuitiva que permite testar componentes sem depender dos detalhes de implementa√ß√£o.

- <a href="">Jest</a>: O Jest √© um framework de teste de unidade JavaScript criado pelo Facebook. Ele tamb√©m pode ser usado para testes de unidade em Vue.js.

- <a href="">Karma</a>: O Karma √© um framework de teste de unidade JavaScript que pode ser usado para executar testes em uma variedade de navegadores. Ele tamb√©m pode ser usado para testes de unidade em Vue.js.

A escolha do framework de teste de unidade mais adequado depende das necessidades espec√≠ficas do projeto. O Vue Test Utils √© uma boa op√ß√£o para projetos simples, enquanto frameworks como o Jest ou o Karma podem ser mais adequados para projetos mais complexos.

O framework Python para web back-end chamado **Django** fornece um framework de teste padr√£o, chamado de **unittest**. Esse framework √© baseado na biblioteca padr√£o unittest do Python e √© adequado para testes unit√°rios e de integra√ß√£o.

Al√©m do unittest, existem outros frameworks de teste de unidade dispon√≠veis para Django. Alguns dos frameworks mais populares incluem:

- <a href="">Pytest</a>: O Pytest √© um framework de teste de unidade completo e flex√≠vel que oferece uma variedade de recursos, como assertion fixtures, parametriza√ß√£o de testes e testes de desempenho.

- <a href="">Mock</a>: O Mock √© um framework de mocking que permite simular o comportamento de objetos externos. Isso pode ser √∫til para testar a funcionalidade de componentes que dependem de outros componentes ou APIs externas.

- <a href="">Selenium</a>: O Selenium √© um framework de automa√ß√£o de testes que permite testar a intera√ß√£o com um navegador web. Isso pode ser √∫til para testar a funcionalidade de componentes de front-end.

A escolha do framework de teste de unidade mais adequado depende das necessidades espec√≠ficas do projeto. O unittest √© uma boa op√ß√£o para projetos simples, enquanto frameworks como Pytest e Mock podem ser mais adequados para projetos mais complexos.

Sobre os conceitos t√©cnicos a respeito de testes de unidades, temos:

<img src="https://github.com/IsaacAlves7/DevSecOps/assets/61624336/f92b16ca-c0a0-40ab-ab33-f8ec9f4cf619" height="77" align="right">

‚úÖ **Testes V√°lidos** (`pass`): S√£o entradas e sa√≠das de dados comuns ao sistema e pertencem ao processo normal. N√£o apresentam tratamento al√©m do normal j√° programado. No caso de retorno dever√° seguir os padr√µes estabelecidos e n√£o permitir retornos fora das regras especificadas. Em testes unit√°rios, estamos nos referindo a casos de teste que exercitam o comportamento correto e esperado da unidade de c√≥digo sob condi√ß√µes normais (v√°lidas), ou seja: Situa√ß√µes em que tudo ocorre como deveria. S√£o aqueles testes que usam entradas v√°lidas e esperadas, esperam resultados corretos, sem exce√ß√µes ou erros. Confirmam que o comportamento da fun√ß√£o est√° conforme o esperado.

Caracter√≠sticas de testes v√°lidos:

| Caracter√≠stica              | Exemplo pr√°tico                                           |
| --------------------------- | --------------------------------------------------------- |
| Entrada no dom√≠nio esperado | CPF v√°lido, n√∫mero positivo, email formatado corretamente |
| Estado inicial v√°lido       | Usu√°rio existente, banco conectado, produto em estoque    |
| Fluxo normal do c√≥digo      | Sem exce√ß√µes, erros, ou retornos inesperados              |
| Resultado esperado          | Retorno certo, estado alterado corretamente               |

Exemplo: Teste manual simples em JavaScript - Aqui, `2` e `3` s√£o valores v√°lidos, e o retorno esperado (`5`) confirma o comportamento correto da fun√ß√£o.

<img src="https://img.shields.io/badge/Jest-1_pass_0_fail-limegreen?style=flat&logo=jest&logoColor=white">

```javascript
function somar(a: number, b: number): number {
  return a + b;
}

test("soma dois n√∫meros positivos", () => {
  expect(somar(2, 3)).toBe(5); // ‚úÖ teste v√°lido
});
```

<img src="https://github.com/IsaacAlves7/DevSecOps/assets/61624336/1e50bc84-048c-40c7-b7b8-98dfdeec38a2" height="77" align="right">

‚ùå **Testes Inv√°lidos** (`fail`): S√£o entradas e sa√≠das de dados n√£o comuns ao sistema. Apresentam tratamento para validar o tipo de dado inv√°lido ou situa√ß√£o. Pode apresentar at√© dois retornos, uma mensagem para um log no sistema e uma mensagem com formata√ß√£o e escrita adequada ao usu√°rio. S√£o t√£o importantes quanto os testes v√°lidos, porque ajudam a garantir que sua fun√ß√£o se defenda bem contra entradas erradas, estados incorretos ou fluxos inesperados. S√£o testes que usam entradas inv√°lidas, incorretas ou fora do esperado; Esperam que o c√≥digo falhe corretamente (com exce√ß√£o, erro, ou retorno de falha); Verificam se o sistema √© robusto contra dados errados ou uso indevido da fun√ß√£o.

Exemplo:

```txt
Dividir (x int,y int)=z int
```

Caso tenhamos `x=1` e `y=0`, `z` ser√° um valor com erro e dever√° retornar uma mensagem ao usu√°rio, avisando que a opera√ß√£o √© inv√°lida. Caso a express√£o seja um dado comum do sistema, a autoriza√ß√£o para tal valida√ß√£o dever√° ser do usu√°rio, pois faz parte do conjunto de regras de neg√≥cio. N√£o existe retorno inv√°lido sem um tratamento. O tratamento gen√©rico ser√° apenas para condi√ß√µes n√£o vis√≠veis na regra e uso do sistema.

<img src="https://github.com/IsaacAlves7/DevSecOps/assets/61624336/c0328294-f3e5-489f-8521-0d634275f7ae" height="77" align="right">

üëÅÔ∏è‚Äçüó®Ô∏è **Dom√≠nio**: No dom√≠nio de testes, usamos testes unit√°rios para validar a funcionalidade de cada componente do nosso dom√≠nio de neg√≥cio, refere-se √† parte do sistema que √© testada para garantir que a l√≥gica de neg√≥cio e a funcionalidade do c√≥digo est√£o corretas, os testes unit√°rios focam em componentes individuais desse dom√≠nio.

> [!Important]
> √â importante ressaltar sobre um termo muito conhecido em ci√™ncia da computa√ß√£o, chamado **dom√≠nio** (domain), cujo a diferen√ßa est√° no n√≠vel de abstra√ß√£o e no foco de cada conceito. A palavra "dom√≠nio" realmente aparece em contextos diferentes e pode causar confus√£o se n√£o for bem delimitada.
>
> No contexto de testes unit√°rios, "dom√≠nio" pode se referir genericamente √† camada de regras de neg√≥cio ou l√≥gica principal da aplica√ß√£o, que √© o alvo ideal desses testes ‚Äî ou seja, testar a l√≥gica do dom√≠nio sem envolver infraestrutura, banco de dados ou interface.
>
> J√° em DDD (Domain-Driven Design), "dom√≠nio" √© o conceito central: √© o conhecimento do neg√≥cio que est√° sendo modelado, e tudo gira em torno disso ‚Äî √© a √°rea de interesse do sistema, como log√≠stica, financeiro, sa√∫de, etc.
>
> No caso de arquiteturas como Clean Architecture ou Ports & Adapters, "dom√≠nio" √© uma camada bem definida e isolada que representa as regras puras do neg√≥cio, ou seja, aquilo que n√£o muda mesmo que a tecnologia mude; √© o n√∫cleo da aplica√ß√£o.
>
> J√° em TDD e BDD, o termo "dom√≠nio" aparece implicitamente quando voc√™ escreve testes voltados para comportamentos do sistema, especialmente no BDD que foca na linguagem ub√≠qua e no comportamento esperado do dom√≠nio de neg√≥cio, enquanto o TDD tende a atuar mais no detalhe t√©cnico e no design emergente.
>
> Por fim, em design de software e design patterns, o "dom√≠nio" pode surgir como contexto onde os padr√µes s√£o aplicados, mas o foco desses conceitos √© mais estrutural e de solu√ß√£o t√©cnica do que modelagem de neg√≥cio em si.
> 
> Ent√£o, "dom√≠nio" em DDD e arquiteturas limpas √© o cora√ß√£o das regras do neg√≥cio, enquanto em testes e padr√µes, √© mais o cen√°rio onde voc√™ aplica as pr√°ticas, muitas vezes sem foco expl√≠cito em representar o neg√≥cio como um modelo coeso.

Voc√™ pode dizer: 

> "Nos nossos testes de unidade, verificamos se os m√©todos da entidade `Pedido` calculam corretamente o total do pedido."

Focado na verifica√ß√£o da funcionalidade de unidades isoladas de c√≥digo (geralmente m√©todos ou fun√ß√µes), tem como objetivo garantir que cada parte do software funcione conforme esperado de maneira isolada. O contexto aqui √© mais t√©cnico e voltado para a qualidade do c√≥digo e a preven√ß√£o de regress√µes.

Pode ser um campo, uma assinatura, um I/O, ou qualquer tipo de local que receba valores externos ao sistema. Todo dom√≠nio deve realizar consist√™ncias de dados v√°lidos e inv√°lidos. Um dom√≠nio s√≥ permite dados com a formata√ß√£o igual ao que ser√° armazenado.

Ex.: Campo DDD dever√° permitir n√∫meros de at√© quatro casas n√£o negativas ou a base de dados deve impedir a entrada de valores inv√°lidos. Receber e guardar o mesmo tipo de dado, o tamanho do campo que recebe os dados deve ser menor ou igual ao campo que ir√° armazenar os dados (em raros casos os campos de armazenamento s√£o menores que os de exibi√ß√£o).

Em suma, dom√≠nio √© o tipo de valor v√°lido para cada campo. Como exemplo podemos citar: 

```txt
Campo nome: Dominio = tipo: string; tamanho:50
```

Ao aplicarmos o particionamento por equival√™ncia e a an√°lise por valor limite, poderemos criar as seguintes classes de testes.

Particionamento por Equival√™ncia: campo nome:

- valor em branco (BLANK); Cen√°rio Negativo
- `valor > 50`; Cen√°rio Negativo
- qualquer valor de `1` a `50`; Cen√°rio Positivo

An√°lise por Valor Limite:

```txt
campo nome: valor em branco; valores 49,50,51; 
```

Usamos um valor exatamente inferior e exatamente posterior ao valor do campo, devido ao fato dos erros aparecerem nas fronteiras da aplica√ß√£o.

O dom√≠nio de testes unit√°rios, o dom√≠nio de DDD (Domain-Driven Design) e o dom√≠nio de microsservi√ßos podem estar inter-relacionados, mas n√£o s√£o exatamente o mesmo dom√≠nio. Embora o dom√≠nio de testes unit√°rios, o dom√≠nio de DDD e o dom√≠nio de microsservi√ßos n√£o sejam exatamente o mesmo, eles est√£o inter-relacionados e podem se complementar. Testes unit√°rios verificam a funcionalidade do c√≥digo, DDD foca na modelagem do dom√≠nio de neg√≥cios, e microsservi√ßos organizam a aplica√ß√£o em componentes pequenos e independentes. Quando usados juntos, esses conceitos podem ajudar a criar sistemas robustos, bem projetados e testados. Voc√™ pode ter uma comunica√ß√£o mais assertiva com o seu time falando da maneira proposta acima que eles ir√£o entender de qual tipo de dom√≠nio se trata.

Quando voc√™ combina esses tr√™s conceitos, voc√™ pode comunicar algo como: 

> "No nosso sistema, utilizamos uma abordagem de Domain-Driven Design (DDD) para modelar nosso dom√≠nio de neg√≥cio. Cada parte do dom√≠nio de neg√≥cio √© implementada como um microsservi√ßo independente, permitindo escalabilidade e independ√™ncia de desenvolvimento. Al√©m disso, garantimos a qualidade e a corre√ß√£o da l√≥gica de neg√≥cio com testes unit√°rios abrangentes, que validam cada componente do nosso dom√≠nio de neg√≥cio."

Agora, imagine que voc√™ precisa validar o funcionamento de sua aplica√ß√£o em um determinado cen√°rio, mas este cen√°rio s√≥ funciona se integrado com uma aplica√ß√£o de terceiros espec√≠fica, a qual voc√™ n√£o tem total acesso.

O fato de voc√™ n√£o ter acesso traz um dilema: ou voc√™ ignora a integra√ß√£o e roda o teste, inviabilizando a obten√ß√£o de resultados assertivos, ou n√£o testa de modo algum.

Nenhuma das op√ß√µes √© realmente a escolha ideal, mesmo se voc√™ encarar aquele ditado ‚Äúfeito √© melhor que perfeito‚Äù. Afinal, √© muito t√™nue a linha entre n√£o trazer os resultados corretos e n√£o testar.

O ideal seria existir algo que possibilitasse que os testes trouxessem os melhores resultados, mesmo sem acesso √† tecnologia necess√°ria. A boa not√≠cia √© que existe! Estamos falando dos _test doubles_.

<img src="https://github.com/IsaacAlves7/DevSecOps/assets/61624336/3963eb3d-ea61-4557-92cb-2f097cfed79a" height="77" align="right">

Os **Test doubles** s√£o objetos usados em testes de software para substituir componentes reais que um sistema ou m√≥dulo depende, permitindo que os testes sejam mais control√°veis, isolados, r√°pidos e confi√°veis. O nome ‚Äúdouble‚Äù vem da ideia de um ‚Äúdubl√™‚Äù no cinema: algu√©m que substitui o ator em cenas arriscadas. No c√≥digo, os test doubles substituem partes reais (como um banco de dados, uma API externa ou at√© um servi√ßo interno) que voc√™ n√£o quer ou n√£o pode usar diretamente durante o teste. Termo gen√©rico para qualquer substitui√ß√£o de objeto de produ√ß√£o em testes.

De acordo com Martin Fowler, test doubles √© um conceito usado quando, para viabilizar a realiza√ß√£o de testes, algum objeto em produ√ß√£o precisa ser substitu√≠do por outro.

Quando falamos em Test Doubles, estamos nos referindo a objetos ‚Äúsubstitutos‚Äù que criamos para simular comportamentos em testes, especialmente quando n√£o queremos ou n√£o podemos usar a implementa√ß√£o real de uma depend√™ncia. O nome vem de uma analogia com o ‚Äústunt double‚Äù do cinema, o dubl√™ que substitui o ator em cenas perigosas. Em testes de software, um test double substitui um componente real para que possamos isolar o c√≥digo que queremos validar. Fazendo um paralelo simplista, eles s√£o como dubl√™s de atores em um filme: substituem aplica√ß√µes reais durante a realiza√ß√£o de um teste por simular sua apar√™ncia e comportamento. Isso traz menos complexidade ao teste, al√©m de permitir verificar uma parte de um sistema sem ficar preso em todas as suas outras por√ß√µes.

<img height="277" align="right" src="https://github.com/user-attachments/assets/22e14580-ed05-4d76-a49f-04f073454f55" />

Em resumo, as duplicatas de teste (test doubles) s√£o usadas para criar testes r√°pidos, independentes, determin√≠sticos e confi√°veis. Eles representam componentes reais, semelhante √† forma como os dubl√™s s√£o usados nos filmes.

Talvez voc√™ n√£o esteja familiarizado com o termo test double. √â que, √†s vezes, eles s√£o generalizados pela palavra mock, ou ent√£o pela express√£o ‚Äúmockar‚Äù . O fato √© que mock √© apenas um dos exemplos de test doubles dentro de uma fam√≠lia muito maior. Al√©m dos mocks, existem, por exemplo, os fakes, os stubs, os dummies‚Ä¶ Abaixo, explico alguns deles.

Eles s√£o fundamentais para testes automatizados, principalmente testes unit√°rios, e ajudam a focar apenas na l√≥gica que voc√™ est√° testando, sem interfer√™ncia de outras partes do sistema. 

<a href="https://pt.slideshare.net/slideshow/sc-mad-tdd-workshop-test-doubles-36543998/36543998"><img src="https://github.com/user-attachments/assets/633f5cc2-e3ff-46ea-a801-44b80ddca48e" height="277" align="right"></a>

Os tipos mais comuns de Test Doubles s√£o geralmente organizados em cinco categorias cl√°ssicas:

- `Dummy`: Passado mas nunca usado; listas de par√¢metros de preenchimentos
- `Fake`: tem uma implementa√ß√£o funcional, mas n√£o √© adequado para produ√ß√£o
- `Stub`: Fornece respostas prontas para chamadas feitas durante o teste
- `Spy`: Um esbo√ßo que registra informa√ß√µes sobre como foi chamado
- `Mock`: Pr√©-programado com expectativas, formando uma especifica√ß√£o das chamadas esperadas

O primeiro √© o **Dummy**, que √© o mais simples: s√£o objetos criados apenas para preencher par√¢metros ou satisfazer assinaturas de m√©todos, mas que nunca s√£o realmente usados. Eles existem para evitar nulls ou falhas de compila√ß√£o, mas n√£o participam da l√≥gica do teste.

Os dummies s√£o dados que substituem dados reais, mas que n√£o chegam a ser realmente utilizados no teste. S√£o normalmente usados para satisfazer determinados par√¢metros.

Como uso de dummies √© poss√≠vel diminuir a complexidade durante a escrita de um teste, ignorando o que n√£o √© relevante no cen√°rio e focando no que realmente importa.

<img height="277" align="right" alt="fake" src="https://github.com/user-attachments/assets/f81524ad-936f-4b9e-9822-05c32d02489c" />

Os **fakes** s√£o test doubles que t√™m implementa√ß√µes reais diferentes √†quelas que existem em produ√ß√£o. √© uma implementa√ß√£o funcional simplificada de um componente real. Ele realmente executa algo, mas de maneira controlada e menos complexa.

Um exemplo cl√°ssico √© um banco de dados em mem√≥ria usado nos testes em vez de um banco de produ√ß√£o, ou um servidor HTTP falso que responde rapidamente sem precisar de rede. 

Os fakes aceleram os testes e evitam depend√™ncias externas pesadas. Podemos consider√°-los como um ‚Äúatalho‚Äù, algo implementado para deixar a execu√ß√£o do teste mais din√¢mica frente ao que √© colocado no ar de fato.

Basicamente, n√£o h√° l√≥gica em um fake ‚Äî ele retorna um valor determinado por quem o implementa e, justamente por isso, n√£o √© um elemento adequado para ir √† produ√ß√£o. Contudo, ele elimina a necessidade de implementar uma funcionalidade real, o que seria bem mais complexo.

<img height="277" align="right" src="https://github.com/user-attachments/assets/4f994eed-d9b0-44fd-8272-3d54b28a4e27" />

O **Stub** √© um objeto que fornece respostas pr√©-determinadas para chamadas feitas durante o teste. Ele n√£o tem l√≥gica real, apenas retorna o que foi configurado. Os stubs s√£o muito √∫teis quando voc√™ quer garantir que o teste receba certos dados sem depender de sistemas externos, como simular uma API retornando um JSON fixo.

S√£o similares aos fakes e aos spies, mas, ao contr√°rio destes, ele consegue alterar seu comportamento com base na maneira como ele foi chamado no teste.

O stub tamb√©m √© uma forma de teste duplo usado para fornecer uma resposta controlada das depend√™ncias de um componente. Esse tipo de teste duplo pode ser usado para fornecer uma resposta controlada sem fazer nenhuma l√≥gica real. Os stubs geralmente n√£o d√£o nenhuma resposta fora do que est√° programado no teste. Isso permite que mais de um cen√°rio para uma √∫nica depend√™ncia seja representado no teste.

Qual √© a diferen√ßa entre Mock e Stub? A julgar pela defini√ß√£o de mock e stub, parece que mock e stub s√£o a mesma coisa. Isso ocorre porque uma simula√ß√£o pode ser considerada uma extens√£o de um esbo√ßo. Um stub √© apenas uma implementa√ß√£o simples usada para fornecer uma resposta controlada. Enquanto isso, a simula√ß√£o n√£o funciona apenas como um stub, mas tamb√©m verifica o comportamento de um componente e sua intera√ß√£o com o objeto que a simula√ß√£o cria.

<img src="https://github.com/user-attachments/assets/4024470e-6396-4b5b-849c-ec7a86e2bc54" height="277" align="right">

Os **mocks** tem expectativas sobre o jeito que deve ser chamado e, caso ele n√£o seja chamado da forma correta, o teste deve falhar. Eles s√£o usados para testar intera√ß√µes entre m√©todos e s√£o √∫teis onde n√£o h√° como verificar algumas mudan√ßas de estado ou retornos do m√©todo testado diretamente.

**Mocking** (Mockado) √© uma t√©cnica usada em testes de software para simular o comportamento de depend√™ncias externas, como servi√ßos, bancos de dados, ou APIs, dentro de uma unidade de c√≥digo que voc√™ est√° testando. Ao inv√©s de usar as implementa√ß√µes reais dessas depend√™ncias, voc√™ cria "mocks" (objetos falsos) que imitam o comportamento esperado, permitindo testar o c√≥digo de forma isolada. O principal benef√≠cio do mocking √© garantir que o teste foque apenas no comportamento da unidade de c√≥digo em quest√£o, sem se preocupar com o comportamento ou estado das depend√™ncias externas.

Exemplo: Se voc√™ estiver testando um servi√ßo que depende de um reposit√≥rio de dados, voc√™ pode usar um mock para simular as respostas do reposit√≥rio, em vez de acessar o banco de dados real.

Mocking e testes unit√°rios s√£o diferentes, mas se complementam para testar unidades isoladas do c√≥digo. Os testes unit√°rios tem o objetivo de testar uma unidade de c√≥digo (como uma fun√ß√£o ou m√©todo) de forma independente, garantindo que ela funcione corretamente em diferentes cen√°rios. Em um teste unit√°rio, voc√™ se preocupa apenas com o comportamento interno dessa unidade. 

J√° o mocking √© uma t√©cnica usada nos testes unit√°rios para simular (mockar) depend√™ncias externas da unidade que est√° sendo testada. Isso permite que voc√™ foque exclusivamente na l√≥gica interna da unidade, sem se preocupar com o comportamento ou estado de servi√ßos, bancos de dados ou APIs reais. Em resumo, os mocks ajudam a garantir que os testes unit√°rios sejam realmente isolados e focados na unidade de c√≥digo que est√° sendo testada, sem interfer√™ncias externas.

<img src="https://github.com/user-attachments/assets/0f2ecf0d-35de-4fe4-a7b7-24530745efd0" height="277" align="right">

Por fim, existe o **Spy**, que √© uma esp√©cie de h√≠brido. Ele √© um objeto real, mas que tem a capacidade de registrar as chamadas que recebeu, permitindo inspecionar posteriormente como foi utilizado. Diferente do mock, o spy n√£o necessariamente substitui a l√≥gica real; ele executa de verdade, mas deixa rastros que podem ser verificados.

Um spy age como um espi√£o sob a implementa√ß√£o real e, como o mock, consegue verificar as intera√ß√µes entre os m√©todos.

A diferen√ßa para o mock √© que o spy chama a implementa√ß√£o real para todos os m√©todos da interface mockada, a n√£o ser que para algum m√©todo este seja configurado para retornar algo espec√≠fico diferente da implementa√ß√£o real.

Existem boas pr√°ticas bem consolidadas no uso de *test doubles*, e as imagens refletem parte disso. A primeira mostra uma distin√ß√£o cl√°ssica: **mocks (e spies)** s√£o usados mais em **commands** (a√ß√µes que mudam estado), enquanto **stubs (stubs, dummies, fakes)** s√£o usados em **queries** (consultas que retornam dados). Essa pr√°tica vem da ideia de **Command Query Separation (CQS)**, que sugere que comandos devem ter efeitos colaterais e n√£o retornar valores, enquanto queries retornam valores mas n√£o mudam estado. Se voc√™ usa stubs para queries, voc√™ s√≥ garante dados de entrada controlados; j√° mocks para comandos te permitem verificar se uma a√ß√£o realmente ocorreu.

Na segunda imagem, vemos os test doubles categorizados em um ‚Äúuniverso‚Äù com sobreposi√ß√µes. A ideia √© refor√ßar que **Dummy, Stub, Fake, Spy e Mock** s√£o varia√ß√µes de substitutos que usamos em testes, mas cada um tem um prop√≥sito espec√≠fico. A boa pr√°tica aqui √© **usar o double mais simples poss√≠vel que resolva o problema do teste**. Por exemplo, se voc√™ s√≥ precisa preencher um par√¢metro, use um dummy. Se precisa de dados controlados, use um stub. Se quer uma implementa√ß√£o leve mas funcional (como um banco em mem√≥ria), use um fake. Se precisa verificar chamadas, use um mock. Se precisa capturar intera√ß√µes sem substituir toda a l√≥gica, use um spy. O erro comum √© usar mocks para tudo, gerando testes fr√°geis, acoplados demais ao c√≥digo interno.

Outra boa pr√°tica √© manter os doubles **pr√≥ximos do contexto do teste** e n√£o generaliz√°-los cedo demais. Doubles gen√©ricos compartilhados entre muitos testes podem virar fonte de inconsist√™ncia ou dificultar a leitura. Em TDD, por exemplo, √© comum criar o double dentro do pr√≥prio teste e s√≥ refatorar para reaproveitar se realmente houver repeti√ß√£o.

Tamb√©m √© importante lembrar que test doubles s√£o **ferramentas para testes de unidade**, onde o isolamento √© crucial. Em testes de integra√ß√£o ou end-to-end, eles devem ser usados com cautela, pois nesses n√≠veis o objetivo √© justamente validar a intera√ß√£o real entre componentes. Usar doubles nesses contextos pode dar uma falsa sensa√ß√£o de seguran√ßa, porque o c√≥digo passa no teste, mas falha no ambiente real.

Por fim, existe uma m√°xima importante: **‚Äúdon‚Äôt mock what you don‚Äôt own‚Äù** ‚Äî ou seja, evite criar mocks para depend√™ncias externas de terceiros, como APIs de bibliotecas que voc√™ n√£o controla. Isso acopla seus testes a detalhes que podem mudar fora do seu controle. Em vez disso, prefira abstrair essas depend√™ncias atr√°s de interfaces pr√≥prias e mockar essas interfaces. Isso deixa seus testes mais est√°veis e mant√©m o acoplamento sob seu dom√≠nio.

Ou seja, as boas pr√°ticas s√£o: usar mocks para comandos e stubs para queries, escolher o double mais simples poss√≠vel para o cen√°rio, n√£o abusar de mocks em todos os lugares, restringir o uso a testes de unidade, e nunca mockar diretamente depend√™ncias externas que voc√™ n√£o controla.

## [QA] Integration Testing
<img src="https://img.shields.io/badge/Jest-fail-%23C21325?style=flat&logo=jest&logoColor=white"> <img src="https://img.shields.io/badge/Cypress-passing-gray?style=flat&logo=Cypress&logoColor=white"> <img src="https://img.shields.io/badge/Mock-passing-chocolate?style=flat&logo=Mock&logoColor=white"> <img src="https://img.shields.io/badge/Go-passing-00ADD8?style=flat&logo=Go&logoColor=white"> <img src="https://img.shields.io/badge/PHPUnit-8.2-777BB4?style=flat&logo=PHP&logoColor=white"> <img src="https://img.shields.io/badge/-Pytest-blue?style=badge&logo=Pytest&logoColor=white"> <img src="https://img.shields.io/badge/JUnit5-passing-25A162?style=flat&logo=JUnit5&logoColor=white"> <img src="https://img.shields.io/badge/xUnit.net-8_pass_0_fail-512BD4?style=flat&logo=DotNet&logoColor=white"> ![xUnit.net](https://img.shields.io/badge/-Moq-512BD4?style=badge&logo=.NET&logoColor=white)

<a href="https://martinfowler.com/bliki/IntegrationTest.html"><img src="https://em-content.zobj.net/source/microsoft-teams/400/woman-and-man-holding-hands_1f46b.png" align="right" height="77"></a>

Os **testes de integra√ß√£o** (integration testing) s√£o de um n√≠vel mais alto, e testam a rela√ß√£o de elementos, como por exemplo um banco de dados e o software. A realiza√ß√£o destes testes √© mais lenta, afinal possuem um outro grau de complexidade. √â um teste em grupos que valida a integra√ß√£o de um sistema com outros sistemas ou banco de dados, √© feito pelo desenvolvedor para validar se existe falha de dados entre integra√ß√µes nos sistemas e se est√° com o comportamento correto.

S√£o testes que verificam se _m√≥dulos_ diferentes do sistema funcionam corretamente juntos, por exemplo: back-end + banco de dados, API + autentica√ß√£o, ou microsservi√ßos se comunicando via fila ou HTTP.

No contexto de testes de integra√ß√£o, **m√≥dulos** s√£o partes distintas de um sistema que t√™m responsabilidade pr√≥pria (ex: autentica√ß√£o, pagamentos, cadastro), podem ou n√£o ser executadas separadamente e precisam se comunicar entre si para o sistema funcionar corretamente. M√≥dulo, em testes de integra√ß√£o, se refere a qualquer parte aut√¥noma do sistema (seja uma classe, servi√ßo, camada ou microservi√ßo) que precisa se comunicar com outras partes para o sistema funcionar. Testes de integra√ß√£o s√£o o que garantem que essas partes realmente funcionam bem juntas, usando dados reais, banco de dados, APIs, filas, etc. Os testes de integra√ß√£o avaliam se a comunica√ß√£o entre esses m√≥dulos est√° funcionando como esperado.

Portanto, testes de integra√ß√£o s√£o uma fase do processo de teste de software em que m√≥dulos ou componentes s√£o combinados e testados em grupo. Ela sucede o teste de unidade, em que os m√≥dulos s√£o testados individualmente, e antecede o teste de sistema, em que o sistema completo √© testado num ambiente que simula o ambiente de produ√ß√£o. Os testes de integra√ß√£o t√™m como objetivo verificar a funcionalidade e a comunica√ß√£o entre m√≥dulos. Eles s√£o projetados para identificar erros de integra√ß√£o, que s√£o erros que ocorrem quando dois ou mais m√≥dulos s√£o combinados.

Exemplo em um sistema web: Suponha que voc√™ tenha um sistema de e-commerce com:

- `M√≥dulo A`: Autentica√ß√£o

- `M√≥dulo B`: Cat√°logo de produtos

- `M√≥dulo C`: Carrinho de compras

- `M√≥dulo D`: Pagamento

No teste de integra√ß√£o, voc√™ testaria coisas como:

- ‚úÖ Se um usu√°rio autenticado consegue adicionar produtos ao carrinho (A + C).

- ‚úÖ Se o sistema s√≥ libera o pagamento se os produtos forem v√°lidos (B + D).

- ‚úÖ Se o pedido final √© registrado no banco com todas as depend√™ncias funcionando (A + B + C + D).

Dependendo do contexto, m√≥dulo pode significar:

| Contexto               | O que √© o "m√≥dulo"?                                           | Exemplo pr√°tico                                           |
| ---------------------- | ------------------------------------------------------------- | --------------------------------------------------------- |
| Back-end (monolito)    | Um **componente separado** (servi√ßo, classe, camada)          | M√≥dulo de usu√°rios vs m√≥dulo de produtos                  |
| Microservi√ßos          | Um **servi√ßo inteiro** com banco pr√≥prio e API                | Servi√ßo de checkout vs servi√ßo de cat√°logo                |
| Front-end modularizado | Um conjunto de **fun√ß√µes ou hooks reutiliz√°veis**             | M√≥dulo de autentica√ß√£o + m√≥dulo de requisi√ß√µes            |
| Arquitetura em camadas | Uma **camada** da aplica√ß√£o (Controller, Service, Repository) | Controller depende do Repository funcionando corretamente |

Ent√£o, nos testes de integra√ß√£o, o objetivo √©:

- Testar a colabora√ß√£o entre m√≥dulos reais, sem mocks.
- Verificar se integra√ß√µes entre m√≥dulos distintos (por c√≥digo, HTTP, fila, banco) est√£o funcionando.
- Detectar problemas de acoplamento, depend√™ncia ou contrato entre partes do sistema.

Se voc√™ quer conhecer todas as principais ferramentas e frameworks de testes de integra√ß√£o, aqui vai um apanhado completo, organizado e atualizado, abrangendo m√∫ltiplas linguagens e stacks modernas ‚Äî incluindo ferramentas de prop√≥sito geral, espec√≠ficas para APIs, banco de dados, E2E (fim a fim), e ambientes complexos como microservi√ßos.

<img src="https://github.com/IsaacAlves7/DevSecOps/assets/61624336/fc63a3ad-8a9f-4841-bc0c-9855af158009" align="right" height="277">

**JavaScript / TypeScript**:

- **Jest** embora seja popular para testes de unidade, tamb√©m permite testes de integra√ß√£o. Suporte a mocking, spies, e `supertest` para testes de API.

- **Supertest** testa endpoints HTTP diretamente em apps Node.js/Express/Koa. Muito usado com Jest ou Mocha.

- **Mocha + Chai** flex√≠vel e modular. Excelente para testes de integra√ß√£o com `chai-http` e `supertest`.

- **Playwright / Puppeteer** usados para testes de integra√ß√£o **em aplica√ß√µes web** (navegador). Permitem verificar o fluxo do usu√°rio entre frontend e backend.

- **Vitest** suporte moderno e r√°pido a testes de integra√ß√£o com foco em performance. Alternativa moderna ao Jest com suporte a ES Modules.

Deno com `deno test` embutido no runtime. Suporte nativo a testes de integra√ß√£o (com `fetch`, banco, etc.). Test libraries auxiliares: `assert` (de `std`) e n√£o precisa de Supertest: pode usar `fetch` diretamente no servidor rodando em teste.

**Python**:

- **Pytest** um dos frameworks mais completos. Com plugins como `pytest-django`, `pytest-flask`, `pytest-asyncio`, cobre testes de integra√ß√£o completos.

- **Requests / HTTPX** combinados com `pytest`, s√£o √≥timos para testar APIs REST ou FastAPI/Flask/Django.

- **Behave / Lettuce** estilo BDD com testes de integra√ß√£o escritos em Gherkin.

**Java / Kotlin**:

- **JUnit (5+)** com Spring Boot Test: realiza testes de integra√ß√£o com o contexto da aplica√ß√£o.

- **Testcontainers** executa servi√ßos reais (como PostgreSQL, Kafka, Redis) em containers Docker nos testes.

- **RestAssured** framework fluente para testar endpoints REST em Java.

**Go**:

- **testing + httptest** padr√£o da linguagem. Cria servidores HTTP fake para testar integra√ß√£o de APIs.

- **GoConvey** framework para escrever testes BDD e de integra√ß√£o.

- **Testcontainers-Go** integra servi√ßos externos com Docker no teste (como bancos, filas, etc).

**Rust**:

- `#[tokio::test]`, `reqwest`, `warp::test` ferramentas nativas para rodar testes async com HTTP, banco etc.

- **Testcontainers-rs** similar ao de outras linguagens: banco de dados real em Docker.

**PHP**:

- **PHPUnit** com Laravel ou Symfony, permite testes de integra√ß√£o completos com banco de dados e API.

- **Codeception** espec√≠fico para testes de integra√ß√£o e E2E. Robusto e com suporte a m√∫ltiplos m√≥dulos (HTTP, DB, etc).

**Ruby**:

- **RSpec + Capybara** usado em Rails para testes de integra√ß√£o web.

- **Minitest** leve e nativo do Ruby. Com suporte a integra√ß√£o com bancos e HTTP.

Ferramentas gen√©ricas de integra√ß√£o / multi-linguagem:

- **Postman + Newman** ideal para testar APIs REST/GraphQL com fluxo, autentica√ß√£o, tokens, etc.

- **Insomnia Tests** alternativa ao Postman com foco em GraphQL e REST.

- üß™ **Cypress** (E2E com integra√ß√£o real) testa interface, mas tamb√©m valida backend real.

- üê≥ **Testcontainers** (multi-language: Java, Node, Go, Rust, .NET, etc) executa servi√ßos reais (Redis, MySQL, RabbitMQ) em Docker, durante os testes.

- **WireMock / MockServer**: Simulam servi√ßos externos para testar integra√ß√£o sem depend√™ncias reais.

- **Docker Compose** (para orquestrar m√∫ltiplos servi√ßos nos testes), muito usado para testes de integra√ß√£o entre microsservi√ßos.

Em casos especiais, testes com fila e mensageria (Kafka, RabbitMQ):

* `Testcontainers` (com RabbitMQ/Kafka)
* `docker-compose` para subir o ambiente
* Bibliotecas nativas da linguagem para consumir/produzir

Para testes de integra√ß√£o, voc√™ pode optar por:

| Categoria | Ferramentas-chave                              |
| --------- | ---------------------------------------------- |
| Node.js   | Jest + Supertest, Mocha, Vitest                |
| Deno      | `deno test` + `fetch/assert`                   |
| Python    | Pytest + HTTPX + Testcontainers                |
| Java      | JUnit + SpringBootTest + Testcontainers        |
| Multi     | Postman/Newman, Testcontainers, Docker Compose |
| E2E web   | Playwright, Cypress, Puppeteer                 |
| APIs      | RestAssured, Insomnia, HTTPX, Supertest        |

## [QA] Functional Testing
<img src="https://www.zucisystems.com/wp-content/uploads/2020/06/3-Types-of-Functional-Testing.png" height="177" align="right">

Testes de um n√≠vel ainda maior, s√£o os **functional tests**, que testam o sistema completo e garante a corre√ß√£o de funcionalidades no ponto de vista do cliente.

O que √© importante pensarmos √© no tempo de execu√ß√£o de testes que teremos. Os testes de unidade existem desde o in√≠cio do projeto, qualquer commit deveria ser acompanhada por um teste.

√â comum que o desenvolvedor que queria concluir um projeto rapidamente deixe de fazer testes para otimizar o tempo. Como resolver esse impasse? Antes do commit, devemos executar todos os testes, embora saibamos que isso √© em um plano ideal, e muitas vezes desnecess√°rio dependendo da modifica√ß√£o que foi realizada. At√© mesmo executar todos os testes unit√°rios pode ser complicado.

Uma t√©cnica comum √© executar o que chamamos de **smoke tests**. Na pr√°tica, trata-se de **uma sele√ß√£o de testes que garantem que as funcionalidades mais importantes do sistema estejam operando corretamente**. Esses testes avaliam um conjunto menor de elementos, por isso s√£o mais r√°pidos, e dessa maneira teremos a garantia de que o software est√° operante em sua estrutura b√°sica. Depois disso, podemos aplicar todos os testes e garantir uma varredura maior de erros.

Em resumo, devemos observar a categoria de cada teste; em ambientes diferentes fazer escolhas de desempenho e que melhor atendam nossa demanda; aplicar boas pr√°ticas de testes ( testes isolados, leg√≠veis, expressivos); realizar testes na parte de build e adquirir feedbacks o mais r√°pido o poss√≠vel.

## [QA] Regression testing
<img src="https://github.com/IsaacAlves7/DevSecOps/assets/61624336/8d0cb7bf-a902-4268-8633-73d0e06a2adc" align="right" height="77">

O **teste de regress√£o** √© uma t√©cnica do teste de software que consiste na aplica√ß√£o de vers√µes mais recentes do software, para garantir que n√£o surgiram novos defeitos em componentes j√° analisados. Regression testing, ou teste de regress√£o, √© um tipo de teste de software realizado para garantir que mudan√ßas recentes no c√≥digo, como corre√ß√µes de bugs, novas funcionalidades ou outras modifica√ß√µes, n√£o introduzam novos defeitos ou causem falhas em partes j√° existentes do software. Este processo √© essencial para manter a integridade do software ap√≥s qualquer tipo de altera√ß√£o. 

Em resumo, regression testing √© uma pr√°tica crucial no desenvolvimento de software que visa assegurar que novas mudan√ßas n√£o comprometam funcionalidades existentes, contribuindo para a estabilidade e qualidade cont√≠nua do sistema.

Objetivos do Regression Testing:

1. **Verificar Estabilidade**: Assegurar que as novas mudan√ßas n√£o impactaram negativamente o comportamento existente do software.

2. **Identificar Regress√µes**: Detectar rapidamente qualquer falha que possa ter sido introduzida devido a mudan√ßas recentes.

3. **Manter Qualidade**: Garantir que o software continua funcionando conforme esperado, mantendo a qualidade e a confiabilidade.

Quando Realizar Regression Testing:

- **Ap√≥s Corre√ß√µes de Bugs**: Sempre que um bug √© corrigido, √© importante garantir que a corre√ß√£o n√£o tenha introduzido novos problemas.

- **Ap√≥s Adi√ß√£o de Novas Funcionalidades**: Novas funcionalidades podem afetar o funcionamento existente, por isso testes de regress√£o s√£o necess√°rios.

- **Durante Refatora√ß√£o de C√≥digo**: A refatora√ß√£o melhora o design interno do c√≥digo, mas pode inadvertidamente introduzir erros.

- **Em Atualiza√ß√µes de Depend√™ncias**: Mudan√ßas em bibliotecas ou frameworks subjacentes podem afetar o comportamento do software.

M√©todos de Regression Testing:

1. **Reexecu√ß√£o Completa**: Executar todos os testes existentes para garantir que o software inteiro funcione corretamente. Isso √© muitas vezes impratic√°vel para grandes sistemas devido ao tempo e recursos necess√°rios.

2. **Sele√ß√£o de Casos de Teste**: Escolher um subconjunto de testes que s√£o mais relevantes para as √°reas do c√≥digo que foram alteradas.

3. **Teste de Prioridade**: Focar nos testes mais cr√≠ticos e mais propensos a serem afetados pelas mudan√ßas.

4. **Automa√ß√£o de Testes**: Usar ferramentas de automa√ß√£o para executar testes de regress√£o de forma eficiente e repet√≠vel.

Ferramentas Comuns para Regression Testing:

- **Selenium**: Para automa√ß√£o de testes de interface de usu√°rio em aplica√ß√µes web.

- **JUnit/NUnit/PyTest**: Para testes unit√°rios automatizados.

- **Jenkins/GitLab CI**: Para integra√ß√£o cont√≠nua e execu√ß√£o automatizada de testes.

- **Robot Framework**: Para testes automatizados em diversos contextos.

- **TestNG**: Para organiza√ß√£o e execu√ß√£o de testes em Java.

Benef√≠cios do Regression Testing:

- **Detec√ß√£o Precoce de Defeitos**: Permite a identifica√ß√£o e corre√ß√£o r√°pida de novos problemas.

- **Redu√ß√£o de Riscos**: Minimiza o risco de introdu√ß√£o de erros ao modificar o software.

- **Qualidade Cont√≠nua**: Mant√©m a qualidade do software ao longo de todo o ciclo de desenvolvimento.

Desafios do Regression Testing:

- **Manuten√ß√£o de Testes**: Manter um conjunto de testes atualizado pode ser desafiador √† medida que o software evolui.

- **Tempo e Recursos**: A execu√ß√£o de um grande conjunto de testes pode ser demorada e consumir muitos recursos.

- **Falsos Positivos/Negativos**: Pode haver casos onde testes falham ou passam erroneamente, exigindo investiga√ß√£o adicional.

## [QA] E2E - End-to-end
<img src="https://img.shields.io/badge/Cypress-E2E-gray?style=badge&logo=Cypress&logoColor=white"> <img src="https://img.shields.io/badge/Playwright-E2E-red?style=badge&logo=Playwright&logoColor=white"> <img src="https://img.shields.io/badge/Zod-E2E-blue?style=badge&logo=Zod&logoColor=white"> <img src="https://img.shields.io/badge/Selenium-E2E-lime?style=badge&logo=Selenium&logoColor=white"> <img src="https://img.shields.io/badge/Appium-E2E-silver?style=badge&logo=Appium&logoColor=white"> <img src="https://img.shields.io/badge/Moqups-E2E-blue?style=badge&logo=Moqups&logoColor=white"> <img src="https://img.shields.io/badge/Mural-E2E-tomato?style=badge&logo=Mural&logoColor=white">

<img src="https://github.com/IsaacAlves7/DevSecOps/assets/61624336/5c4e2a17-1197-42fb-b43a-d32d15bf5be5" align="right" height="77">

O **E2E - End-to-end** refere-se a um tipo de teste ou processo que envolve a verifica√ß√£o de um sistema ou fluxo de trabalho em sua totalidade, desde o in√≠cio at√© o fim, simulando as condi√ß√µes reais de uso pelo usu√°rio final. Em resumo, "end-to-end" se refere √† abordagem de teste que abrange todo o sistema ou processo, do in√≠cio ao fim, para garantir seu funcionamento correto e eficaz.

O E2E verifica se todos os componentes de um sistema (front-end, back-end, bancos de dados, APIs externas, etc.) funcionam juntos conforme esperado, do in√≠cio ao fim. Em um contexto de desenvolvimento de software, os testes end-to-end s√£o realizados para garantir que todas as partes do sistema estejam funcionando corretamente juntas, desde a interface do usu√°rio at√© o backend, incluindo integra√ß√µes com outros sistemas, se aplic√°vel. Isso √© feito para garantir que o sistema esteja se comportando conforme o esperado e atendendo aos requisitos do usu√°rio final.

Os testes end-to-end s√£o frequentemente usados para validar fluxos de trabalho completos em um aplicativo ou site, simulando a intera√ß√£o do usu√°rio final com o sistema. Eles podem envolver a automa√ß√£o de cliques de mouse, preenchimento de formul√°rios, navega√ß√£o entre p√°ginas e verifica√ß√£o de resultados. No entanto, a valida√ß√£o √© um conceito que se aplica a m√∫ltiplos n√≠veis de teste, incluindo o E2E, mas n√£o √© exclusiva dele. 

As principais ferramentas para testes *E2E (End-to-End)* e solu√ß√µes complementares (como Zod) para valida√ß√£o de dados, organizadas por contexto de uso:

Ferramentas Especializadas em E2E:

1. **Para Aplica√ß√µes Web**  
   - **Cypress**: Framework completo para testes E2E em navegadores, com suporte a simula√ß√£o de intera√ß√µes (cliques, formul√°rios) e debug em tempo real. Inclui **Cypress Testing Library** para boas pr√°ticas de sele√ß√£o de elementos.  

   - **Playwright**: Suporta m√∫ltiplos navegadores (Chromium, Firefox, WebKit) e linguagens (JS/TS, Python, .NET). Recursos como auto-wait, grava√ß√£o de testes e testes em paralelo. O Playwright √© uma biblioteca de automa√ß√£o de c√≥digo aberto para testes de navegador e web scraping desenvolvida pela Microsoft e lan√ßada em 31 de janeiro de 2020, que desde ent√£o se tornou popular entre programadores e desenvolvedores web.

    - **Selenium**: Mais antigo, mas ainda usado em projetos legados. Requer mais configura√ß√£o (WebDriver).  

3. **Para APIs**  
   - **Supertest** (Node.js): Biblioteca para testar APIs HTTP integrada ao Jest/Mocha. Valida status codes, responses e headers.  
   - **Postman/Newman**: Cole√ß√µes de requisi√ß√µes podem ser automatizadas como testes E2E (com scripts em JavaScript).  

4. **Para Mobile**  
   - **Appium**: Framework open-source para testes E2E em aplicativos Android/iOS.  
   - **Detox**: Focado em React Native e aplica√ß√µes nativas, com suporte a sincroniza√ß√£o autom√°tica.  

5. **Para Desktop**  
   - **Spectron** (para Electron): Integra Selenium com o Electron para testar aplica√ß√µes desktop.  

Ferramentas Complementares (como Zod):

1. **Valida√ß√£o de Dados em Testes E2E**  
   - **Zod**: Valida esquemas de respostas de API ou estados da UI durante testes. Exemplo:  
       ```typescript  
       const LoginResponseSchema = z.object({ token: z.string() });  
       const data = LoginResponseSchema.parse(await response.json());  
       ```  
   - **Joi**: Similar ao Zod, mas mais usado em back-end (Node.js) para validar objetos.  

2. **Mock de Dados/APIs**  
   - **MSW (Mock Service Worker)**: Intercepta requisi√ß√µes HTTP em testes E2E para simular APIs sem depender do back-end real.  

   - **JSON Server**: Cria uma API fake baseada em um arquivo JSON para testes iniciais.  

4. **Asser√ß√µes Avan√ßadas**  
   - **Jest/Vitest**: Oferecem matchers (como `.toMatchObject()`) para validar estruturas de dados em testes.  

   - **Chai**: Biblioteca de asser√ß√µes para Mocha, com sintaxe leg√≠vel (ex.: `expect(user).to.have.property('name')`).  

6. **Monitoramento e Relat√≥rios**  
   - **Allure Report**: Gera relat√≥rios visuais detalhados de testes E2E.  

   - **Sentry**: Captura erros em tempo real durante testes (√∫til para debug em CI/CD).  

Exemplo de Fluxo com Ferramentas Combinadas

1. **Playwright** simula um usu√°rio fazendo login.  
2. **MSW** mocka a API de login (opcional).  
3. **Zod** valida se a resposta da API cont√©m `{ token: string }`.  
4. **Allure Report** gera um dashboard com os resultados.  

Quando Usar Cada Uma?

- **Testes de UI Completa**: Cypress/Playwright.  
- **APIs**: Supertest + Zod/Joi.  
- **Mobile**: Appium/Detox.  
- **Valida√ß√£o de Dados**: Zod (TypeScript) ou Joi (JavaScript).  
- **Mock**: MSW ou JSON Server.  

Essas ferramentas podem ser combinadas para cobrir todos os aspectos de testes E2E, desde a intera√ß√£o do usu√°rio at√© a integridade dos dados.

## [QA] TDD - Test-Driven Development 
![Jest](https://img.shields.io/badge/-Jest-EF2D5E?style=badge&logo=jest&logoColor=white)
![Mocha](https://img.shields.io/badge/-Mocha-EF2D5E?style=badge&logo=mocha&logoColor=white)
![JUnit5](https://img.shields.io/badge/-JUnit5-EF2D5E?style=badge&logo=JUnit5&logoColor=white) 
![xUnit](https://img.shields.io/badge/-xUnit-EF2D5E?style=badge&logo=.NET&logoColor=white) 
![Jest](https://img.shields.io/badge/-Jest-00D564?style=badge&logo=jest&logoColor=white)
![Mocha](https://img.shields.io/badge/-Mocha-00D564?style=badge&logo=mocha&logoColor=white)
![JUnit5](https://img.shields.io/badge/-JUnit5-00D564?style=badge&logo=JUnit5&logoColor=white) 
![Jest](https://img.shields.io/badge/-Jest-FFDF6F?style=badge&logo=jest&logoColor=black)
![Mocha](https://img.shields.io/badge/-Mocha-FFDF6F?style=badge&logo=mocha&logoColor=black)
![JUnit5](https://img.shields.io/badge/-JUnit5-FFDF6F?style=badge&logo=JUnit5&logoColor=black) 
![JUnit5](https://img.shields.io/badge/-xUnit-FFDF6F?style=badge&logo=.NET&logoColor=black) 

<img src="https://github.com/IsaacAlves7/DevSecOps/assets/61624336/555d9d87-5698-46e3-b39f-713da277205e" align="right" height="77">

O **TDD - Test-Driven Development**, ou em portugu√™s "Desenvolvimento guiado por testes" ou Desenvolvimento Orientado a testes ou Desenvolvimento digirido por testes, √© uma t√©cnica de desenvolvimento de software que se relaciona com o conceito de verifica√ß√£o e valida√ß√£o e se baseia em um ciclo curto de repeti√ß√µes: Primeiramente o desenvolvedor escreve um caso de teste automatizado que define uma melhoria desejada ou uma nova funcionalidade. Logo, √© produzido c√≥digo que possa ser validado pelo teste para posteriormente o c√≥digo ser refatorado para um c√≥digo sob padr√µes aceit√°veis. 

Basicamente, ela ajuda a aumentar a produtividade a partir de testes j√° consolidados. O TDD (Test-Driven Development) foca em um tipo espec√≠fico de teste chamado <a href="">teste de unidade</a>. No entanto, ele pode influenciar outros tipos de testes durante o ciclo de desenvolvimento.

Kent Beck, considerado o criador ou o 'descobridor' da t√©cnica, declarou em 2003 que TDD encoraja designs de c√≥digo simples e inspira confian√ßa. Desenvolvimento dirigido por testes √© relacionado a conceitos de programa√ß√£o de <a href="">XP - Extreme Programming</a>, iniciado em 1999, mas recentemente tem-se criado maior interesse pela mesma em fun√ß√£o de seus pr√≥prios ideais. Atrav√©s de TDD, programadores podem aplicar o conceito de melhorar e depurar c√≥digo legado desenvolvido a partir de t√©cnicas antigas.

> O TDD √© considerado uma t√©cnica ou metodologia, muito adotada nos times de desenvolvimento. Isso porque ele √© direcionado ao desenvolvimento de softwares. Contudo, pelo fato de inverter a ordem dos trabalhos ‚Äì do teste para o c√≥digo ‚Äì √© um pouco impopular entre os Devs. No entanto, ap√≥s pegar o jeito, o desenvolvimento ganha um up, e a t√©cnica traz muitos resultados positivos ao projeto.

<img src="https://github.com/user-attachments/assets/08e14244-2f2f-42eb-8e9f-049efca12ce5" align="right" height="177">

> [!Important]
> O livro **Test-Driven Development: By Example** do Kent Beck, √© considerado a obra fundamental sobre TDD (Test-Driven Development). Ele √© importante por alguns motivos hist√≥ricos e pr√°ticos. Primeiro, porque o Kent Beck foi um dos criadores originais do TDD como pr√°tica estruturada dentro do movimento Extreme Programming (XP) e um dos autores do Manifesto √Ågil. Ou seja, ele n√£o s√≥ ajudou a popularizar o conceito, como tamb√©m foi quem deu a forma mais clara e pr√°tica para sua aplica√ß√£o. Segundo, porque esse livro √© did√°tico e pr√°tico: Beck explica a ideia de TDD usando exemplos pequenos, progressivos e reais. Ele mostra o famoso ciclo do TDD ‚Äî Red, Green, Refactor ‚Äî de maneira muito detalhada, quase como se estivesse pair programming com o leitor. Ele come√ßa com problemas bem simples, como implementar uma calculadora de dinheiro com opera√ß√µes b√°sicas, e vai aumentando a complexidade, at√© chegar em casos mais sofisticados.

O TDD segue a l√≥gica do ciclo: Red, Green e Refactor. Este ciclo √© uma abordagem estruturada para escrever e melhorar c√≥digo de software de maneira incremental, garantindo que ele seja test√°vel, funcional e de alta qualidade. Aqui est√° uma explica√ß√£o detalhada de cada fase do ciclo:

<img src="https://github.com/IsaacAlves7/DevSecOps/assets/61624336/63318aff-ad59-4c3e-b858-172ec4154f85" align="right" height="277">

üî¥ **Red**: Escreva um teste que apresenta erros, que falhe. A√ß√£o: voc√™ come√ßa escrevendo um teste automatizado para a funcionalidade que deseja implementar. Este teste √© baseado nos requisitos e especifica√ß√µes do que o c√≥digo deve fazer. Resultado: O teste falha, pois a funcionalidade ainda n√£o foi implementada. A falha confirma que o teste √© v√°lido e que a funcionalidade n√£o existe no momento.

üü¢ **Green**: Logo ap√≥s, escreva um c√≥digo que passe no teste, que funcione e fa√ßa o teste passar. A√ß√£o: Escrever a quantidade m√≠nima de c√≥digo necess√°rio para fazer o teste passar. Nesta fase, o foco est√° em implementar a funcionalidade de maneira r√°pida e simples, sem se preocupar muito com a qualidade ou eleg√¢ncia do c√≥digo. Resultado: O teste passa, indicando que a funcionalidade b√°sica foi implementada corretamente.

üü° **Refactor**: Depois disso, "refatorar" o que foi feito, ou seja, eliminar a redund√¢ncia e melhorar a qualidade do c√≥digo, ou seja, melhorar e otimizar o c√≥digo sem alterar sua funcionalidade, mantendo todos os testes passando. A√ß√£o: Refatorar o c√≥digo escrito na fase anterior para torn√°-lo mais limpo com princ√≠pios de <a href="">C√≥digo Limpo (Clean Code)</a>, eficiente e f√°cil de manter. Isso pode incluir a remo√ß√£o de duplica√ß√µes, melhoria da legibilidade, e conformidade com padr√µes de design. Resultado: O c√≥digo √© melhorado sem alterar seu comportamento externo. Os testes (novos e antigos) continuam passando, garantindo que a funcionalidade permanece correta ap√≥s as melhorias. 

A **Refatora√ß√£o** √© o processo de reestruturar o c√≥digo de um software para melhorar sua qualidade interna, sem alterar seu comportamento externo. A principal finalidade da refatora√ß√£o √© tornar o c√≥digo mais limpo, leg√≠vel, e f√°cil de manter, otimizando aspectos como desempenho, organiza√ß√£o e modularidade. 

Ela costuma envolver a remo√ß√£o de duplica√ß√£o de c√≥digo, simplifica√ß√£o de estruturas complexas, e melhoria na nomenclatura de vari√°veis, classes e fun√ß√µes, al√©m de aplicar padr√µes de design e princ√≠pios como o <a href="">SOLID</a>. 

Refatorar tamb√©m ajuda a prevenir a "d√≠vida t√©cnica", que ocorre quando decis√µes de design ou implementa√ß√£o apressadas criam problemas futuros. Em metodologias √°geis, a refatora√ß√£o √© geralmente integrada ao processo de desenvolvimento cont√≠nuo, sendo realizada entre ciclos de implementa√ß√£o de novas funcionalidades. Portanto, a refatora√ß√£o se encaixa como uma pr√°tica regular dentro da fase de desenvolvimento, especificamente na etapa de Integra√ß√£o Cont√≠nua (CI), que foca na qualidade do c√≥digo e na automa√ß√£o de testes.

<img src="https://github.com/user-attachments/assets/620b69eb-5d3b-4339-ad75-7d4dc78839d1" align="right" height="177">

> [!Important]
> Por mais de vinte anos, programadores experientes no mundo inteiro contaram com o livro **Refatora√ß√£o: Aperfei√ßoando o Design de C√≥digos Existentes** de Martin Fowler para aperfei√ßoar o design de c√≥digos existentes e melhorar a manutenibilidade do software, assim como para deixar o c√≥digo existente mais f√°cil de entender. Essa nova edi√ß√£o ansiosamente esperada foi atualizada por completo para refletir mudan√ßas vitais no dom√≠nio da programa√ß√£o. Refatora√ß√£o 2¬™ edi√ß√£o cont√©m um cat√°logo atualizado das refatora√ß√µes e inclui exemplos de c√≥digo JavaScript bem como novos exemplos funcionais que demonstram a refatora√ß√£o sem classes. Assim como na edi√ß√£o original, este livro explica o que √© refatora√ß√£o, por que voc√™ deve refatorar, como reorganizar um c√≥digo que precise de refatora√ß√£o e como fazer isso de forma bem-sucedida, independentemente da linguagem usada. Para aperfei√ßoar o design de c√≥digos existentes e melhorar a manutenibilidade de software, assim como para deixar o c√≥digo existente mais f√°cil de entender.

Ap√≥s ler este livro, voc√™ ser√° capaz de:

<img src="https://github.com/user-attachments/assets/77f87103-de9e-49e9-85d2-b29a8ed47608" align="right" height="277">

- Entenda o processo e os princ√≠pios b√°sicos da refatora√ß√£o;
- Aplique rapidamente refatora√ß√µes convenientes para deixar um programa mais f√°cil de entender e de alterar;
- Reconhe√ßa ‚Äúmaus cheiros‚Äù no c√≥digo que sinalizam oportunidades para refatorar;
- Explore as refatora√ß√µes, cada uma com suas explica√ß√µes, a motiva√ß√£o, o mecanismo e exemplos simples;
- Escreva testes robustos para suas refatora√ß√µes;
- Reconhe√ßa as contrapartidas e os obst√°culos para a refatora√ß√£o.

O Desenvolvimento dirigido por testes requer dos desenvolvedores criar testes automatizados que definam requisitos em c√≥digo antes de escrever o c√≥digo da aplica√ß√£o. Os testes cont√©m asser√ß√µes que podem ser verdadeiras ou falsas. Ap√≥s as mesmas serem consideradas verdadeiras ap√≥s sua execu√ß√£o, os testes confirmam o comportamento correto, permitindo os desenvolvedores evoluir e refatorar o c√≥digo. Normalmente todos os testes s√£o efetuados de forma continua de acordo com o desenvolvimento cada funcionalidade criada deve ser acompanhada de um teste bem descrito e projetado, ent√£o deve-se escolher a √°rea do projeto ou requisitos da tarefa para melhor orientar o desenvolvimento destes testes.

Desenvolvedores normalmente usam frameworks de testes, como **xUnit**, para criar e executar automaticamente uma s√©rie de casos de teste.

> As empresas esperam que seus colaboradores sejam realmente muito bons em testes unit√°rios e a melhor forma de garantir isso √© pedindo TDD. Muitas pessoas aprendem testes de forma muito superficial, mas um profissional que j√° praticou TDD em alguma codebase real tem uma vantagem sobre os outros, pois j√° enfrentou diversos problemas e sabe como contorn√°-los.

<img src="https://caelum-online-public.s3.amazonaws.com/1629+-+integracao_continua/03/3_1_1_design.png" height="177" align="right">

Os testes em integra√ß√£o cont√≠nua s√£o sobre **feedback do software**, como a maioria dos m√©todos √°geis. Feedback √© o ponto chave para um desenvolvimento com qualidade, seja ele a n√≠vel t√©cnico, de gest√£o ou pessoal. O Feedback √© o ponto chave para um desenvolvimento com qualidade, seja ele a n√≠vel t√©cnico, de gest√£o ou pessoal.

Bom, muito provavelmente n√£o fui eu quem inventou o nome Ciclo de Feedback para desenvolvimento de Software mas estou adicionando o guiado a Testes. Legal mas o que isso quer dizer? Quer dizer que, quando trabalhando no desenvolvimento de uma tarefa qualquer, que seja guiada a testes, n√≥s temos que trabalhar em cima do feedback que os testes nos trazem e n√£o com o pensamento de que temos apenas que codar a `feature` e adicionar testes para garanti-las. Realizar uma tarefa guiada a testes com esse pensamento √© disperdi√ßar boa parte do potencial da abordagem do TDD.

![tdd,bdd,ddd](https://github.com/user-attachments/assets/999df44a-f250-4287-b80c-e7725401d917)

Ent√£o, o TDD, BDD e DDD s√£o tr√™s abordagens diferentes que se complementam no desenvolvimento de software. O **TDD (Test-Driven Development)** √© uma pr√°tica focada no ciclo de escrita de testes antes da implementa√ß√£o do c√≥digo. A ideia central √© escrever primeiro um teste que falha porque a funcionalidade ainda n√£o existe, depois escrever o c√≥digo m√≠nimo necess√°rio para faz√™-lo passar e, em seguida, refatorar para manter a qualidade. Esse ciclo de ‚Äúred, green, refactor‚Äù garante que o sistema nas√ßa j√° com testes cobrindo a funcionalidade, evita sobrecarga de bugs e mant√©m o design do c√≥digo limpo e orientado ao que realmente precisa ser implementado. Com o tempo, voc√™ ganha confian√ßa para refatorar e evoluir a aplica√ß√£o porque sabe que os testes automatizados garantem que nada quebrou.

J√° o **BDD (Behavior-Driven Development)** nasceu como uma evolu√ß√£o do TDD, com foco maior na comunica√ß√£o entre time de neg√≥cios e desenvolvimento. A ideia √© descrever o comportamento esperado do sistema em linguagem natural, geralmente em formato de cen√°rios (‚ÄúDado que‚Äù, ‚ÄúQuando‚Äù, ‚ÄúEnt√£o‚Äù), o que torna os testes leg√≠veis at√© para quem n√£o programa. Isso aproxima desenvolvedores, QA, product owners e at√© clientes, porque todos falam a mesma l√≠ngua sobre o que o software deve fazer. Enquanto o TDD guia o c√≥digo a partir de testes t√©cnicos, o BDD guia o c√≥digo a partir do comportamento esperado do usu√°rio ou do neg√≥cio, trazendo clareza e diminuindo ambiguidades nos requisitos.

O **DDD (Domain-Driven Design)**, por sua vez, √© mais abrangente, √© uma forma de estruturar todo o sistema a partir do dom√≠nio de neg√≥cio. O ponto central √© que o design da aplica√ß√£o deve emergir do entendimento profundo do problema que se quer resolver, criando um modelo de dom√≠nio claro, organizado e rico, que reflete a realidade do neg√≥cio. DDD traz conceitos como entidades, agregados, value objects, bounded contexts e ubiquitous language, para garantir que o c√≥digo represente fielmente as regras do dom√≠nio e que diferentes partes do sistema conversem de forma coerente. Ele n√£o √© uma t√©cnica de testes como TDD ou BDD, mas sim uma filosofia arquitetural que ajuda a manter a complexidade sob controle e tornar o software mais alinhado √†s necessidades reais do neg√≥cio. Por isso, o DDD √© amplamente adotado em Code Reviews.

Quando voc√™ junta as tr√™s abordagens, tem um fluxo bastante poderoso: o DDD te ajuda a entender e modelar corretamente o dom√≠nio; o BDD garante que os comportamentos mais importantes estejam claros e validados com o neg√≥cio; e o TDD d√° a base t√©cnica para implementar cada parte com qualidade e seguran√ßa. Assim, voc√™ cobre desde a concep√ß√£o do sistema at√© a implementa√ß√£o e os testes, reduzindo riscos, aumentando a clareza e facilitando a manuten√ß√£o e evolu√ß√£o ao longo do tempo.

Esse diagrama mostra o **ciclo do TDD** expandido para al√©m do ‚Äúred-green-refactor‚Äù cl√°ssico, conectando os diferentes n√≠veis de testes (caixa preta, cinza e branca) dentro do ciclo de desenvolvimento. Destrinchando o que ele est√° representando:

<img width="1200" height="635" alt="Test-driven-development-cycle-Cybus-Nordic-APIs" src="https://github.com/user-attachments/assets/c1a8a96e-1c48-4152-95e3-003afbdcd210" />

√Ä esquerda, temos a **Black Box**, que √© onde entram os **testes de aceita√ß√£o**. Eles validam se o sistema, como um todo, faz o que o usu√°rio ou o neg√≥cio espera. √â aqui que entra aquele ‚ÄúDado‚ÄìQuando‚ÄìEnt√£o‚Äù do BDD, por exemplo. 

1. Esse √© o primeiro passo (1): escrever o teste de aceita√ß√£o que vai falhar porque o sistema ainda n√£o implementa a funcionalidade.

2. Na sequ√™ncia (2), entra a parte de **testes funcionais**, ainda numa vis√£o de alto n√≠vel. Eles descrevem como cada funcionalidade deve se comportar dentro do sistema. √â a ponte entre aceita√ß√£o e c√≥digo.

3.4 Indo para a direita, temos a **White Box**, com **testes unit√°rios**. Esse √© o n√∫cleo do TDD cl√°ssico: para cada pequena parte do c√≥digo (fun√ß√£o, m√©todo, classe), voc√™ escreve um teste que falha (3), implementa o c√≥digo m√≠nimo para passar (4) e depois refatora (ciclo interno de unidade).

5. Depois de escrever e passar os testes unit√°rios, voc√™ volta para os **testes funcionais** (5), garantindo que aquela unidade est√° contribuindo corretamente para o comportamento esperado.

6. Daqui em diante, surgem os **testes de integra√ß√£o** (6), que validam se as diferentes partes do sistema trabalham bem juntas (por exemplo, se um servi√ßo conversa com outro via API, se a camada de aplica√ß√£o integra corretamente com o banco).

6.7 Os testes funcionais e de integra√ß√£o se retroalimentam (6 e 7), porque quando voc√™ conecta m√≥dulos, √© comum ajustar tanto o comportamento funcional quanto a integra√ß√£o.

8. Por fim, quando tudo isso passa, voc√™ retorna para os **testes de aceita√ß√£o** (8). Se eles agora passam, significa que o sistema como um todo est√° atendendo ao que foi pedido. Se ainda falham, o ciclo recome√ßa at√© que os crit√©rios de aceita√ß√£o estejam cumpridos.

Resumindo: o ciclo mostra que o TDD n√£o vive s√≥ no n√≠vel unit√°rio (teste‚Äìc√≥digo‚Äìrefatora), mas pode ser entendido como um **encadeamento de ciclos em diferentes camadas**: come√ßa com aceita√ß√£o (vis√£o do usu√°rio), vai para funcional (vis√£o do sistema), integra√ß√µes (m√≥dulos se falando) e finalmente unidades (blocos de c√≥digo). √â um processo iterativo que desce do mais abstrato at√© o mais concreto e depois sobe de volta, validando em todos os n√≠veis.

## [QA] BDD - Behavior-Driven Development
![Cucumber](https://img.shields.io/badge/-Cucumber-23D96C?style=badge&logo=cucumber&logoColor=white) ![Behave](https://img.shields.io/badge/-Behave-00D564?style=Behave&logo=Python&logoColor=white) ![Specflow](https://img.shields.io/badge/-Specflow-00D564?style=badge&logo=.NET&logoColor=white) ![Speculate](https://img.shields.io/badge/-Speculate-00D564?style=badge&logo=Rust&logoColor=white) ![Mocha](https://img.shields.io/badge/-Mocha-00D564?style=badge&logo=Mocha&logoColor=white) ![Chai](https://img.shields.io/badge/-Chai-00D564?style=badge&logo=Chai&logoColor=white) ![Jest](https://img.shields.io/badge/-Jest-00D564?style=badge&logo=Jest&logoColor=white) ![Sinon](https://img.shields.io/badge/-Sinon-00D564?style=badge&logo=Node.js&logoColor=white) ![Gherkin](https://img.shields.io/badge/-Gherkin-00D564?style=badge&logo=Gherkin&logoColor=white) ![Gherkin](https://img.shields.io/badge/-Gherkin-00D564?style=badge&logo=Gherkin&logoColor=white) ![Gherkin](https://img.shields.io/badge/-Gherkin-00D564?style=badge&logo=Gherkin&logoColor=white) 

<img src="https://github.com/user-attachments/assets/51f4d9a0-47ce-49a9-baeb-f8b9d4c15b3e" align="right" height="77">

O **BDD - Behavior-Driven Development** (Desenvolvimento Orientado a Comportamento), √© uma metodologia de desenvolvimento √°gil que tem como foco a colabora√ß√£o entre desenvolvedores, QA (Quality Assurance) e partes interessadas n√£o t√©cnicas para criar uma compreens√£o compartilhada do comportamento desejado de um software. O BDD √© uma evolu√ß√£o do TDD (Test-Driven Development) e adiciona uma √™nfase maior na comunica√ß√£o e na clareza dos requisitos.

Em resumo, o BDD promove uma abordagem colaborativa para o desenvolvimento de software, focando em comportamentos e resultados esperados do sistema, o que ajuda a garantir que o software entregue atenda √†s necessidades reais dos usu√°rios e stakeholders.

Aqui est√£o os componentes chave do BDD:

<img height="177" align="right" src="https://github.com/user-attachments/assets/1886b145-5f12-4bc5-b096-fe3d0849e991" />

1. **Foco no Comportamento**: Em vez de se concentrar apenas na implementa√ß√£o t√©cnica e nos testes de unidade, o BDD foca em como o software deve se comportar sob v√°rias condi√ß√µes, incluindo o comportamento do usu√°rio final.

2. **Linguagem Ub√≠qua (Ubiquitous Language)**: Utiliza uma linguagem comum (frequentemente baseada em linguagens naturais como o ingl√™s) que pode ser compreendida por todos os membros da equipe, incluindo desenvolvedores, QA, e stakeholders n√£o t√©cnicos. Isso ajuda a reduzir ambiguidades e garantir que todos tenham a mesma compreens√£o dos requisitos. A Linguagem Ub√≠qua (Ubiquitous Language) √© um conceito central no <a href="">Design Orientado a Dom√≠nio (DDD)</a> que visa criar uma linguagem comum entre todos os envolvidos em um projeto, seja para os especialistas no dom√≠nio, desenvolvedores, ou mesmo os usu√°rios finais. Essa linguagem comum facilita a comunica√ß√£o e colabora√ß√£o, reduzindo a possibilidade de mal-entendidos e melhorando a qualidade do desenvolvimento. 

3. **Especifica√ß√µes Execut√°veis**: No BDD, os requisitos s√£o escritos em forma de especifica√ß√µes que podem ser executadas como testes. Essas especifica√ß√µes geralmente seguem um formato estruturado, como <a href="">Gherkin</a> que √© uma linguagem de dom√≠nio espec√≠fico usada para descrever comportamentos esperados de um sistema de forma clara e compreens√≠vel por todos os envolvidos no desenvolvimento de software, incluindo pessoas n√£o t√©cnicas, que usa palavras-chave como "`Given`" (Dado), "`When`" (Quando), e "`Then`" (Ent√£o) para descrever cen√°rios de teste:

   - `Given` (Dado): Descreve o contexto inicial ou o estado do sistema antes de uma a√ß√£o espec√≠fica.

   - `When` (Quando): Descreve a a√ß√£o ou evento que ocorre.

   - `Then` (Ent√£o): Descreve o resultado esperado ou o comportamento do sistema ap√≥s a a√ß√£o.

Exemplo: Login no Sistema

[![Login.feature](https://img.shields.io/badge/-Login.feature-pink?style=social&logo=googledocs&logoColor=purple)](#)

```gherkin
Feature: Login no Sistema

Scenario: Login com credenciais v√°lidas
  Given: o usu√°rio est√° na p√°gina de login
  When: o usu√°rio insere suas credenciais v√°lidas
  Then: o usu√°rio √© redirecionado para a p√°gina inicial
```

Exemplo 2: Pesquisar produto

[![Pesquisar.feature](https://img.shields.io/badge/-Pesquisar.feature-pink?style=social&logo=googledocs&logoColor=purple)](#)

```gherkin
Funcionalidade: Pesquisar produto
  Eu como cliente
  Quero fazer pesquisas no site da OLX
  Para buscar por produtos

Cen√°rio: Buscar produto com sucesso
  Dado que estou no site da OLX como um comprador de SP
  Quando eu fizer uma busca por um produto
  Ent√£o ser√£o exibidos os resultados de busca para o produto em SP
```

5. **Ferramentas de BDD**: Existem v√°rias ferramentas que suportam BDD, ajudando a automatizar as especifica√ß√µes execut√°veis. Algumas das ferramentas populares incluem <a href="">Cucumber</a> (para v√°rias linguagens como Java, Ruby), <a href="">SpecFlow</a> (para .NET), <a href="">Behave</a> (para Python), entre outras.

<img src="https://github.com/IsaacAlves7/DevSecOps/assets/61624336/93228869-20dc-414f-b89e-4ae549ac96b4" align="right" height="277">

5. **Benef√≠cios do BDD**: Uma das maiores virtudes do BDD - Behavior-Driven Development √© unir os dois mundos TDD e DDD, de fato √© representar uma interse√ß√£o entre TDD (Test-Driven Development) e DDD (Domain-Driven Design), pois ele nasce da necessidade de alinhar o desenvolvimento t√©cnico com o entendimento do neg√≥cio, garantindo que o software reflita o comportamento esperado do sistema a partir da perspectiva do usu√°rio ou dom√≠nio. BDD pode ser visto como a interse√ß√£o onde a clareza de inten√ß√£o do dom√≠nio (trazida pelo DDD) se encontra com a pr√°tica de testar antes de desenvolver (como prop√µe o TDD).

   - **Melhor Comunica√ß√£o**: Facilita a comunica√ß√£o entre todos os membros da equipe, garantindo que todos entendam os requisitos de maneira clara e compartilhada.

   - **Desenvolvimento Orientado a Valor**: Foca no que realmente importa para os usu√°rios finais e stakeholders, ajudando a priorizar o desenvolvimento de funcionalidades de maior valor.

   - **Menos Retrabalho**: Reduz ambiguidades nos requisitos, diminuindo o risco de desenvolvimento de funcionalidades incorretas ou desnecess√°rias.

   - **Documenta√ß√£o Viva**: As especifica√ß√µes atuam como uma documenta√ß√£o viva que est√° sempre em sincronia com o comportamento atual do sistema.

## [QA] ATDD - Acceptance Test-Driven Development
<img src="https://github.com/user-attachments/assets/dcf5ece6-9b99-4a82-aca2-4af7351d944a" align="right" height="277">

O **ATDD - Acceptance Test-Driven Development** √© uma pr√°tica e uma varia√ß√£o do desenvolvimento orientado a testes (TDD) que coloca o **teste de aceita√ß√£o** como ponto central do ciclo. Enquanto no TDD tradicional o desenvolvedor escreve primeiro testes unit√°rios para depois implementar o c√≥digo que os satisfaz, no ATTD o processo come√ßa com a defini√ß√£o dos testes de aceita√ß√£o, geralmente descritos em linguagem mais pr√≥xima do neg√≥cio, representando os crit√©rios que o sistema precisa cumprir para ser aceito pelo cliente ou pelo usu√°rio final.

A ideia √© alinhar desde o in√≠cio o que ser√° constru√≠do com o que realmente tem valor para o neg√≥cio. Os testes de aceita√ß√£o funcionam como especifica√ß√µes execut√°veis: descrevem cen√°rios, entradas, sa√≠das e comportamentos esperados do sistema em termos que os stakeholders entendem. Depois disso, os desenvolvedores implementam o c√≥digo necess√°rio para fazer esses testes passarem. Em muitos casos, ferramentas como Cucumber, SpecFlow ou Behave s√£o usadas para escrever cen√°rios em Gherkin (‚ÄúGiven, When, Then‚Äù), permitindo que as pr√≥prias partes interessadas consigam validar e at√© revisar os testes.

Na pr√°tica, o ATTD acaba funcionando como uma ponte entre BDD e TDD. Ele compartilha com o BDD a preocupa√ß√£o de usar exemplos de neg√≥cio como base para o desenvolvimento, mas mant√©m a disciplina do TDD de usar testes automatizados como motor do ciclo. Isso ajuda a garantir que o software entregue n√£o s√≥ funcione tecnicamente, mas tamb√©m atenda ao valor esperado pelos usu√°rios, reduzindo retrabalho e mal-entendidos.

## [QA] SDD - Specification-Driven Development
<img height="277" align="right" src="https://github.com/user-attachments/assets/f1d7c1dc-adde-4604-b310-f8dd82f287f6" />

O **SDD - Specification-Driven Development** √© uma abordagem de desenvolvimento de software em que o ponto de partida e o guia principal de todo o ciclo de cria√ß√£o √© a especifica√ß√£o formal e clara do sistema a ser constru√≠do. 

Em vez de come√ßar direto pela implementa√ß√£o de c√≥digo ou at√© mesmo pelos testes, a ideia central do SDD √© produzir especifica√ß√µes bem definidas que podem ser documentos estruturados, contratos formais, modelos de comportamento ou at√© DSLs (linguagens espec√≠ficas de dom√≠nio) e a partir delas orientar o design, os testes e a implementa√ß√£o. 

No desenvolvimento tradicional, o c√≥digo vem primeiro, seguido pela documenta√ß√£o, testes e explica√ß√£o.

Mas no desenvolvimento orientado a especifica√ß√µes, invertemos o roteiro. A especifica√ß√£o se torna a fonte da verdade e o c√≥digo flui a partir dela. Com a IA no circuito, esse fluxo de trabalho se torna ainda mais poderoso. Gera especifica√ß√µes a partir da inten√ß√£o do usu√°rio. Deriva c√≥digo a partir de especifica√ß√µes e valida a l√≥gica com linguagem natural.

Neste t√≥pico, voc√™ aprender√° como fluxos de trabalho com tecnologia de IA permitem sistemas mais r√°pidos, seguros e modulares, especialmente para aplica√ß√µes embarcadas e distribu√≠das na borda. O desenvolvimento orientado a especifica√ß√µes come√ßa definindo o que o sistema deve fazer.

Antes de tocar no c√≥digo, as especifica√ß√µes podem delinear o comportamento funcional, relacionamentos de entrada/sa√≠da, casos extremos (edge cases), failure cases, Temporal logic e.g. do x, y, and z.

O prop√≥sito √© reduzir ambiguidades que frequentemente aparecem em m√©todos tradicionais, onde requisitos em linguagem natural muitas vezes d√£o margem a interpreta√ß√µes diferentes por desenvolvedores, testadores e stakeholders. No SDD, a especifica√ß√£o n√£o √© apenas um requisito no papel, mas sim um artefato execut√°vel ou valid√°vel, que pode ser usado para gerar c√≥digo, validar regras de neg√≥cio automaticamente ou servir de refer√™ncia inequ√≠voca para testes.

Dessa forma, o SDD busca criar um fluxo em que a especifica√ß√£o √© a fonte da verdade. Em muitas implementa√ß√µes dessa pr√°tica, as especifica√ß√µes podem ser escritas em formatos que permitam serem executadas ou verificadas, como contratos formais, modelos l√≥gicos ou at√© arquivos que depois geram c√≥digo de suporte, documenta√ß√£o ou casos de teste. Isso cria uma forte liga√ß√£o entre o que o cliente espera, o que o time desenvolve e o que √© testado. Diferente do TDD (Test-Driven Development), que coloca os testes como guia para a implementa√ß√£o, ou do BDD (Behavior-Driven Development), que enfatiza a escrita de cen√°rios de comportamento em linguagem quase natural, o SDD √© mais r√≠gido e sistem√°tico, focando na **especifica√ß√£o t√©cnica ou formal** como ponto de converg√™ncia, de forma que a implementa√ß√£o n√£o seja ‚Äúinterpretada‚Äù pelos desenvolvedores, mas derivada da especifica√ß√£o.

Essa abordagem √© especialmente √∫til em dom√≠nios onde erros de interpreta√ß√£o podem ser cr√≠ticos, como sistemas financeiros, governamentais, industriais e m√©dicos, porque minimiza a dist√¢ncia entre o que foi pedido e o que √© entregue. Al√©m disso, o SDD facilita auditorias, compliance e rastreabilidade, j√° que a especifica√ß√£o pode ser usada tanto como documento de contrato entre as partes quanto como mecanismo t√©cnico para validar que o software est√° aderente √†s regras. Por outro lado, aplicar SDD de forma efetiva exige disciplina, ferramentas adequadas e equipes acostumadas a lidar com formalismo maior do que em metodologias mais flex√≠veis, o que pode ser uma barreira em times √°geis que preferem rapidez de itera√ß√£o.

## [QA] DDD - Domain-Driven Design
<img src="https://img.shields.io/badge/Python-3.10.7-3776AB?style=flat&logo=Python&logoColor=white"> <img src="https://img.shields.io/badge/Node.js-16.17.0-339933?style=flat&logo=Node.js&logoColor=white"> <img src="https://img.shields.io/badge/Ruby-3.3-CC342D?style=flat&logo=Ruby&logoColor=white"> <img src="https://img.shields.io/badge/Go-1.21-00ADD8?style=flat&logo=Go&logoColor=white"> <img src="https://img.shields.io/badge/PHP-8.2-777BB4?style=flat&logo=PHP&logoColor=white"> <img src="https://img.shields.io/badge/C++-23-F5455C?style=flat&logo=CPlusPlus&logoColor=white"> <img src="https://img.shields.io/badge/Java-22.0.1-chocolate?style=flat&logo=OpenJDK&logoColor=white"> <img src="https://img.shields.io/badge/.NET-8.0.300-512BD4?style=flat&logo=DotNet&logoColor=white"> <img src="https://img.shields.io/badge/Rust-1.82.0-dda584?style=flat&logo=Rust&logoColor=white"> <img src="https://img.shields.io/badge/UML-diagrams-purple?style=flat&logo=UML&logoColor=white"> 

<a href=""><img src="https://em-content.zobj.net/source/microsoft-teams/363/ferris-wheel_1f3a1.png" align="right" height="77"></a>

O **DDD - Domain-Driven Design** (Projeto Orientado a Dom√≠nio) √© uma abordagem de desenvolvimento de software que se concentra em entender o **dom√≠nio do neg√≥cio** e modelar o software em torno desses conceitos e regras de neg√≥cio. 

√â um tipo de <a href="">modelagem de software</a> e um <a href="">design de software</a> orientado a objetos (OOP) que procura refor√ßar conceitos e boas pr√°ticas relacionadas √† OOP e surgiu como uma resposta √†s dificuldades enfrentadas por desenvolvedores ao lidarem com sistemas complexos, especialmente em dom√≠nios de neg√≥cio onde a l√≥gica e os requisitos mudam frequentemente. Isso vem em contrapartida com o uso comum do <a href="">Data-Driven Design</a> (Projeto Orientado a Dados), que a maioria dos desenvolvedores usa sem mesmo ter consci√™ncia disso. 

O DDD nos permite planejar uma arquitetura de microsservi√ßos decompondo o sistema maior em unidades independentes, compreendendo as responsabilidades de cada uma e identificando seus relacionamentos, ele n√£o √© um design pattern espec√≠fico, mas sim uma importante abordagem de design de software, com foco na modelagem de software para corresponder a um **dom√≠nio** de acordo com as informa√ß√µes dos especialistas desse dom√≠nio. O Domain-Driven Design (DDD) surgiu como uma metodologia revolucion√°ria para a modelagem de software, desenvolvida com o intuito de refinar e otimizar a correspond√™ncia entre o design do software e o dom√≠nio do software e o dom√≠nio do problema que ele busca resolver.

> Os microsservi√ßos s√£o a forma mais escal√°vel de desenvolver software. Mas voc√™ precisa de um bom design que permita que as equipes de desenvolvedores trabalhem de forma aut√¥noma e implementem sem atrapalhar umas √†s outras, caso contr√°rio, voc√™ perder√° os benef√≠cios de escalabilidade. O DDD ajuda a delimitar responsabilidades claras entre os servi√ßos, o que permite que equipes atuem de forma independente e coordenada.

<a href=""><img src="https://github.com/user-attachments/assets/47723806-ab10-490c-844f-6c5e8980e08f" align="right" height="177"></a>

> [!Important]
> Foi popularizado por Eric Evans em seu livro **Domain-Driven Design: Tackling Complexity in the Heart of Software**, publicado em 2003. Esse livro n√£o √© leve, especialmente se voc√™ ainda est√° no in√≠cio da jornada. Ele exige uma certa base em desenvolvimento orientado a objetos (OOP), arquitetura de software e experi√™ncia pr√°tica com projetos reais. Geralmente, ele √© mais proveitoso depois que voc√™ j√° trabalhou em sistemas mais complexos ou com arquitetura em camadas.

O DDD acaba aparecendo muito em code reviews (revis√µes de c√≥digo) porque ele n√£o √© s√≥ um conjunto de padr√µes t√©cnicos, mas uma maneira de organizar o racioc√≠nio e o design do sistema a partir do dom√≠nio de neg√≥cio. Diferente de TDD e BDD, que s√£o mais voltados ao como testar e como validar comportamento, o DDD toca no como estruturar o c√≥digo para refletir a realidade do problema que a aplica√ß√£o resolve.

Num code review, o time n√£o est√° apenas olhando se o c√≥digo ‚Äúfunciona‚Äù, mas se ele est√° leg√≠vel, sustent√°vel e alinhado ao dom√≠nio. √â a√≠ que DDD se torna um guia. Por exemplo, quando voc√™ define entidades e value objects, o revisor consegue avaliar se voc√™ est√° representando o dom√≠nio corretamente ou se misturou regras de neg√≥cio com detalhes de infraestrutura. Se voc√™ trabalha com bounded contexts, o code review ajuda a garantir que cada m√≥dulo est√° respeitando suas fronteiras e n√£o est√° acoplando responsabilidades que deveriam estar separadas. E quando se usa a linguagem ub√≠qua, qualquer pessoa envolvida no projeto pode bater o olho no c√≥digo e identificar termos familiares do neg√≥cio, reduzindo ambiguidades.

Isso muda o tom da revis√£o: em vez de ser s√≥ ‚Äúesse m√©todo est√° mal nomeado‚Äù ou ‚Äúesse if pode virar um switch‚Äù, passa a ser ‚Äúessa entidade realmente pertence a este contexto?‚Äù ou ‚Äúessa regra deveria estar no dom√≠nio ou no servi√ßo de aplica√ß√£o?‚Äù. S√£o discuss√µes de mais alto n√≠vel, que evitam d√≠vida t√©cnica e fortalecem a coer√™ncia do sistema. Por isso, times que adotam DDD costumam ter code reviews mais ricos, que n√£o param na forma, mas questionam se a ess√™ncia do c√≥digo est√° fiel ao problema que ele resolve.

Sem levar em conta o DDD, as **t√©cnicas de modelagem de dom√≠nio** s√£o m√©todos utilizados na engenharia de software para compreender e representar o dom√≠nio de um problema espec√≠fico. O dom√≠nio refere-se √† √°rea de conhecimento, contexto ou setor de neg√≥cios em que o software est√° sendo desenvolvido. A modelagem de dom√≠nio tem como objetivo capturar os conceitos, regras e relacionamentos do dom√≠nio em um formato compreens√≠vel e utiliz√°vel pelos desenvolvedores. Ent√£o, o DDD (Domain-Driven Design) √© uma abordagem para o desenvolvimento de software que combina conceitos de design de software e t√©cnicas de modelagem de dom√≠nio. N√£o √© considerado um design pattern espec√≠fico, mas sim uma abordagem geral para projetar e estruturar sistemas de software. Domain-Driven Design (DDD) √© um m√©todo de design de software em que os desenvolvedores constroem modelos para entender os requisitos de neg√≥cios de um dom√≠nio. Esses modelos servem como base conceitual para o desenvolvimento de software.

No entanto, suas ra√≠zes v√™m de pr√°ticas e ideias que estavam sendo discutidas na ind√∫stria desde os anos 1990. Durante esse per√≠odo, muitas empresas estavam adotando metodologias √°geis e enfrentando problemas ao construir sistemas que n√£o apenas funcionassem, mas que tamb√©m fossem f√°ceis de entender, modificar e expandir. Um dos grandes desafios era a chamada "lacuna sem√¢ntica" entre os especialistas de dom√≠nio (pessoas que entendem o neg√≥cio) e os desenvolvedores (que implementam solu√ß√µes t√©cnicas). Essa lacuna frequentemente levava a softwares que funcionavam de forma errada ou que eram dif√≠ceis de adaptar a mudan√ßas nos requisitos.

A ideia inicial do DDD √© voltar √† uma modelagem OO mais pura, por assim dizer. Devemos esquecer de como os dados s√£o persistidos e nos preocupar em como representar melhor as necessidades de neg√≥cio em classes e comportamentos (m√©todos). Isso significa que em DDD um `Cliente` pode n√£o ter um *setter* para os seus atributos comuns, mas pode ter m√©todos com l√≥gica de neg√≥cio que neste dom√≠nio de neg√≥cio pertencem ao `cliente`, como `void associarNovoCartao(Cartao)` ou `Conta recuperarInformacoesConta()`. Em resumo, as classes modeladas e os seus m√©todos deveriam representar o neg√≥cio da empresa, usando inclusive a mesma nomenclatura. A persist√™ncia dos dados √© colocada em segundo plano, sendo apenas uma camada complementar.

O DDD nasceu da necessidade de aproximar esses dois mundos. Eric Evans observou que o software bem-sucedido em contextos complexos era constru√≠do em torno de um **modelo de dom√≠nio** que capturava com precis√£o o conhecimento do neg√≥cio. Ele tamb√©m percebeu que os sistemas mais sustent√°veis utilizavam linguagens comuns entre especialistas e desenvolvedores, al√©m de t√©cnicas para isolar a complexidade e tornar o c√≥digo mais alinhado com as regras do dom√≠nio.

Com a evolu√ß√£o do desenvolvimento de softwares e no aumento da complexidade dos requisitos da aplica√ß√£o, √© extremamente relevante definirmos uma comunica√ß√£o clara entre as v√°rias partes envolvidas em um projeto de software. √â bastante comum haver conflitos entre os termos t√©cnicos utilizados pelas diferentes √°reas, seja entre analistas de neg√≥cios, desenvolvedores, especialistas financeiros ou de vendas. Nada mais natural haja visto que as equipes est√£o cada vez mais multidisciplinares. Para auxiliar em uma comunica√ß√£o fluida, os conceitos do DDD ‚Äî Domain Driven Design, prop√µem como um dos seus pilares a defini√ß√£o de uma _Linguagem Ub√≠qua_.

<a href=""><img src="https://github.com/user-attachments/assets/4873d674-b778-448b-a311-26f9307e624f"></a>

O DDD formalizou essas pr√°ticas ao introduzir conceitos como **Ubiquitous Language** (Linguagem Ub√≠qua), o cerne do DDD, que promove a cria√ß√£o de uma linguagem compartilhada entre todas as partes interessadas, e **Bounded Contexts** (Contextos Limitados), que ajudam a dividir sistemas grandes e complexos em partes menores e mais compreens√≠veis. Al√©m disso, o DDD trouxe aten√ß√£o para padr√µes arquiteturais que d√£o suporte ao dom√≠nio, como **Entidades** (Entity), **Agregados** (), **Reposit√≥rios** () e **Servi√ßos de Dom√≠nio** (), estabelecendo um design centrado na l√≥gica de neg√≥cios em vez de nas tecnologias subjacentes.

Para que possamos iniciar uma compreens√£o acerca de Linguagem Ub√≠qua (Ubiquitous Language), podemos nos valer da an√°lise sem√¢ntica do termo ub√≠quo: `u-b√≠-quo` (latim _ubiquus_, -a, -um), adjetivo:

- Que est√° ao mesmo tempo em toda a parte. = `ONIPRESENTE`
- Que tem dom da ubiquidade. = `ONIPRESENTE`
- Que est√° difundido em todo o lado. = `GERAL, UNIVERSAL`.

De forma conceitual, a linguagem ub√≠qua √© o conjunto de termos e inter-rela√ß√µes que fornecem a sem√¢ntica da comunica√ß√£o do dom√≠nio, que reflete a vis√£o do neg√≥cio. E de forma pr√°tica, ao se trabalhar com DDD, entende-se como comunica√ß√£o de mesma linguagem, em um √∫nico modelo, de forma que todos os envolvidos no projeto tenham a mesma compreens√£o acerca dos termos utilizados. Linguagem ub√≠qua pode parecer um termo complexo de se compreender, mas outro termo tamb√©m utilizado para identificar este tipo de comunica√ß√£o, nos auxilia em uma melhor compreens√£o: _Linguagem Onipresente_.

**Linguagem Onipresente** √© essencialmente os termos, palavras e defini√ß√µes utilizadas por todo o dom√≠nio do projeto. √â o idioma utilizado no cotidiano da empresa, as terminologias da realidade do neg√≥cio. Quando um projeto n√£o respeita a **linguagem do dom√≠nio** diversos problemas de comunica√ß√£o surgem, dificultando o desenvolvimento, implanta√ß√£o e sustenta√ß√£o da solu√ß√£o.

Quando termos utilizados no projeto v√£o sendo traduzidos, de acordo com o uso em cada departamento, a comunica√ß√£o se torna an√™mica e a assimila√ß√£o do conhecimento disperso. Em seu livro Domain Driven Design ‚Äî Atacando as Complexidades no Cora√ß√£o do Software, Eric Evans descreve de maneira clara esta problem√°tica:

> O custo de toda a tradu√ß√£o, al√©m do risco de entendimento errado, √© simplesmente muito alto. Um projeto precisa de uma linguagem em comum que seja mais robusta que o m√≠nimo denominador comum.

<a href=""><img src="https://github.com/user-attachments/assets/5ac09617-ba80-4f3f-955a-62bd9dfe77ee" align="right" height="77"></a>

A Linguagem Onipresente (ubiquitous language) n√£o est√° limitada a diagramas em <a href="">UML (Unified Modeling Languages, ou Linguagem de Modelagem Unificada)</a>, mas principalmente, define em seu vocabul√°rio nome das classes e opera√ß√µes de destaque. Inclui regras para implantar um dicion√°rio uniforme e expl√≠cito para o modelo, para que o mesmo possa ser utilizado com o m√°ximo de efici√™ncia poss√≠vel.

O **Diagram as code** (Diagrama como c√≥digo) √© uma abordagem de cria√ß√£o de diagramas que utiliza c√≥digo, em vez de ferramentas gr√°ficas, para desenhar e manter diagramas. Essa abordagem permite que os diagramas sejam criados e atualizados utilizando linguagens de programa√ß√£o ou marcadores, em vez de ferramentas de desenho gr√°fico. A pr√°tica de "Diagram as code" (Diagrama como c√≥digo) pode auxiliar no Domain-Driven Design (DDD), pois √© uma pr√°tica √∫til no DDD que ajuda a manter a documenta√ß√£o atualizada, facilita a colabora√ß√£o, fornece controle de vers√£o e permite a gera√ß√£o autom√°tica de diagramas. Vantagens do "Diagram as code" no DDD:

1. **Melhor documenta√ß√£o**: Com o "Diagram as code", voc√™ pode manter a documenta√ß√£o do seu modelo de dom√≠nio atualizada e sincronizada com o c√≥digo. Isso ajuda a garantir que a documenta√ß√£o seja precisa e refletida nas mudan√ßas no c√≥digo.
2. **Modelagem colaborativa**: O "Diagram as code" permite que os membros da equipe colaborativamente trabalhem no modelo de dom√≠nio, tornando mais f√°cil para os desenvolvedores, especialistas em dom√≠nio e outros stakeholders discutirem e refinarem o modelo.
3. **Vers√£o e controle**: Com o "Diagram as code", voc√™ pode usar sistemas de controle de vers√£o (como Git) para rastrear as altera√ß√µes no modelo de dom√≠nio. Isso ajuda a garantir que todas as altera√ß√µes sejam documentadas e possam ser revertidas se necess√°rio.
4. **Gera√ß√£o autom√°tica de diagramas**: Muitas ferramentas de "Diagram as code" permitem que voc√™ gere diagramas automaticamente a partir do c√≥digo. Isso pode economizar tempo e reduzir a chance de erros manuais.
5. **Integra√ß√£o com o ciclo de desenvolvimento**: O "Diagram as code" pode ser integrado ao ciclo de desenvolvimento de software, permitindo que os desenvolvedores trabalhem no modelo de dom√≠nio em paralelo com o desenvolvimento do c√≥digo.

As ferramentas permitem que voc√™ crie diagramas como c√≥digo, utilizando sintaxes espec√≠ficas para desenhar os diagramas. Em seguida, elas geram imagens ou diagramas a partir do c√≥digo. Algumas ferramentas populares para "Diagram as code" incluem:

<a href="https://www.plantuml.com/plantuml/uml/SyfFKj2rKt3CoKnELR1Io4ZDoSa700003"><img src="https://github.com/user-attachments/assets/cd3deff0-176a-4d9b-8735-0a1b2b1d2a33" align="right" height="77"></a>

- Mermaid
- **PlantUML**
- Graphviz
- C4 (abordagem de modelagem de software)

Normalmente os especialistas de um dom√≠nio, diretores, administradores, analistas, t√©cnicos, possuem pouca familiaridade com o jarg√£o t√©cnico utilizado no desenvolvimento de software, mas utilizam os jarg√µes pr√≥prios de sua √°rea de atua√ß√£o. A partir desta realidade, os especialistas de um dom√≠nio descrevem superficialmente o que necessitam, fazendo com que desenvolvedores criem abstra√ß√µes que sustentem o design da aplica√ß√£o. Com isso, uma compreens√£o uniforme vai se deteriorando exponencialmente.

<a href="https://www.plantuml.com/plantuml/uml/SyfFKj2rKt3CoKnELR1Io4ZDoSa700003"><img src="https://github.com/user-attachments/assets/d51f18a5-193c-49ef-8a83-83f42f1924f5" align="right" height="277"></a>

Como solu√ß√£o a esta dispers√£o na comunica√ß√£o, devemos usar a linguagem baseada no modelo de forma exaustiva at√© que a comunica√ß√£o seja fluida e compreens√≠vel entre os diversos setores envolvidos no projeto. Para que possamos alcan√ßar esta flu√™ncia, os especialistas do dom√≠nio devem vetar termos ou estruturas que n√£o transmitam uma compreens√£o clara acerca das funcionalidades envolvidas; os desenvolvedores devem se empenhar no cuidado com ambiguidades ou inconsist√™ncias que possam corromper o modelo proposto. Ou seja, √© um esfor√ßo conjunto entre todos os envolvidos, mas, √© essencialmente necess√°rio que ocorra.

Como identificar os especialistas de dom√≠nio? Especialistas de dom√≠nio s√£o os profissionais envolvidos no dia a dia da opera√ß√£o, nos mais diferentes setores, ou seja, s√£o os ‚Äúconhecedores‚Äù do neg√≥cio (stakeholders). Normalmente estes especialistas s√£o analistas, t√©cnicos, engenheiros, podendo ser todo aquele que possui a compreens√£o acerca do fluxo de opera√ß√£o da empresa. Os especialistas de dom√≠nio det√©m o conhecimento sobre as necessidades e requisitos necess√°rios para o processamento das atividades organizacionais.

<img src="https://github.com/user-attachments/assets/3e5b0f4e-5517-4b6d-a8a8-cd650c6f577d" align="right" height="277">

Em ess√™ncia, o DDD surgiu para enfrentar a complexidade inerente ao desenvolvimento de software em dom√≠nios desafiadores, permitindo que os sistemas sejam projetados de forma que o c√≥digo seja uma express√£o direta das regras e processos do neg√≥cio. Com o tempo, o DDD ganhou popularidade e passou a ser usado em diversos contextos, especialmente em sistemas corporativos onde o dom√≠nio de neg√≥cio √© complexo e sujeito a constantes mudan√ßas.

Para o sucesso de um projeto de software, o DDD sugere que tanto especialistas de dom√≠nio quanto desenvolvedores devem falar a mesma l√≠ngua.

A figura acima, ilustra a exist√™ncia de termos que s√≥ os especialistas de dom√≠nio conhecem e apresentam express√µes somente de car√°ter tecnol√≥gico, os quais s√£o de uso apenas do time de desenvolvimento. Contudo, √© necess√°rio que exista um conjunto de termos que devem ser de conhecimento universal, no que se refere ao dom√≠nio da aplica√ß√£o, formando a Linguagem Ub√≠qua do sistema. A defini√ß√£o de uma linguagem onipresente objetiva principalmente dois prop√≥sitos:

- Possibilitar uma comunica√ß√£o fluida entre os membros de equipes multidisciplinares; Nomear elementos do c√≥digo da aplica√ß√£o, como classes, m√©todos, vari√°veis, fun√ß√µes, m√≥dulos, tabelas de bancos de dados, rotas de APIs, etc.

- Ademais a padroniza√ß√£o na comunica√ß√£o prop√µe elucidar o significado dos termos, de um forma simples, objetiva e compreens√≠vel para facilitar os relacionamentos e associa√ß√µes entre todos m√≥dulos necess√°rios.

Qualquer pessoa t√©cnica contribuindo para o modelo deve programar, pelo menos tocar no c√≥digo, independente do papel desempenhado no projeto. Um respons√°vel por mudar o c√≥digo deve sempre aprender a expressar o modelo atrav√©s do c√≥digo. Todo desenvolvedor deve estar envolvido na discuss√£o sobre o modelo e ter contato com os especialistas do dom√≠nio. (EVANS, 2016).

Em seu livro Implementando Domain Driven Design, Vaughn Vernon, pontua que um especialista de dom√≠nio tem uma forte influ√™ncia sobre a linguagem utilizada, devido ao maior conhecimento acerca do neg√≥cio, que no final √© o contexto imperativo de todo projeto. Estes especialistas tendem a ser influenciados pelos padr√µes da ind√∫stria, contudo, uma linguagem universal deve ser centrada em como o pr√≥prio neg√≥cio pensa e opera. Ou seja, cada empresa possui seu pr√≥prio dom√≠nio acerca da execu√ß√£o de seus processos.

N√£o entenda Linguagem Ub√≠qua como um conjunto de jarg√µes de neg√≥cios sendo impostos ao time de desenvolvimento, e nem mesmo uma sobreposi√ß√£o de termos t√©cnicos sobre o contexto de neg√≥cio, mas sim, uma linguagem real que √© criada por toda a equipe e que √© propagada por toda a corpora√ß√£o.

Compreende-se que haver√° discord√¢ncias em rela√ß√£o aos termos utilizados e que est√£o na mente dos especialistas, mas, a partir do uso aberto da linguagem, a evolu√ß√£o √© natural e consolidada por este processo de matura√ß√£o da comunica√ß√£o.

O DDD enfatiza a compreens√£o profunda do dom√≠nio do problema e o uso de uma linguagem ub√≠qua compartilhada entre as equipes de desenvolvimento e especialistas do dom√≠nio. Ele prop√µe a organiza√ß√£o do c√≥digo em torno do dom√≠nio do problema, separando-o dos detalhes t√©cnicos e infraestrutura. 

Embora o DDD n√£o seja um design pattern em si, ele pode ser combinado com v√°rios design patterns e princ√≠pios de design, como Agregado, Reposit√≥rio, Especifica√ß√£o, Event Sourcing, entre outros. O DDD fornece diretrizes e conceitos para ajudar na cria√ß√£o de uma arquitetura de software robusta e flex√≠vel.

Portanto, podemos dizer que o DDD √© uma abordagem de design e uma metodologia de modelagem que pode ser aplicada em diferentes arquiteturas de software, como arquitetura em camadas, arquitetura hexagonal, arquitetura de microsservi√ßos, entre outras. Ele fornece princ√≠pios e pr√°ticas para projetar e estruturar o c√≥digo em torno do dom√≠nio do problema, visando um modelo de dom√≠nio rico, desacoplamento e flexibilidade.

√â uma abordagem mais ampla para o design de software que abrange v√°rios conceitos e t√©cnicas. DDD enfatiza a modelagem do dom√≠nio, a colabora√ß√£o entre especialistas do dom√≠nio e desenvolvedores, e a cria√ß√£o de um c√≥digo baseado em um entendimento profundo do dom√≠nio do problema.

No contexto do DDD, existem design patterns espec√≠ficos que s√£o frequentemente utilizados para ajudar a implementar os conceitos e princ√≠pios do DDD. Alguns desses padr√µes incluem:

<a href=""><img src="https://github.com/IsaacAlves7/DevSecOps/assets/61624336/0ade6281-cdca-47d3-8b95-57e81b61d04a" align="right" height="377"></a>

1. <a href="">Agregado</a>: Se refere a um padr√£o de design que agrupa um conjunto de objetos relacionados em uma √∫nica unidade coesa. O Agregado √© uma das principais constru√ß√µes utilizadas para modelar e organizar o dom√≠nio em DDD;

2. <a href="">Reposit√≥rio</a>: Fornece uma interface para acessar cole√ß√µes de objetos agregados, permitindo que o dom√≠nio permane√ßa livre de preocupa√ß√µes com persist√™ncia. Ele atua como uma camada intermedi√°ria entre o dom√≠nio e a fonte de dados (como bancos de dados).

3. <a href="">Servi√ßo de Dom√≠nio</a>: Representa opera√ß√µes ou a√ß√µes do dom√≠nio que n√£o pertencem naturalmente a uma √∫nica entidade ou value object. Encapsula l√≥gica de neg√≥cio que depende de m√∫ltiplos objetos.

4. <a href="">Value Object</a>: Objetos que n√£o possuem identidade pr√≥pria e s√£o definidos apenas por seus atributos. S√£o imut√°veis e usados para representar conceitos como dinheiro, coordenadas ou medidas.

5. <a href="">Entidade</a>: Objetos do dom√≠nio que possuem identidade pr√≥pria (geralmente um ID) e um ciclo de vida distinto. Diferente de value objects, entidades podem mudar seus atributos ao longo do tempo.

6. <a href="">Factory</a>: Padr√£o respons√°vel por encapsular a l√≥gica de cria√ß√£o complexa de objetos, especialmente agregados. Evita a polui√ß√£o do construtor com l√≥gica de montagem de objetos.

7. <a href="">Especifica√ß√£o</a>: Define regras de neg√≥cio reutiliz√°veis e combin√°veis para verificar se um objeto atende a determinados crit√©rios. √â √∫til para separa√ß√£o de responsabilidades e clareza das regras de dom√≠nio.

8. <a href="">Event Sourcing</a>: T√©cnica onde o estado do sistema √© determinado por uma sequ√™ncia de eventos (ao inv√©s de snapshots de dados). Permite reconstruir o estado do sistema e ter um hist√≥rico detalhado das mudan√ßas.

9. <a href="">Inje√ß√£o de Depend√™ncia (DI - Dependency Injection)</a>: T√©cnica que permite desacoplar componentes do sistema, facilitando testes, manuten√ß√£o e extensibilidade. No DDD, √© comum para injetar reposit√≥rios, servi√ßos de dom√≠nio e unidades de trabalho nos agregados e servi√ßos de aplica√ß√£o.

Esses padr√µes, juntamente com outros conceitos e t√©cnicas, podem ser aplicados para construir uma arquitetura que segue os princ√≠pios do DDD. O DDD, portanto, n√£o √© um design pattern em si, mas uma abordagem que pode ser implementada usando diversos padr√µes de design espec√≠ficos.

Quando n√£o usar DDD? √Äs vezes s√≥ √© necess√°rio um CRUD! DDD n√£o √© uma solu√ß√£o para tudo. A maioria dos sistemas possui uma boa parte composta por cadastros b√°sicos (CRUD) e n√£o seria adequado usar DDD para isso.

O DDD deve ajudar na modelagem das classes mais importantes e mais centrais do sistema de forma e diminuir a complexidade e ajudar na manuten√ß√£o das mesmas, afinal este √© o objetivo dos princ√≠pios de orienta√ß√£o a objetos.

Outro ponto √© sobre n√≥s desenvolvedores estarmos compartilhando dados com outros sistemas, as rotinas de integra√ß√£o que recebem ou disponibilizam dados para outros sistemas n√£o devem ser "inteligentes". Muitos desenvolvedores acabam modelando suas classes de neg√≥cios tentando resolver as quest√µes internas do sistema e, ao mesmo tempo, pensando em como essas classes ser√£o expostas para outros sistemas. Padr√µes como DTO (Data Transfer Object) que usam objetos "burros" s√£o mais adequados para isso.

Portanto, o DDD n√£o tenta resolver todos os problemas de todas as camadas de um sistema. Seu foco √© na modelagem das entidades principais de neg√≥cio usando a linguagem adequada daquele dom√≠nio para facilitar a manuten√ß√£o, extens√£o e entendimento. Particularmente, eu n√£o seguiria √† risca o padr√£o, at√© porque existem in√∫meros padr√µes e varia√ß√µes de modelagem OO. Estude os princ√≠pios por detr√°s desses padr√µes, pois eles s√£o geralmente parecidos e veja o que funciona melhor para cada projeto.

# [QA] UAT - User Acceptance Testing
O **User Acceptance Testing (UAT)**, ou Teste de Aceita√ß√£o do Usu√°rio, √© uma etapa final e crucial dentro do ciclo de testes de software. Ele acontece quando o sistema j√° passou por testes internos ‚Äî como unit√°rios, de integra√ß√£o, funcionais e de sistema ‚Äî e est√° teoricamente pronto para ser colocado em produ√ß√£o. A ideia do UAT √© validar se o software realmente atende √†s necessidades do usu√°rio final e aos requisitos de neg√≥cio. Aqui, o foco n√£o √© tanto verificar se o c√≥digo funciona sem erros t√©cnicos, mas se a solu√ß√£o √© √∫til, intuitiva e cumpre aquilo que foi solicitado e esperado. Por isso, normalmente √© realizado pelos pr√≥prios usu√°rios, clientes, stakeholders ou representantes do neg√≥cio, com o suporte da equipe de QA.

Dentro do ecossistema de QA, o UAT se integra como a camada de valida√ß√£o final que coroa todo o pipeline de testes. Em um fluxo t√≠pico, o software passa por testes unit√°rios para verificar pequenos blocos de c√≥digo isolados, depois vai para testes de integra√ß√£o para garantir que os m√≥dulos funcionem em conjunto, segue para testes funcionais e de sistema que avaliam requisitos e comportamento completo, pode ainda passar por testes n√£o funcionais como performance, seguran√ßa e usabilidade. S√≥ depois desse ciclo √© que entra o UAT, pois n√£o faria sentido colocar o usu√°rio para validar algo que ainda tem falhas b√°sicas de funcionamento ou de estabilidade.

O UAT funciona quase como um ‚Äúfiltro de realidade‚Äù: ele conecta a linguagem t√©cnica do QA com a linguagem de neg√≥cio do cliente. Muitas vezes, mesmo um sistema tecnicamente correto pode falhar no UAT se n√£o atender ao fluxo real que o usu√°rio precisa seguir no dia a dia. √â comum, por exemplo, que durante o UAT se descubra que um processo est√° tecnicamente certo, mas exige muitos cliques desnecess√°rios, ou n√£o reflete a forma como o trabalho √© feito na pr√°tica. Assim, ele serve para alinhar expectativas, corrigir ajustes de usabilidade e garantir que, no momento do go-live, o software n√£o s√≥ funcione, mas tamb√©m seja aceito pelo p√∫blico a que se destina.

Em termos de QA, voc√™ pode pensar no UAT como o elo entre testes de qualidade t√©cnica e testes de valor de neg√≥cio. Ele n√£o substitui os outros, mas se apoia neles: se os testes anteriores garantem que o software √© confi√°vel, o UAT garante que ele √© √∫til e aprovado pelo cliente.
