[![License](https://img.shields.io/badge/license-Apache%20License%202.0-blue.svg)](https://opensource.org/licenses/Apache-2.0)
[![Java](https://img.shields.io/badge/java-17%2B-blue)](https://www.oracle.com/java/technologies/javase/jdk17-archive-downloads.html)
[![Release](https://img.shields.io/github/release/rife2/tests-badge.svg)](https://github.com/rife2/tests-badge/releases/latest)
[![GitHub CI](https://github.com/rife2/tests-badge/actions/workflows/bld.yml/badge.svg)](https://github.com/rife2/tests-badge/actions/workflows/bld.yml)
[![Tests](https://rife2.com/tests-badge/badge/com.uwyn/tests-badge)](https://github.com/rife2/tests-badge/actions/workflows/bld.yml)
[![Tests](https://rife2.com/tests-badge/badge/com.uwyn/tests-badge)](https://github.com/rife2/tests-badge/actions/workflows/bld.yml)

<a href="https://github.com/IsaacAlves7/qa"><img width="1920" height="500" alt="image" src="https://github.com/user-attachments/assets/7675c835-51aa-4d5d-b46b-8d8b81d948a8" /></a>

> Vers√≠culo chave: "Consagre ao Senhor tudo o que voc√™ faz, e os seus planos ser√£o bem-sucedidos." - Prov√©rbios 16:3

# QA/QC - Quality Assurance and Quality Control üë®üèæ‚Äçüî¨
<img src="https://img.shields.io/badge/Python-3.10.7-3776AB?style=flat&logo=Python&logoColor=white"> <img src="https://img.shields.io/badge/Node.js-16.17.0-339933?style=flat&logo=Node.js&logoColor=white"> <img src="https://img.shields.io/badge/Ruby-3.3-CC342D?style=flat&logo=Ruby&logoColor=white"> <img src="https://img.shields.io/badge/Go-1.21-00ADD8?style=flat&logo=Go&logoColor=white"> <img src="https://img.shields.io/badge/PHP-8.2-777BB4?style=flat&logo=PHP&logoColor=white"> <img src="https://img.shields.io/badge/C++-23-F5455C?style=flat&logo=CPlusPlus&logoColor=white"> <img src="https://img.shields.io/badge/Java-22.0.1-chocolate?style=flat&logo=OpenJDK&logoColor=white"> <img src="https://img.shields.io/badge/.NET-8.0.300-512BD4?style=flat&logo=DotNet&logoColor=white">

<a href=""><img src="https://em-content.zobj.net/source/microsoft-teams/363/man-scientist-medium-dark-skin-tone_1f468-1f3fe-200d-1f52c.png" align="right" height="77"></a>

Imagine-se como um entusiasta da tecnologia, ansioso por entender como um software pode ser eficaz e confi√°vel. Como garantir que um software atenda √†s expectativas dos usu√°rios e funcione sem falhas? Esse dilema cria um conflito cognitivo que nos impulsiona a mergulhar mais fundo.

A hist√≥ria da **Qualidade de Software** nos mostra a evolu√ß√£o dos processos, desde as abordagens mais tradicionais at√© as metodologias √°geis modernas. Aprender sobre modelos de qualidade, como o ISO 25000, e as dimens√µes da qualidade, como funcionalidade e usabilidade, enriquece nossa compreens√£o. As pe√ßas se encaixam, transformando a quest√£o inicial em um quebra-cabe√ßa conceitual.

Imagine que voc√™ √© um membro de uma equipe de desenvolvimento de software. Voc√™ √© desafiado a aplicar os conceitos aprendidos em um cen√°rio real. Voc√™ participa de revis√µes, que s√£o an√°lises colaborativas do c√≥digo, e auditorias, que avaliam os processos utilizados. Essa simula√ß√£o o coloca no ambiente profissional, onde as decis√µes t√™m impacto direto na qualidade do software.

Ao concluir as revis√µes e auditorias, voc√™ reflete sobre os processos e a efic√°cia das t√©cnicas aplicadas. Reconhece a import√¢ncia de identificar falhas cedo e como as revis√µes sistem√°ticas podem prevenir erros custosos. Voc√™ compreende que, assim como o software, o aprendizado √© um processo cont√≠nuo (Continuous Learning). E √† medida que voc√™ assimila esses conceitos, torna-se mais apto a contribuir para o desenvolvimento de software de alta qualidade, solidificando sua jornada na compreens√£o da Qualidade de Software

> [!Note]
> Esse conte√∫do √© geralmente abordado no final das gradua√ß√µes da √°rea de TI, ou seja, √© um m√≥dulo avan√ßado e atua com boas pr√°ticas do mercado. Ent√£o eu vou supor que todos j√° sabem desenvolver softwares e pular toda a parte de codifica√ß√£o com metodologias √°geis e ciclo de vida de desenvolvimento para partir pro ponto de qualidade de software.

> [!Tip]
> Vamos recordar a import√¢ncia das boas pr√°ticas de programa√ß√£o como um elemento essencial na busca pela qualidade de software. Revisitarmos a no√ß√£o de c√≥digo limpo e bem estruturado, que n√£o s√≥ facilita a manuten√ß√£o, mas tamb√©m reduz erros e falhas futuras. Recordar como padr√µes de nomenclatura consistentes, coment√°rios claros e modulariza√ß√£o do c√≥digo s√£o cruciais para criar um produto de software robusto e de f√°cil compreens√£o. Isso nos lembrar√° que a qualidade n√£o se limita apenas aos processos de teste, mas come√ßa desde a concep√ß√£o do c√≥digo-fonte.

Primeiro, precisamos entender que a qualidade de software √© uma √°rea de grande import√¢ncia no mercado de tecnologia da informa√ß√£o. E para garantir a qualidade de um software, √© preciso conhecer seus fundamentos, entender sua hist√≥ria, compreender os custos envolvidos, realizar atividades de apoio, seguir padr√µes e avaliar seus atributos. A seguir, apresentamos alguns desses atributos:

> [!Important]
> **Defini√ß√£o**: Qualidade √© a caracter√≠stica ou atributo que define algo ou algu√©m em termos de excel√™ncia, valor, ou n√≠vel de desempenho. Pode se referir a propriedades como durabilidade, efici√™ncia, efic√°cia, ou valor percebido. ‚ÄúQualidade √© a medida de quanto um projeto atende aos requisitos especificados no escopo.‚Äù

<img src="https://github.com/IsaacAlves7/DevSecOps/assets/61624336/ff221b02-782f-4525-8375-b3d672c6eb05" align="right" height="77">

Desde muito tempo, muitos engenheiros de software e empresas desenvolveram softwares de modo casual, por acreditarem que a cria√ß√£o de programas n√£o podia seguir regras, normas ou padr√µes. Por√©m, o poder da comunidade eletr√¥nica caracter√≠stica do s√©culo XXI, criada por redes de computadores e softwares, instituiu a era da troca de informa√ß√£o e conhecimentos em todo o mundo.

Sendo assim, destaca-se a √°rea de Engenharia de Software, que auxilia o entendimento do processo de desenvolvimento de softwares. Desta forma, nos processos de qualidade de software, a ger√™ncia de risco e o teste de software s√£o pontos fundamentais para a garantia da qualidade do produto gerado.

A proposta da disciplina √© oferecer a voc√™ um guia quanto √† import√¢ncia de as empresas implementarem normas e modelos que permitam a garantia e a correta avalia√ß√£o de qualidade de produtos e de processos de desenvolvimento de software.

O objetivo da fun√ß√£o de qualidade e testes de software √©:

- Reconhecer a necessidade de se adotar um processo de testes para garantir a qualidade do desenvolvimento de software, bem como as m√©tricas utilizadas nos testes;
- Desenvolver um plano de qualidade de software (SQA) que esteja em conformidade com normas e padr√µes de qualidade, bem como usar ferramentas para garantir a qualidade no seu desenvolvimento;
- Produzir planos de mitiga√ß√£o de riscos e identificar qual modelo se adapta para cada tipo de software.

Antes de passarmos para os modelos de integra√ß√£o, discutiremos brevemente sobre os VCS, Modelos de controle de vers√£o.

Em uma equipe de desenvolvimento, precisaremos de uma ajuda para sincronizar e manter o hist√≥rico do c√≥digo, de maneira concreta utilizamos ferramentas como **Git** e SVN.

A integra√ß√£o cont√≠nua n√£o possui necessidade de muitas ferramentas, em tese, mas alguns aux√≠lios que s√£o padr√£o em pr√°ticas de desenvolvimento s√£o requiridos.

O **Git** √© o mais popular em integra√ß√£o hoje em dia, mas n√£o precisamos utiliza-lo, basta que tenhamos algum modelo de controle de vers√£o de nossa escolha.

A ferramenta em si n√£o importa, mas o que devemos inserir em nosso sistema de controle? De maneira geral, deve conter tudo aquilo que √© necess√°rio para a constru√ß√£o do projeto.

- c√≥digo
- scripts
- migra√ß√µes, schemas
- IDE Configs
- Devemos definir uma formata√ß√£o de c√≥digo para a equipe. Para come√ßarmos um projeto √© necess√°rio fazer o clone - a c√≥pia local - e o comando unificado (deve ser f√°cil).
- N√£o significa que devemos comitar o artefato de constru√ß√£o, ou seja, no caso de um desenvolvedor Ruby ou Gem n√£o deveria estar dentro do reposit√≥rio, o mesmo ocorre no mundo Java. Resultados da constru√ß√£o do software n√£o s√£o comitados como gem, jar, image e modules.

Sabemos o que comitar e o que n√£o comitar, ent√£o seguiremos estudando os modelos de reposit√≥rio que exitem no mercado. Ent√£o, o que deve conter no reposit√≥rio?

- **Scripts de testes**, os testes s√£o uma parte essencial da aplica√ß√£o. Os testes tamb√©m s√£o c√≥digos, e scripts relacionados a eles devem entrar no reposit√≥rio;
- **Database Schema**, faz parte da aplica√ß√£o e √© preciso para construir e executar o projeto.

Contudo, como organizar nossos reposit√≥rios? Em uma empresa encontramos mais de um projeto por vez, e √© importante que saibamos como representar estes projetos dentro do reposit√≥rio.

O que √© mais natural √© utilizar um reposit√≥rio para cada projeto, de um tamanho razo√°vel com escopo bem definido. Essa forma de organiza√ß√£o √© chamada **Multi-repo**.

No entanto, nos √∫ltimos anos, surgiu uma nova forma de organiza√ß√£o dos nossos projetos dentro de reposit√≥rios. Empresas grandes de tecnologia como Google e Facebook n√£o utilizam o esquema Multi-repo, porque s√£o empresas que trabalham em in√∫meros projetos de maneira concomitante. Empresas que atuam com outra dimens√£o de projetos utilizam o **Mono-repo**, ou seja, um √∫nico e gigantesco reposit√≥rio que acumula todos os projetos.

A desvantagem do segundo modelo √© o reposit√≥rio precisar√° ser realmente grande, e o *build* pode ser lento, talvez nem o Git seja mais a ferramenta adequada para fazer o controle de vers√µes para esta situa√ß√£o. Contudo, como temos apenas um grande reposit√≥rio temos uma administra√ß√£o relativamente mais simples, ent√£o a verifica√ß√£o de padr√µes √© facilitada. As refatora√ß√µes s√£o globais, afinal est√£o todos dentro da mesma base.

Vamos trabalhar com o Multi-repo, afinal √© o mais comum no dia a dia da maioria dos desenvolvedores.

> [!Note]
> **FUNDAMENTOS DA QUALIDADE DE SOFTWARE**: Incluem a defini√ß√£o de requisitos, o planejamento de testes e a execu√ß√£o de testes de forma sistem√°tica. Esses processos s√£o essenciais para garantir que o software desenvolvido atenda √†s necessidades do usu√°rio e atinja a qualidade esperada.

No antigo Egito, h√° aproximadamente 4 mil anos, para que as constru√ß√µes fossem feitas com **qualidade**, definiu-se o c√∫bito, que era a dist√¢ncia do cotovelo √† ponta do indicador do fara√≥. Uma das primeiras tentativas da humanidade de _padronizar_ as medidas, gerando qualidade nas constru√ß√µes.

Nesta escultura, temos na base um compilado com as regras e leis a serem seguidas, impostas por Hamurabi, Rei da Babil√¥nia, que era aplicada a cidad√£os livres, comerciantes, escravos, etc. Uma das primeiras tentativas de _padronizar_ as regras de conv√≠vio da sociedade, h√° aproximadamente 3.800 anos atr√°s.

Historicamente, o conceito de qualidade est√° ligado √† ideia de atender padr√µes e requisitos acordados, com base em comunica√ß√£o clara e objetivos definidos, seja na qualidade do ar, qualidade da √°gua, da qualidade de vida ou qualidade do software. Portanto, a qualidade de software √© a investiga√ß√£o do software a fim de fornecer informa√ß√µes sobre sua qualidade em rela√ß√£o ao contexto em que ele deve operar.

A busca por qualidade n√£o √© algo novo. Desde os prim√≥rdios, o ser humano busca aprimorar suas cria√ß√µes e produ√ß√µes, seja para torn√°-las mais dur√°veis, funcionais ou esteticamente agrad√°veis. Com o advento da Revolu√ß√£o Industrial, essa busca se intensificou, principalmente no que diz respeito √† produ√ß√£o em massa. 

Mas foi somente com a Segunda Guerra Mundial que a qualidade passou a ser vista como uma quest√£o estrat√©gica, com a necessidade de se produzir em larga escala produtos de alta qualidade para suprir as demandas militares. A partir da√≠, a qualidade come√ßou a ser tratada como um processo e a ser estudada de forma mais sistem√°tica. A evolu√ß√£o hist√≥rica da qualidade de software pode ser dividida em v√°rias fases:

1. **PRIMEIRA FASE**: Conhecida como era dos ‚Äúprogramadores her√≥is‚Äù, ocorreu na d√©cada de 1940 a 1950, quando o foco era na programa√ß√£o manual e n√£o havia processos formais de garantia de qualidade.

2. **SEGUNDA FASE**: Foi a era dos ‚Äúprodutos de software‚Äù, que teve in√≠cio nos anos 1960 e trouxe a necessidade de se preocupar com a qualidade dos softwares produzidos, mas ainda sem muita formaliza√ß√£o.

3. **TERCEIRA FASE**: A era da ‚Äúengenharia de software‚Äù, teve in√≠cio nos anos 1970 e marcou o surgimento de processos formais de desenvolvimento de software e de metodologias para garantir a qualidade do produto final. Nesta fase, foi criada a ISO 9000, que estabeleceu padr√µes de qualidade para empresas e servi√ßos em geral.

4. **QUALIDADE TOTAL**: Teve in√≠cio na d√©cada de 1980, trouxe a ideia de que a qualidade n√£o √© responsabilidade apenas da √°rea de desenvolvimento de software, mas sim de toda a organiza√ß√£o. Foram estabelecidos processos de melhoria cont√≠nua e a necessidade de se envolver todos os departamentos e funcion√°rios na busca pela qualidade.

5. **QUALIDADE DE SOFTWARE**: Teve in√≠cio nos anos 1990, trouxe a necessidade de se preocupar com a qualidade do processo de desenvolvimento do software, e n√£o apenas com o produto final. Surgiram novas metodologias e modelos de maturidade, como o Capability Matu
rity Model Integration (CMMI) e o ISO/IEC 12207, que buscam garantir a qualidade do processo de desenvolvimento.

No in√≠cio da d√©cada de 1980, o governo dos Estados Unidos reconheceu a necessidade de padronizar a qualidade do software. Em 1986, foi publicado o padr√£o IEEE 610.12, que definiu a terminologia b√°sica usada em engenharia de software, incluindo defini√ß√µes de qualidade de software. Essas defini√ß√µes incluem ‚Äúqualidade de software‚Äù como o grau em que um sistema, componente ou processo atende aos requisitos especificados e/ou impl√≠citos e √†s necessidades ou expectativas do usu√°rio.

A partir de ent√£o, a qualidade de software se tornou um foco importante na ind√∫stria de TI e foi acompanhada pelo surgimento de v√°rias ferramentas e t√©cnicas de teste e garantia de qualidade de software. A demanda por softwares confi√°veis e de alta qualidade √© cada vez maior, uma vez que muitos neg√≥cios e servi√ßos dependem de sistemas de software em seus processos di√°rios.

Hoje em dia, a busca pela qualidade de software continua em constante evolu√ß√£o, com a introdu√ß√£o de novas tecnologias e metodologias, como a integra√ß√£o cont√≠nua e o desenvolvimento √°gil, e intelig√™ncia artificial que buscam garantir a qualidade do software de forma mais eficiente e r√°pida.

No entanto, a busca pela qualidade de software ainda √© um desafio constante. Novas tecnologias e metodologias surgem a cada dia, e os desenvolvedores de software devem estar atualizados sobre as novas tend√™ncias e ferramentas dispon√≠veis. Al√©m disso, a complexidade dos sistemas de software modernos tamb√©m torna o controle de qualidade mais dif√≠cil, exigindo uma abordagem mais estruturada e orientada a processos.

Portanto, os aspectos hist√≥ricos da qualidade de software nos mostram como essa √°rea evoluiu ao longo do tempo. Desde a d√©cada de 1970, a qualidade de software vem sendo debatida e estudada, e hoje em dia √© um tema muito importante em empresas de desenvolvimento de software.

Para aprofundar seus conhecimentos sobre qualidade de software, voc√™ pode se perguntar: como garantir que um software seja de qualidade? Uma resposta √© adotar processos de garantia de qualidade, que englobam atividades como revis√µes, testes e inspe√ß√µes para identificar e corrigir defeitos. Al√©m disso, √© importante definir crit√©rios de qualidade e medir a qualidade do software com base nesses crit√©rios.
 
Uma ilustra√ß√£o que pode ajudar a entender a import√¢ncia da qualidade de software √© pensar em um aplicativo de banco que apresenta erros constantemente. Isso certamente afetaria a confian√ßa do usu√°rio no aplicativo e, consequentemente, na institui√ß√£o financeira. Por isso, a qualidade do software √© fundamental para garantir a satisfa√ß√£o e fideliza√ß√£o do usu√°rio.

Os fundamentos de **teste de software** (Software Testing) se referem a um conjunto de pr√°ticas e t√©cnicas utilizadas para garantir que um software seja capaz de atender aos requisitos e expectativas dos usu√°rios, al√©m de estar livre de erros e falhas. Para ser eficaz, o teste de software deve ser planejado, executado e gerenciado de forma adequada. Isso envolve identificar e definir os objetivos do teste, estabelecer crit√©rios de aceita√ß√£o, selecionar as t√©cnicas e ferramentas adequadas e documentar todo o processo.

Entre os fundamentos do teste de software est√£o:

1. **Identifica√ß√£o de requisitos**: Os **requisitos** (requirements) s√£o funcionalidades que o produto precisa ter para atender √†s expectativas e necessidades das partes interessadas. √â importante que todos os requisitos do software estejam claramente definidos e documentados antes do in√≠cio do teste. Essa etapa √© crucial para garantir que o software atenda √†s expectativas dos usu√°rios e construir MVPs (M√≠nimo Produto Vi√°vel). O **escopo** √© o conjunto de caracter√≠sticas desejadas que descrevem o resultado final do projeto.

2. **Planejamento de teste**: o planejamento do teste deve ser feito de forma estruturada e detalhada, incluindo a defini√ß√£o dos objetivos, recursos, cronograma, t√©cnicas e crit√©rios de aceita√ß√£o.

3. **Projeto de casos de teste**: os casos de teste devem ser projetados de acordo com os requisitos e objetivos do teste, de forma a garantir a cobertura de todos os aspectos do software.

4. **Execu√ß√£o de testes**: a execu√ß√£o dos testes deve ser feita de forma sistem√°tica e controlada, registrando todas as falhas encontradas.

5. **Avalia√ß√£o de resultados**: os resultados dos testes devem ser avaliados de acordo com os crit√©rios de aceita√ß√£o para determinar se o software atendeu aos requisitos.

6. **Relat√≥rios e documenta√ß√£o**: todos os resultados e conclus√µes do teste devem ser documentados de forma clara e concisa para permitir que outras pessoas entendam e repliquem o processo.

Al√©m desses fundamentos b√°sicos, existem diversas t√©cnicas e ferramentas de teste que podem ser utilizadas para tornar o processo mais eficiente e eficaz. Essas incluem testes funcionais, testes de desempenho, testes de seguran√ßa, testes de usabilidade, dentre outros. √â importante que o testador esteja familiarizado com as diferentes t√©cnicas e saiba selecionar a mais adequada para cada situa√ß√£o. 

Outro aspecto importante dos fundamentos de qualidade de software √© a colabora√ß√£o entre as equipes envolvidas no desenvolvimento. √â preciso que todos os membros trabalhem em conjunto para garantir a qualidade do produto final. Isso inclui desde a comunica√ß√£o eficiente entre os desenvolvedores e os testadores at√© a participa√ß√£o do usu√°rio em testes de aceita√ß√£o.

<img src="https://github.com/user-attachments/assets/e2a8279f-4b9e-44f5-aea4-278ae9cc5bfe" align="right" height="177">

> [!Important]
> **Software Engineering: A Practitioner's Approach**: Para aprofundar seus conhecimentos sobre qualidade de software, voc√™ pode recorrer a materiais como artigos cient√≠ficos, livros e cursos on-line. Uma indica√ß√£o de leitura √© o livro Software Engineering: A Practitioner's Approach, de Roger Pressman, que aborda temas como garantia de qualidade, medi√ß√£o de qualidade e processos de software. Em resumo, entender os fundamentos de qualidade de software √© essencial para garantir o sucesso de projetos de desenvolvimento. Isso inclui a compreens√£o do conceito de qualidade, a ado√ß√£o de processos de garantia de qualidade, a defini√ß√£o de crit√©rios de qualidade e a colabora√ß√£o entre as equipes. Aprofundar seus conhecimentos neste tema √© fundamental para se destacar no mercado de trabalho e garantir a satisfa√ß√£o do usu√°rio.

Portanto, o teste de software (Software testing) para os profissionais de QA‚Äôs √© a forma que utilizamos para avaliar um software, com um objetivo de assegurar e garantir a qualidade do mesmo, nos pontos de vista t√©cnico e funcional. 

<img height="277" align="right" src="https://github.com/user-attachments/assets/156de8a8-38de-4fc1-9920-aa8cb2c75f38" />

O **teste de software** √© a pr√°tica concreta que os profissionais de QA (no papel de testers, engenheiros de teste ou SDETs) usam para avaliar se o produto realmente cumpre o que deveria cumprir, tanto sob o ponto de vista t√©cnico (estabilidade, performance, seguran√ßa) quanto funcional (se as regras de neg√≥cio e requisitos do usu√°rio est√£o atendidos).

O desenvolvimento de software tem v√°rias fases. Quando come√ßamos a construir software, primeiro precisamos definir o que planejamos construir. Definimos alguns limites para o escopo do software que estamos construindo, definimos processos intermedi√°rios e marcos para colocar alguns pontos de verifica√ß√£o sobre se estamos indo na dire√ß√£o certa durante o processo de desenvolvimento e definimos crit√©rios de sucesso para que o software saiba o que constru√≠mos √© o que quer√≠amos. O termo mais amplo e sofisticado "Garantia de Qualidade" lida com o estabelecimento de limites e pontos de verifica√ß√£o, e "Teste" √© um subconjunto do processo geral de garantia de qualidade que lida com a valida√ß√£o de que tudo isso se juntou para culminar em um produto final que deixar√° as partes interessadas felizes (principalmente). Se tudo isso √© muito abstrato, n√£o tema, explicaremos com um exemplo mais concreto em breve.

<img height="600" align="right" src="https://github.com/user-attachments/assets/75d2ef4f-90d7-4011-a58d-e0ad1c904967" />

Digamos que temos uma ambi√ß√£o simples - queremos aceitar alguma entrada do usu√°rio e imprimi-la de volta no console. A vida n√£o poderia ser mais simples do que isso, pode? Vamos ver como isso se traduz no processo SDLC. Duvido que uma explica√ß√£o seja necess√°ria, mas aqui est√°, no entanto - n√£o √© um exemplo da vida real, mas simplificado demais para ilustrar o processo de pensamento e tamb√©m por que o teste de aplicativos evoluiu como uma disciplina separada do desenvolvimento. 

> "Descobrir o inesperado √© mais importante do que confirmar o conhecido." - George E.P.Box

Quando falamos de testes de software usamos bastante os conceitos de dois pontos de vista: o _caminho test√°vel_ e _caminho feliz_, mas cada um tem um prop√≥sito diferente dentro da estrat√©gia de valida√ß√£o do sistema. O chamado ‚Äúcaminho feliz‚Äù (ou ‚Äúhappy path‚Äù) √© aquele fluxo idealizado em que tudo acontece como esperado, sem erros, exce√ß√µes ou desvios. √â o cen√°rio perfeito, onde o usu√°rio ou o sistema segue exatamente o que foi planejado, com entradas v√°lidas, comportamento conforme os requisitos e sa√≠da correta. √â fundamental porque garante que a funcionalidade principal est√° realmente atendendo ao objetivo esperado quando usada da maneira correta, e por isso √© quase sempre o primeiro caso de teste escrito, seja em testes manuais, automatizados, unit√°rios ou de integra√ß√£o.

J√° o ‚Äúcaminho test√°vel‚Äù (alternativo ou inesperado) pode ter interpreta√ß√µes ligeiramente diferentes dependendo do contexto, mas normalmente √© usado para se referir a qualquer rota dentro do c√≥digo ou do fluxo da aplica√ß√£o que pode ser exercitada por um teste. √â o conjunto de caminhos poss√≠veis que o teste consegue alcan√ßar, incluindo o caminho feliz e tamb√©m as rotas alternativas, os cen√°rios de exce√ß√£o, entradas inv√°lidas, erros de neg√≥cio, falhas de integra√ß√£o, entre outros. Em outras palavras, n√£o √© s√≥ garantir que a fun√ß√£o principal funciona, mas tamb√©m que o sistema se comporta corretamente quando algo sai do esperado. √â a√≠ que entram testes negativos, de borda, de falha, de performance ou at√© mesmo de seguran√ßa, que exercitam a aplica√ß√£o de forma mais ampla e realista.

Portanto, quando voc√™ ouve falar de ‚Äúcaminho feliz‚Äù, √© um subconjunto do ‚Äúcaminho test√°vel‚Äù. O caminho feliz prova que o b√°sico funciona; o caminho test√°vel inclui todas as outras possibilidades para dar robustez √† aplica√ß√£o. Ou seja, o usu√°rio √© inesperado, ent√£o vamos precisar "preparar" a aplica√ß√£o para coisas inesperadas.

<img height="377" align="right" src="https://github.com/user-attachments/assets/0ec5b719-1df3-47b4-9d9d-b8c2db2adb1c" />

No universo do desenvolvimento de software, a qualidade √© um objetivo primordial, e dois termos frequentemente se entrela√ßam nesse contexto: Quality Assurance (QA) e Quality Control (QC). Embora muitas vezes usados como sin√¥nimos, esses conceitos representam abordagens distintas, por√©m complementares, para garantir que o produto final atenda aos mais altos padr√µes de excel√™ncia.

**Quality Assurance (QA)**: Prevenindo os Erros Antes que Eles Acontec√ßam

Imagine um arquiteto meticuloso, que examina cada detalhe do projeto de uma casa, desde a funda√ß√£o at√© o telhado, para garantir que a constru√ß√£o seja s√≥lida, segura e atenda √†s necessidades dos moradores. Essa √© a ess√™ncia do QA, um processo proativo que se concentra em prevenir erros e defeitos durante todo o ciclo de desenvolvimento de software.

O QA atua como um guardi√£o da qualidade, definindo e implementando processos, padr√µes e melhores pr√°ticas para garantir que o software seja desenvolvido da maneira correta, desde o in√≠cio. Ele se concentra em:

- Definir e monitorar os processos de desenvolvimento: Implementar metodologias e pr√°ticas que garantam a qualidade em todas as etapas do desenvolvimento.
- Estabelecer padr√µes de qualidade: Definir crit√©rios e m√©tricas para avaliar a qualidade do software em diferentes aspectos, como funcionalidade, usabilidade, desempenho e seguran√ßa.
- Prevenir defeitos: Implementar medidas preventivas para evitar que erros e defeitos sejam introduzidos no software, como revis√µes de c√≥digo, testes unit√°rios e an√°lise est√°tica de c√≥digo.
- Promover a cultura de qualidade: Incentivar a colabora√ß√£o, a comunica√ß√£o e o feedback entre os membros da equipe, criando um ambiente onde a qualidade √© valorizada e priorizada.

**Quality Control (QC)**: Detectando e Corrigindo os Bugs

Agora, imagine um inspetor de qualidade que examina cada c√¥modo da casa j√° constru√≠da, verificando se tudo est√° de acordo com o projeto e se n√£o h√° nenhum problema. Essa √© a ess√™ncia do QC, um processo reativo que se concentra em detectar e corrigir defeitos no software ap√≥s ele ter sido desenvolvido.

O QC atua como um detetive, buscando por bugs e falhas que podem comprometer a qualidade do software. Ele se concentra em:

- Executar testes: Realizar diferentes tipos de testes, como testes funcionais, de performance, de seguran√ßa e de usabilidade, para identificar defeitos no software.
- Reportar bugs: Documentar e reportar os bugs encontrados para a equipe de desenvolvimento, fornecendo informa√ß√µes detalhadas para que eles possam ser corrigidos.
- Verificar as corre√ß√µes: Ap√≥s a corre√ß√£o dos bugs, o QC realiza novos testes para garantir que os problemas foram resolvidos e que n√£o foram introduzidos novos bugs.
- Monitorar a qualidade do software: Acompanhar o desempenho do software em produ√ß√£o, coletando dados e feedback dos usu√°rios para identificar e corrigir problemas.

<img src="https://github.com/user-attachments/assets/7f699e28-254b-4bdd-9028-c2c2b7b75ac0" align="right" height="377">

QA e QC: Um Time Imbat√≠vel. QA e QC s√£o como duas faces da mesma moeda, trabalhando em conjunto para garantir a qualidade do software. Enquanto o QA se concentra na preven√ß√£o de defeitos, o QC se concentra na detec√ß√£o e corre√ß√£o dos problemas. A sinergia entre esses dois processos √© essencial para construir um software robusto, confi√°vel e que atenda √†s expectativas dos usu√°rios.

Compreender a diferen√ßa entre QA e QC √© fundamental para construir uma estrat√©gia de qualidade de software eficaz. Ao integrar as pr√°ticas de QA e QC em todo o ciclo de desenvolvimento, as empresas podem garantir que seus softwares sejam desenvolvidos com qualidade, efici√™ncia e seguran√ßa, satisfazendo os usu√°rios e impulsionando o sucesso do neg√≥cio.

E dentro da distin√ß√£o cl√°ssica entre *QA (Quality Assurance)* e *QC (Quality Control)*, os **testes de software** se enquadram como atividades de QC, porque est√£o no n√≠vel da inspe√ß√£o e verifica√ß√£o do produto final. 

QA olha mais para os processos, prevenindo defeitos ao longo do ciclo (defini√ß√£o de padr√µes, auditorias de qualidade, pr√°ticas de engenharia), enquanto QC foca em detectar e validar defeitos no resultado tang√≠vel ‚Äî o software em execu√ß√£o, as integra√ß√µes funcionando, os requisitos sendo cumpridos.

Portanto, sim: quando falamos em **testes manuais, automatizados, de integra√ß√£o, de aceita√ß√£o, de regress√£o, de performance, etc.**, estamos atuando dentro da **camada de QC**. Eles s√£o o mecanismo pelo qual conseguimos transformar ‚Äúexpectativas de qualidade‚Äù em **evid√™ncias objetivas** de que o software funciona (ou n√£o) como esperado.

<img src="https://github.com/user-attachments/assets/bcc83195-9916-4d3a-8fe9-22a87ccf18f8" align="right" height="177">

> [!Important]
> Vantagens dos testes de software: Se voc√™ quer evoluir em testes de software e entender como integrar qualidade de forma colaborativa e cont√≠nua em equipes √°geis, o livro **"Agile Testing: A Practical Guide for Testers and Agile Teams"**, escrito por Lisa Crispin e Janet Gregory, √© uma leitura essencial para transformar a teoria em pr√°tica.
> 
> - Qualidade
> - Suporte ao time
> - Feedback constante
> - Produtividade
> - Documenta√ß√£o viva
> - Alinhamento com o neg√≥cio
> - Dissemina√ß√£o de conhecimento
> - Preven√ß√£o de bugs: Evitar a continua√ß√£o dos bugs
> - Redu√ß√£o de Custos

A defini√ß√£o de ‚Äúpronto‚Äù nada mais √© do que um contrato firmado entre o time e o PO, que lista de forma clara os requisitos que determinam que uma User Story est√° completa.

> E a resposta √© simples: normalmente, quando perguntam se uma funcionalidade ou story est√° pronta, respondem: ‚Äúsim, mas falta testar‚Ä¶‚Äù.

Isso significa que ao definir o conceito de ‚Äúpronto‚Äù, √© importante que o QA ‚Äì que faz parte do time ‚Äì esteja envolvido e possa sensibilizar os membros do time e PO para que os testes fa√ßam parte deste conceito.

Dessa forma, garantimos:

- Integra√ß√£o entre desenvolvedores e QA;
- Maior qualidade do time;
- Que n√£o haja desentendimentos desnecess√°rios;
- Story testada e com aceite formal.¬†

As atividades de apoio da qualidade de software, como revis√µes, auditorias e inspe√ß√µes, s√£o essenciais para garantir que o software seja produzido de acordo com os padr√µes de qualidade estabelecidos. Essas atividades podem ser realizadas em diferentes momentos do ciclo de vida do software, desde a an√°lise de requisitos at√© a manuten√ß√£o.
 
As **revis√µes** s√£o uma das atividades de apoio mais comuns e envolvem a an√°lise do software por um grupo de pessoas para detectar erros e poss√≠veis me
lhorias. Existem diferentes tipos de revis√µes, como revis√µes de c√≥digo (Code Reviews), revis√µes de documentos e revis√µes de design.
 
As **auditorias** s√£o semelhantes √†s revis√µes, mas geralmente s√£o realizadas por equipes independentes de pessoas com habilidades espec√≠ficas para avaliar o software em rela√ß√£o a padr√µes e regulamenta√ß√µes espec√≠ficos. As auditorias podem ser internas ou externas e podem ser realizadas em diferentes fases do ciclo de vida do software (BRITO, 2006).

J√° as **inspe√ß√µes** s√£o atividades mais formais e estruturadas, que seguem um processo espec√≠fico para avaliar o software em rela√ß√£o a determinados padr√µes e especifica√ß√µes. As inspe√ß√µes geralmente envolvem uma equipe multidisciplinar e podem ser realizadas em diferentes fases do ciclo de vida do software.

Essas atividades de apoio da qualidade de software s√£o importantes porque ajudam a identificar problemas no software antes que ele seja lan√ßado, reduzindo assim os custos e os riscos associados a falhas no software. Al√©m disso, elas tamb√©m podem ajudar a melhorar a efici√™ncia e a efic√°cia do processo de desenvolvimento de software (SHAMA, 2016).

Para aprofundar seu conhecimento sobre atividades de apoio da qualidade de software, voc√™ pode se perguntar: 

‚ñ† Quais s√£o as diferen√ßas entre as atividades de revis√£o, auditoria e inspe√ß√£o? 

‚ñ† Como as atividades de apoio podem ser integradas ao processo de desenvolvimento de software? 

‚ñ† Qual √© o papel dos diferentes membros da equipe na execu√ß√£o dessas atividades?

Al√©m disso, uma ilustra√ß√£o √∫til pode ser um diagrama que mostre a rela√ß√£o entre as atividades de apoio da qualidade de software e outras atividades do ciclo de vida do software, como desenvolvimento, teste e implanta√ß√£o. Isso pode ajudar a entender como as atividades de apoio se encaixam no processo geral de desenvolvimento de software e como elas podem contribuir para a melhoria da qualidade do produto final.

<div align="center"><img width="551" height="351" alt="image" src="https://github.com/user-attachments/assets/d9decc9c-a526-4733-bf66-c5cd63aaba1e" /></div>

<a href="https://github.com/IsaacAlves7/observability"><img src="https://em-content.zobj.net/source/microsoft-teams/400/magnifying-glass-tilted-left_1f50d.png" align="right" height="77"></a>

√â importante destacar que a **observabilidade** (observability) n√£o √© exatamente parte do QA no sentido tradicional, mas ela se conecta de forma muito natural com a qualidade do software. QA (Quality Assurance) historicamente √© voltado para preven√ß√£o de defeitos, valida√ß√£o e verifica√ß√£o de requisitos, testes funcionais, n√£o funcionais e processos que garantem que o produto atenda ao que foi especificado. Observabilidade, por outro lado, nasceu com foco na opera√ß√£o e na confiabilidade: √© a capacidade de entender o que est√° acontecendo em um sistema, em tempo real, a partir de sinais como logs, m√©tricas e traces. Ela vai al√©m de simplesmente monitorar: √© sobre ser capaz de responder perguntas desconhecidas sobre o comportamento do sistema.

A rela√ß√£o entre as duas √°reas est√° no fato de que quanto mais observ√°vel um sistema √©, mais f√°cil fica detectar, diagnosticar e corrigir problemas que impactam a qualidade. QA tradicional muitas vezes termina antes da aplica√ß√£o ir para produ√ß√£o, mas bugs e falhas ainda podem aparecer em ambientes reais. Com observabilidade, voc√™ complementa os testes com uma vis√£o cont√≠nua, onde √© poss√≠vel acompanhar a sa√∫de, a performance, os gargalos e at√© o comportamento do usu√°rio. Para equipes modernas, especialmente em DevOps e SRE, a linha entre QA e observabilidade se mistura um pouco, pois qualidade n√£o √© mais s√≥ ‚Äútestar antes de subir‚Äù, mas tamb√©m garantir que o produto em execu√ß√£o esteja saud√°vel, rastre√°vel e confi√°vel.

Portanto, observabilidade pode ser vista como complementar ao QA, n√£o substitui testes e processos de qualidade, mas amplia a seguran√ßa e o controle. Muitas equipes de alto desempenho hoje tratam a observabilidade como parte essencial da estrat√©gia de qualidade, especialmente quando o sistema √© distribu√≠do, usa microsservi√ßos, filas, integra√ß√µes externas ou precisa de alta disponibilidade.

## [QA] Custos x Fases
<img width="524" height="241" align="right" src="https://github.com/user-attachments/assets/a3aaded7-0fad-4ba5-9b0a-9d664bf0dc8e" />

Voc√™ sabia que a qualidade de um software pode impactar diretamente nos custos de uma empresa? Os **Custos de controle** em qualidade de software se referem aos gastos necess√°rios para prevenir defeitos e garantir a qualidade dos produtos de software, bem como para corrigir quaisquer defeitos encontrados durante as fases de desenvolvimento 
e teste. 

Esses custos podem incluir investimentos em treinamento, ferramentas de teste, testes manuais e automatizados, revis√µes de c√≥digo e outras atividades de garantia de qualidade. 

Ao investir em custos de controle, as organiza√ß√µes podem reduzir o n√∫mero de defeitos encontrados nos produtos de software (custos de preven√ß√£o) e, consequentemente, minimizar os custos associados a falhas de software, como retrabalho, atrasos no cronograma, perda de receita e reputa√ß√£o negativa (custos de avalia√ß√£o).
 
As falhas internas s√£o aquelas que acontecem dentro da empresa, antes do produto final ser entregue ao cliente. Elas podem ser causadas por diversos motivos, como falta de capacita√ß√£o da equipe, problemas de comunica√ß√£o, dentre outros. Essas falhas podem levar a retrabalho, atrasos na entrega e insatisfa√ß√£o do cliente.

J√° as **falhas externas** s√£o aquelas que ocorrem ap√≥s a entrega do produto final ao cliente. Elas podem ser causadas por problemas na codifica√ß√£o, falhas de seguran√ßa, dentre outros fatores. Essas falhas podem gerar custos alt√≠ssimos para a empresa, como a necessidade de retrabalho, de suporte t√©cnico, de processos judiciais e at√© mesmo a perda de clientes

> [!Warning]
> Para aprofundar seu conhecimento sobre os custos de qualidade de software, voc√™ pode se perguntar: quais s√£o as principais causas de falhas internas e externas? Como a qualidade do software pode influenciar nos custos da empresa? Como √© poss√≠vel reduzir esses custos e melhorar a qualidade do produto final?

<img height="177" align="right" src="https://github.com/user-attachments/assets/4d60adb8-9629-4605-ae7f-8b97798f7699" />

A **Regra 10 de Myers**, criada em 2004 por Glenford Myers, √© uma importante diretriz para os analistas de teste de software. Essa regra afirma que toda falha no software deve ser rastre√°vel a uma a√ß√£o ou decis√£o espec√≠fica tomada durante o desenvolvimento do software.

> A ilustra√ß√£o mostra um gr√°fico que representa os custos de corre√ß√£o associados a cada est√°gio do ciclo de desenvolvimento de software. No lado esquerdo, h√° uma linha vertical que corresponde ao eixo Y, onde est√° inscrito "Custo da corre√ß√£o do defeito". Na parte inferior, h√° uma linha horizontal que se junta √† linha vertical, formando uma grade para marcar os est√°gios do ciclo no eixo X. Abaixo dessa linha vertical est√° escrito da esquerda para a direita: An√°lise, Especifica√ß√£o, Constru√ß√£o, Testes e Produ√ß√£o. No interior do gr√°fico h√° uma linha vermelha com cinco c√≠rculos amarelos.

Em outras palavras, a Regra 10 de Myers enfatiza  que o custo da corre√ß√£o de defeitos √© bem mais custoso quanto mais tarde o defeito √© encontrado, ou seja, um defeito encontrado em produ√ß√£o custa muito mais do que se fosse encontrado na fase de an√°lise ou em modelos de dados.

Uma boa gest√£o de qualidade pode ser a chave para minimizar os custos relacionados √†s falhas em software. Investir em capacita√ß√£o da equipe, em boas pr√°ticas de desenvolvimento e em testes constantes pode ajudar a evitar falhas internas e externas e, consequentemente, reduzir os custos para a empresa.

O **Shift Left Testing** √© um conceito dentro da engenharia de software e de testes que significa **trazer as atividades de teste para mais cedo no ciclo de desenvolvimento**. Tradicionalmente, em modelos como o *waterfall*, os testes s√≥ aconteciam no fim, depois que o c√≥digo j√° estava implementado. Isso levava a atrasos, altos custos de corre√ß√£o e ac√∫mulo de defeitos. O movimento de ‚Äúshift left‚Äù (deslocar para a esquerda, no cronograma) √© justamente antecipar a valida√ß√£o de qualidade para as fases iniciais ‚Äî an√°lise de requisitos, design e at√© antes de escrever c√≥digo ‚Äî com o objetivo de encontrar problemas cedo, quando ainda s√£o baratos de corrigir.

E isso se conecta com a famosa Regra de 10 de Myers (ou Myers‚Äô Rule of Ten). A regra, proposta por Glenford Myers, diz que:

> ‚ÄúO custo para corrigir um defeito aumenta em uma ordem de grandeza (10x) a cada fase posterior do ciclo de desenvolvimento em que ele √© encontrado.‚Äù

Na pr√°tica, **shift left** se traduz em v√°rias pr√°ticas modernas. Envolve escrever crit√©rios de aceita√ß√£o e testes antes da implementa√ß√£o (TDD, ATDD, BDD), fazer testes unit√°rios e de integra√ß√£o cont√≠nuos, usar pipelines de CI/CD para rodar automaticamente baterias de testes a cada commit, e at√© aplicar ferramentas de an√°lise est√°tica e valida√ß√µes de seguran√ßa durante o desenvolvimento. Tamb√©m pode incluir colabora√ß√£o mais pr√≥xima entre desenvolvedores, QAs e analistas de neg√≥cio logo no in√≠cio, evitando que requisitos mal entendidos s√≥ sejam percebidos no final.

O grande benef√≠cio √© que, quanto mais cedo um bug √© descoberto, menor o impacto t√©cnico e financeiro para o projeto. Por isso, ‚Äúshift left testing‚Äù n√£o significa apenas testar antes, mas criar uma cultura de **qualidade incorporada desde o in√≠cio**, em vez de tratada como etapa final. √â um complemento direto de metodologias √°geis e DevOps, porque apoia ciclos r√°pidos, entregas frequentes e feedback constante.

<img align="right" height="177" alt="image" src="https://github.com/user-attachments/assets/b99bfaa0-07bf-4497-b544-d45d91f1fe50" />

> [!Important]
> **Qualidade De Software Na Pr√°tica - Como Reduzir O Custo De Manuten√ß√£o**: Para aprofundar seus conhecimentos sobre avalia√ß√£o de atributos de qualidade, recomendamos a leitura do livro Qualidade De Software Na Pr√°tica - Como Reduzir O Custo De Manuten√ß√£o √© um livro escrito por Alexandre Kherroubi e Adalberto Cavalcanti. O livro aborda a import√¢ncia da qualidade de software na redu√ß√£o dos custos de manuten√ß√£o e explora estrat√©gias pr√°ticas para melhorar a qualidade do software, resultando em um impacto positivo nos custos de manuten√ß√£o ao longo do ciclo de vida do software.

## [QA] Padr√µes de Qualidade de Software
<img height="177" align="right" src="https://github.com/user-attachments/assets/23634a8a-fa08-411f-b723-7115f8b03f9b" />

Os **padr√µes de qualidade de software** s√£o conjuntos de pr√°ticas, regras e diretrizes que visam garantir a qualidade do software produzido. Eles s√£o uma refer√™ncia para desenvolvedores e equipes de qualidade, ajudando a garantir que o software produzido seja confi√°vel, seguro e atenda aos requisitos do usu√°rio.

Os padr√µes de qualidade de software podem ser baseados em normas internacionais , como a ISO/IEC 12207 e a ISO/IEC 9126, ou podem ser espec√≠ficos para uma ind√∫stria ou empresa. Eles podem cobrir todos os aspectos do ciclo de vida do software, desde a especifica√ß√£o de requisitos at√© a manuten√ß√£o e evolu√ß√£o do software.

Os padr√µes de qualidade de software podem ser baseados em normas internacionais.

> VOC√ä SABE RESPONDER? Como os padr√µes de qualidade de software podem ajudar a melhorar a confiabilidade e seguran√ßa do software?

Um dos principais benef√≠cios dos padr√µes de qualidade de software √© que eles fornecem uma base s√≥lida para a avalia√ß√£o da qualidade do software (GALINAC, 2013). Os padr√µes de qualidade de software, como o **CMM (Capability Maturity Model)** e o **MPS-BR  (Melhoria de Processo do Software Brasileiro)**, foram desenvolvidos para melhorar a qualidade dos processos e produtos de software.

O CMM foi criado pelo SEI (Software Engineering Institute) nos anos 1990, com o objetivo de estabelecer um modelo de maturidade para avaliar a capacidade dos processos de software em uma organiza√ß√£o (CMMI-DEV V2.0, 2018). 

O modelo √© baseado em cinco n√≠veis, que representam um aumento gradual da maturidade do processo, desde o n√≠vel 1, que √© o mais baixo, at√© o n√≠vel 5, que √© o mais alto. Cada n√≠vel tem seus pr√≥prios objetivos, pr√°ticas e √°reas de processo. 

O CMM √© amplamente utilizado para avaliar a maturidade dos processos de software em organiza√ß√µes governamentais e privadas em todo o mundo.

## [QA] Self testing
![Jest](https://img.shields.io/badge/-Jest-EF2D5E?style=badge&logo=jest&logoColor=white)
![Mocha](https://img.shields.io/badge/-Mocha-EF2D5E?style=badge&logo=mocha&logoColor=white)
![JUnit5](https://img.shields.io/badge/-JUnit5-EF2D5E?style=badge&logo=JUnit5&logoColor=white) 
![xUnit](https://img.shields.io/badge/-xUnit-EF2D5E?style=badge&logo=.NET&logoColor=white) 
![Cucumber](https://img.shields.io/badge/-Cucumber-23D96C?style=badge&logo=cucumber&logoColor=white)
![Selenium](https://img.shields.io/badge/-Selenium-limegreen?style=badge&logo=Selenium&logoColor=white)
![Appium](https://img.shields.io/badge/-Appium-EE376D?style=badge&logo=Appium&logoColor=white)
![Apache JMeter](https://img.shields.io/badge/-Apache_JMeter-D22128?style=badge&logo=apachejmeter&logoColor=white)
![Cypress](https://img.shields.io/badge/-Cypress-505050?style=badge&logo=cypress&logoColor=white)
![Robot Framework](https://img.shields.io/badge/-Robot_Framework-000000?style=badge&logo=robotframework&logoColor=white)

<a href="https://martinfowler.com/articles/practical-test-pyramid.html"><img src="https://www.pcloudy.com/wp-content/uploads/2019/07/functional-testing.png" align="right" height="277"></a>

O conceito de **self-testing** em software vem da ideia de que o pr√≥prio sistema deve ter meios embutidos para validar se est√° funcionando corretamente, sem depender de verifica√ß√µes externas e ocasionais. Em ess√™ncia, √© a no√ß√£o de que a aplica√ß√£o deve trazer consigo a capacidade de se ‚Äúautoavaliar‚Äù. 

Isso pode se manifestar de formas diferentes dependendo do contexto: em n√≠vel de c√≥digo, por meio de uma su√≠te de testes automatizados que √© executada sempre que o sistema √© constru√≠do ou implantado; em n√≠vel operacional, com health checks, m√©tricas, logs e alertas que confirmam se o servi√ßo est√° √≠ntegro; ou ainda em processos de QA, onde o produto √© constantemente validado contra crit√©rios de aceita√ß√£o definidos.

Dentro desse conceito, **testes automatizados** s√£o o n√∫cleo natural do self-testing, porque permitem verificar de forma cont√≠nua e repet√≠vel se o c√≥digo ainda atende √†s especifica√ß√µes √† medida que evolui. √â nesse ponto que pr√°ticas como **TDD** se encaixam perfeitamente: ao escrever primeiro o teste e depois o c√≥digo, o desenvolvedor garante que cada parte do sistema j√° nasce coberta por verifica√ß√µes, criando um software que j√° vem com seus pr√≥prios ‚Äúexames de sa√∫de‚Äù. Al√©m disso, TDD gera uma rede de seguran√ßa de regress√£o, que torna o sistema mais resistente a falhas ao longo do tempo.

> "Descobrir o inesperado √© mais importante do que confirmar o conhecido." - George E.P.Box

J√° os **testes manuais** tamb√©m podem existir em um cen√°rio de self-testing, mas n√£o cumprem totalmente a proposta. Eles servem bem em situa√ß√µes explorat√≥rias, de usabilidade ou de descoberta de casos n√£o previstos, mas n√£o garantem a automa√ß√£o e a repetibilidade que o conceito prega. Em outras palavras, um sistema pode at√© contar com testes manuais complementares, mas n√£o se considera realmente ‚Äúself-testing‚Äù se depende s√≥ deles, porque n√£o h√° como o software se validar sozinho sem a interven√ß√£o humana.

Portanto, podemos dizer que o self-testing **aceita testes manuais como complemento**, mas a ess√™ncia dele est√° nos **testes automatizados**, preferencialmente guiados por boas pr√°ticas como TDD ou ATDD, que d√£o disciplina e cobertura consistente ao ciclo de desenvolvimento.

Estudamos os branches, os workflows e conclu√≠mos que dentro da pr√°tica da integra√ß√£o cont√≠nua, devemos nos afastar o m√≠nimo poss√≠vel do nosso trunk master principal.

Com as altera√ß√µes que realizamos o tempo todo em nosso software, como podemos garantir a qualidade do c√≥digo? Testes. No caso da integra√ß√£o cont√≠nua, precisaremos utilizar testes automatizados. O ideal √© que a cada altera√ß√£o, seja realizado um novo teste automatizado, para termos certeza de nenhum problema ser√° gerado.

Para isso, algumas regras e padr√µes s√£o necess√°rios para manter o fluxo saud√°vel e o caminho feliz em todas as fases:

<img height="177" align="right" src="https://github.com/user-attachments/assets/2428e394-db35-454e-bdc5-add66d850f53" />

O **Build** vem antes da etapa de teste/QA. Pensa assim: o build √© o processo de pegar o c√≥digo-fonte (em .NET, Java, etc.) e transform√°-lo em um artefato execut√°vel ou implant√°vel (um `.dll`, `.exe`, `.jar`, container Docker, pacote NuGet, etc.). S√≥ depois que esse artefato √© gerado √© que voc√™ consegue rodar os testes de verdade, seja unit√°rio, de integra√ß√£o, ou QA manual/automatizado.

> A quest√£o √© n√£o √© que "sem teste, n√£o tem build", mas sim **"do que adianta build sem teste?"**. 

Tecnicamente, d√° pra fazer build sem teste, mas a√≠ a pergunta √© exatamente essa: ‚Äúde que adianta gerar um bin√°rio, se eu n√£o sei se ele funciona?‚Äù. √â como fabricar um carro e n√£o ligar o motor pra ver se anda. O artefato at√© existe, mas n√£o tem valor de verdade, porque ningu√©m pode confiar nele. 

√â por isso que, na pr√°tica, no ciclo de engenharia de software moderno, teste e build se fundem. O pipeline s√≥ chama aquilo de ‚Äúbuild v√°lido‚Äù se os testes passaram. Tanto que em muitas empresas voc√™ v√™ at√© a nomenclatura ‚ÄúBuild & Test‚Äù como uma √∫nica fase.

A sequ√™ncia cl√°ssica em pipelines CI/CD √© mais ou menos assim:

1. **Code** ‚Üí desenvolvedor escreve o c√≥digo.
2. **Build** ‚Üí o c√≥digo √© compilado e empacotado.
3. **Test/QA** ‚Üí o artefato gerado √© validado (testes automatizados, est√°ticos, integra√ß√£o, QA manual).
4. **Release/Deploy** ‚Üí se passou em QA, o build √© promovido para homologa√ß√£o ou produ√ß√£o.

Claro que existem nuances: testes unit√°rios √†s vezes rodam j√° na fase de build (porque s√£o r√°pidos e podem rodar junto da compila√ß√£o), mas testes de QA completos (funcionais, integra√ß√£o, performance) dependem do build estar pronto. Ent√£o, em termos de pipeline: `Build ‚Üí Test/QA ‚Üí Deploy`.

Mas existem dois cen√°rios, a√≠ entra uma confus√£o comum, e √© legal esclarecer. O **build** em si ‚Äî no sentido t√©cnico de compilar e gerar um artefato execut√°vel ‚Äî **n√£o depende de teste nenhum**. Voc√™ pode rodar `dotnet build`, `mvn package` ou `npm run build` mesmo sem nenhum teste, e o c√≥digo vai gerar bin√°rio, JAR ou bundle normalmente.

O que acontece √© que em **pipelines modernos de CI/CD** (Azure DevOps, GitHub Actions, GitLab CI, Jenkins etc.), muita gente coloca testes logo ap√≥s ou at√© durante o build. Isso d√° a impress√£o de que ‚Äúsem teste o build n√£o roda‚Äù, mas na pr√°tica √© s√≥ uma regra do pipeline que impede a entrega se os testes falharem.

Ou seja:

* **Build cru** = compila e empacota. Independe de teste.
* **Build no pipeline CI** = compila, empacota e executa testes obrigat√≥rios (unit√°rios, integra√ß√£o r√°pida). Se algum falhar, o pipeline cancela e o build n√£o √© promovido para as pr√≥ximas fases (QA, deploy).

Ent√£o, tecnicamente: o **build vem antes do teste**, mas no mundo real de pipelines, eles caminham juntos, porque √© mais eficiente falhar cedo se os testes n√£o passarem.

<img height="177" align="right" src="https://github.com/user-attachments/assets/b22f3aba-0a19-43b7-9da4-fdca9afa4231" />

- **Testes fazem parte da constru√ß√£o do software**: Num fluxo de desenvolvimento saud√°vel, os testes n√£o s√£o ‚Äúum passo depois que o c√≥digo j√° est√° pronto‚Äù, mas um componente do pr√≥prio processo de cria√ß√£o. A ideia do TDD (Test-Driven Development), por exemplo, √© justamente colocar o teste como motor do design do c√≥digo. E mesmo fora do TDD, testes unit√°rios, est√°ticos e at√© linters fazem parte do que chamamos de build saud√°vel. √â por isso que pipelines modernos acoplam testes ao build: sem eles, o artefato at√© compila, mas n√£o √© considerado ‚Äúconstru√≠do de verdade‚Äù.;

- **Devem ser realizados antes do commit**: Aqui voc√™ est√° descrevendo o que chamamos de pr√©-valida√ß√£o local. O ideal √© que o desenvolvedor rode testes (unit√°rios pelo menos) antes de commitar, garantindo que n√£o quebrou nada b√°sico. Isso pode ser cultural (boa pr√°tica individual) ou t√©cnico (com pre-commit hooks no Git, que bloqueiam commit se os testes falharem). Dessa forma, o c√≥digo que chega ao reposit√≥rio central j√° tem uma garantia m√≠nima.;

- TDD pode ajudar neste processo;

- Desempenho bom em testes;

- Os testes demorados podem ser uma barreira para a integra√ß√£o cont√≠nua, por isso precisamos ficar atentos.

## [QA] Automation testing
![Jest](https://img.shields.io/badge/-Jest-EF2D5E?style=badge&logo=jest&logoColor=white)
![Mocha](https://img.shields.io/badge/-Mocha-EF2D5E?style=badge&logo=mocha&logoColor=white)
![JUnit5](https://img.shields.io/badge/-JUnit5-EF2D5E?style=badge&logo=JUnit5&logoColor=white) 
![xUnit](https://img.shields.io/badge/-xUnit-EF2D5E?style=badge&logo=.NET&logoColor=white) 
![Cucumber](https://img.shields.io/badge/-Cucumber-23D96C?style=badge&logo=cucumber&logoColor=white)
![Selenium](https://img.shields.io/badge/-Selenium-limegreen?style=badge&logo=Selenium&logoColor=white)
![Appium](https://img.shields.io/badge/-Appium-EE376D?style=badge&logo=Appium&logoColor=white)
![Apache JMeter](https://img.shields.io/badge/-Apache_JMeter-D22128?style=badge&logo=apachejmeter&logoColor=white)
![Cypress](https://img.shields.io/badge/-Cypress-505050?style=badge&logo=cypress&logoColor=white)
![Robot Framework](https://img.shields.io/badge/-Robot_Framework-000000?style=badge&logo=robotframework&logoColor=white)

<img src="https://github.com/IsaacAlves7/DevSecOps/assets/61624336/7ae43145-a45f-49a5-98ae-693912faae5d" align="right" height="77">

Uma vez que o c√≥digo √© integrado, a pr√≥xima etapa √© o **teste automatizado** (automation testing) que envolve a execu√ß√£o de um conjunto de testes para garantir que as altera√ß√µes de c√≥digo sejam funcionais, atendam aos padr√µes de qualidade esperados e estejam livres de defeitos. Essa etapa ajuda a identificar problemas no in√≠cio do processo de desenvolvimento, permitindo que os desenvolvedores os corrijam de maneira r√°pida e eficiente.

Conforme o tempo passa a tecnologia segue avan√ßando e os sistemas que s√£o desenvolvidos por pessoas da √°rea de TI est√£o cada vez mais completos. Antigamente os testes manuais eram os mais utilizados, mas eles j√° n√£o suprem mais √†s demandas das empresas e acabam sendo suscet√≠veis a erros. Ent√£o, as organiza√ß√µes precisam desenvolver mais e com melhor qualidade, √© a√≠ que entram os *testes automatizados* que s√£o programas que executam testes em softwares que est√£o em constru√ß√£o de uma forma padronizada, sem ser necess√°rio a interven√ß√£o humana.

Pois, tais testes possuem funcionalidades capazes de testar de forma autom√°tica todos os aspectos de uma plataforma, com o intuito de assegurar um desempenho adequado. Ou seja, a automa√ß√£o de teste √© o uso de software para controlar a execu√ß√£o do teste de software, a compara√ß√£o dos resultados esperados com os resultados reais, a configura√ß√£o das pr√©-condi√ß√µes de teste e outras fun√ß√µes de controle e relat√≥rio de teste. 

Tal procedimento, gera muito mais efic√°cia e agilidade na etapa de testes, permitindo que o profissional encontre de uma maneira mais f√°cil as falhas de seguran√ßa, bugs e demais erros que possam comprometer o uso da aplica√ß√£o.

> Quando o profissional notar que est√° gastando muito tempo com tarefas repetitivas e quando o software est√° muito grande, pode ser a hora de automatizar. Mas, √© necess√°rio tamb√©m questionar a viabilidade dessa a√ß√£o, sendo essencial analisar se com a automa√ß√£o a equipe ir√° obter ganho de tempo e se conseguir√£o reduzir custos e manter a qualidade.

Testes automatizados s√£o uma das pr√°ticas mais fundamentais no desenvolvimento de software moderno, pois garantem confiabilidade, reduzem bugs em produ√ß√£o, facilitam refatora√ß√µes e melhoram a documenta√ß√£o viva do sistema. Para construir testes automatizados realmente bons, √© preciso compreender n√£o s√≥ as ferramentas, mas tamb√©m o processo como um todo ‚Äî desde a fase de planejamento at√© a execu√ß√£o cont√≠nua. Tudo come√ßa pela compreens√£o dos **n√≠veis de teste**: 

<img src="https://user-images.githubusercontent.com/61624336/128188070-c1fff724-f895-4501-bdca-dbab78dca6b1.png" height="277" align="right"> 

1. **Testes de unidade** (isolam pequenas partes do c√≥digo),

2. **Testes de integra√ß√£o** (verificam a comunica√ß√£o entre partes),

3. **Testes funcionais**

4. **Testes de sistema** (validam o sistema como um todo)

5. **Testes end-to-end** (simulam o comportamento real do usu√°rio).

Cada n√≠vel exige aten√ß√£o diferente e ferramentas espec√≠ficas:

No in√≠cio do ciclo, o **desenho dos testes** precisa ser baseado em crit√©rios claros de cobertura: o que est√° sendo testado, por que est√° sendo testado e o que n√£o precisa ser testado. Bons testes n√£o s√£o s√≥ aqueles que passam, mas aqueles que falham quando o comportamento do c√≥digo foge do esperado. Para isso, as asser√ß√µes precisam ser claras, espec√≠ficas e rastre√°veis. Boas pr√°ticas incluem escrever testes que sejam r√°pidos, isolados, determin√≠sticos e leg√≠veis. Um teste bom √© aquele que algu√©m consegue entender o que ele verifica s√≥ de ler o seu nome e o corpo, sem necessidade de ir at√© a implementa√ß√£o testada.

A fase de ferramentas √© t√£o importante quanto o planejamento. Para testes de unidade, temos ferramentas como **JUnit** (Java), **xUnit** (C#), **pytest** (Python), **Jest** e **Vitest** (JavaScript/TypeScript), **Elixir ExUnit**, entre outras. Para mocks e test doubles, usamos bibliotecas como **Moq**, **Sinon**, **Mockito** ou **NSubstitute**, que ajudam a isolar depend√™ncias externas, como chamadas a APIs, bancos de dados e arquivos. Em testes de integra√ß√£o, frameworks como **TestContainers**, **WireMock** ou bancos de dados em mem√≥ria ajudam a montar ambientes realistas. Para testes de aceita√ß√£o e end-to-end, ferramentas como **Cypress**, **Playwright**, **Selenium** e **Puppeteer** s√£o as mais utilizadas, permitindo testes que interagem com o navegador ou sistema completo, validando fluxos reais.

<img src="https://github.com/IsaacAlves7/DevSecOps/assets/61624336/52a5bb6f-070c-4635-8de1-43db6d07500d" height="377" align="right"> 

Na constru√ß√£o de um bom teste automatizado, o primeiro passo √© **nomear corretamente o que est√° sendo testado**, depois criar um ambiente previs√≠vel para que os testes n√£o tenham falsos positivos ou negativos. Um teste que falha √†s vezes √© um teste ruim. Depois, **seguir o padr√£o AAA** (Arrange, Act, Assert) √© uma boa pr√°tica: configurar os dados e depend√™ncias, executar o comportamento que est√° sendo testado, e por fim verificar o resultado. Tamb√©m √© essencial n√£o testar l√≥gica interna demais (isso gera testes fr√°geis), mas focar no comportamento observ√°vel da fun√ß√£o ou componente.

Outro pilar crucial √© a **integra√ß√£o com pipelines de CI/CD**. Automatizar os testes via GitHub Actions, GitLab CI, Jenkins ou Azure DevOps garante que os testes rodam a cada push ou PR, evitando regress√µes. Um teste que s√≥ roda localmente √© praticamente in√∫til em um time com m√∫ltiplos desenvolvedores.

Al√©m disso, n√£o se deve esquecer do **relato dos testes**. Ferramentas de coverage (cobertura de c√≥digo) como **Istanbul**, **Coverlet** ou **Codecov** ajudam a visualizar o quanto do c√≥digo est√° sendo testado, embora **cobertura alta n√£o signifique qualidade alta** ‚Äî √© poss√≠vel ter 100% de cobertura e testes in√∫teis. O ideal √© buscar cobertura √∫til, ou seja, testes que validam fluxos importantes, limites, erros e casos reais de uso.

Por fim, construir um teste automatizado bom exige pr√°tica, disciplina e conhecimento. N√£o √© s√≥ sobre ferramentas, mas sobre escrever c√≥digo de teste que seja confi√°vel, f√°cil de manter e que reflita as regras de neg√≥cio do sistema. √â preciso ter clareza sobre o que vale a pena testar, manter a su√≠te de testes r√°pida e identificar o ponto de equil√≠brio entre cobertura e custo de manuten√ß√£o. Testes automatizados s√£o investimento ‚Äî e como todo investimento, precisam de foco, consist√™ncia e revis√£o cont√≠nua para darem retorno real.

O desenvolvimento, inspe√ß√£o e o teste de unidade s√£o as tr√™s partes do teste de c√≥digos. Numa era onde tudo √© automatizado, testadores de software tem demandado cada vez mais ferramentas de automa√ß√£o de testes. Veja algumas ferramentas para automa√ß√£o de testes:

<img src="https://github.com/user-attachments/assets/3c87b05b-6715-4178-8166-9bf528c4e3ff" height="77" align="right"> 

1. **Selenium**: √© um framework port√°til para testar aplicativos web. O Selenium fornece uma ferramenta de reprodu√ß√£o para a cria√ß√£o de testes funcionais sem a necessidade de aprender uma linguagem de script de teste. √â provavelmente a ferramenta de automa√ß√£o de testes mais conhecida e utilizada no mundo, especialmente quando o foco s√£o aplica√ß√µes web. Diferente de solu√ß√µes comerciais como Ranorex, UFT ou TestComplete, ele √© open source, o que significa que n√£o h√° custo de licen√ßa e ele pode ser adaptado de acordo com as necessidades do time. Esse fator, aliado √† sua flexibilidade, fez do Selenium uma esp√©cie de padr√£o de fato em automa√ß√£o de testes web, sendo adotado desde startups at√© grandes corpora√ß√µes.

2. **Robot Framework**: √© uma estrutura gen√©rica de automa√ß√£o de teste para testes de aceita√ß√£o e desenvolvimento orientado a testes de aceita√ß√£o. √â uma estrutura de teste orientada por palavras-chave que usa a sintaxe de dados de teste tabular. 

3. **Robotium**: √© um framework open source de automa√ß√£o de testes voltado especificamente para aplica√ß√µes Android. Ele surgiu como uma resposta √† necessidade de se criar testes funcionais e de interface de forma mais pr√°tica e menos trabalhosa do que o que era oferecido nativamente pela API de testes do Android. Diferente de solu√ß√µes que focam em testes unit√°rios ou apenas em pequenas partes da aplica√ß√£o, o Robotium foi desenhado para permitir que voc√™ crie testes que simulam a intera√ß√£o real de um usu√°rio com o aplicativo, clicando em bot√µes, digitando em campos, navegando por telas e validando os resultados exibidos. Ele funciona essencialmente como uma camada que se apoia no JUnit e traz uma API mais rica e amig√°vel para lidar com a interface de usu√°rio.

4. **Cucumber**: √© uma ferramenta de automa√ß√£o de testes que se popularizou por trazer uma abordagem muito forte de BDD (Behavior-Driven Development) para o dia a dia do desenvolvimento de software. Diferente de frameworks mais t√©cnicos, que focam em testes unit√°rios ou funcionais a partir do c√≥digo, o Cucumber tem como diferencial a ideia de que os testes devem ser escritos em uma linguagem acess√≠vel a todos do time ‚Äî n√£o apenas a desenvolvedores. Ele utiliza a sintaxe Gherkin, que √© baseada em descri√ß√µes de comportamento no formato de cen√°rios, usando estruturas como Dado‚ÄìQuando‚ÄìEnt√£o. Isso permite que pessoas de neg√≥cio, analistas de QA e desenvolvedores conversem sobre o sistema usando a mesma forma de especifica√ß√£o, diminuindo ambiguidades e garantindo que todos entendam da mesma maneira o que est√° sendo implementado.

5. **Playwright**: √© uma ferramenta criada com foco em testes automatizados de aplica√ß√µes web, mas seu prop√≥sito vai um pouco al√©m disso, porque ele tamb√©m pode ser usado como uma biblioteca de automa√ß√£o de navega√ß√£o. A origem dele est√° na mesma equipe que desenvolveu o Puppeteer, do Google, mas a Microsoft o criou para oferecer mais robustez, abrang√™ncia e recursos modernos. O Playwright permite em testes com Cross-browser (Chrome Firefox etc) para aplica√ß√µes web, emula√ß√£o Mobile para simular dispositivos m√≥veis, e testes de API trata requisi√ß√µes HTTP.

6. TestComplete: √© uma ferramenta comercial de automa√ß√£o de testes desenvolvida pela SmartBear que tem como foco facilitar a cria√ß√£o, execu√ß√£o e manuten√ß√£o de testes funcionais em diferentes tipos de aplica√ß√µes, desde desktop, web at√© mobile. A grande proposta dela √© oferecer uma plataforma robusta que permite tanto a quem tem experi√™ncia em programa√ß√£o quanto a quem n√£o programa criar testes de forma eficiente. Isso √© poss√≠vel porque ela oferece duas formas de trabalho: por um lado, h√° a possibilidade de construir scripts completos em linguagens como Python, JavaScript, VBScript e outras suportadas, o que d√° liberdade total para quem tem familiaridade com c√≥digo; por outro lado, ela tamb√©m disponibiliza recursos de grava√ß√£o e reprodu√ß√£o, em que o testador interage com a aplica√ß√£o e o TestComplete grava essas intera√ß√µes para gerar um script automaticamente, que depois pode ser reutilizado e refinado.

7. Telerik Test Studio: √© uma ferramenta de automa√ß√£o de testes desenvolvida pela Progress, criada para simplificar e acelerar o processo de valida√ß√£o de software em diferentes tipos de aplica√ß√µes, desde web, desktop at√© aplicativos responsivos e mobile. O grande diferencial dela √© o foco em ser acess√≠vel para equipes que n√£o necessariamente t√™m profundo conhecimento em programa√ß√£o, ao mesmo tempo em que entrega recursos avan√ßados que podem ser explorados por engenheiros de testes mais experientes. Assim como outras solu√ß√µes comerciais, a proposta √© unir praticidade, estabilidade e integra√ß√£o com o ciclo de desenvolvimento.

8. HPE Unified Functional Testing: anteriormente conhecido como HP QuickTest Professional (QTP), √© uma das ferramentas mais tradicionais e consolidadas de automa√ß√£o de testes funcionais. Ele foi desenvolvido pela Hewlett-Packard (hoje Micro Focus, depois da aquisi√ß√£o da divis√£o de software da HPE) e √© amplamente utilizado em grandes corpora√ß√µes que precisam validar aplica√ß√µes complexas, que muitas vezes envolvem uma mistura de sistemas legados, aplica√ß√µes web modernas e at√© integra√ß√µes entre diferentes tecnologias. O grande diferencial do UFT sempre foi a abrang√™ncia tecnol√≥gica: ele suporta automa√ß√£o em aplica√ß√µes desktop, web, SAP, Oracle, PeopleSoft, aplica√ß√µes client-server, APIs e at√© mobile, tudo em uma √∫nica plataforma, reduzindo a necessidade de v√°rias ferramentas diferentes.

9. Ranorex: √© uma ferramenta comercial de automa√ß√£o de testes que ganhou bastante destaque justamente por tentar simplificar e unificar a automa√ß√£o em diferentes tipos de aplica√ß√µes, cobrindo desde softwares desktop, sistemas web at√© aplicativos mobile. Ele √© muito utilizado em ambientes corporativos onde existe a necessidade de automatizar aplica√ß√µes complexas, que muitas vezes envolvem tecnologias legadas misturadas com plataformas modernas. Seu grande diferencial √© oferecer uma interface visual poderosa, que permite a cria√ß√£o de testes sem exigir conhecimento avan√ßado em programa√ß√£o, mas ao mesmo tempo dar liberdade para quem domina c√≥digo escrever scripts mais sofisticados em linguagens como C# e VB.NET, j√° que o Ranorex √© baseado no ecossistema .NET.

10. Visual Studio Test Professional: √© uma edi√ß√£o do Visual Studio voltada especificamente para gest√£o e execu√ß√£o de testes de software dentro do ecossistema da Microsoft. Ele n√£o √© apenas um IDE, mas uma su√≠te de ferramentas pensada para equipes de QA e de desenvolvimento que precisam trabalhar de forma integrada em projetos com pr√°ticas √°geis e DevOps. Enquanto vers√µes como o Visual Studio Enterprise s√£o mais amplas e englobam todo o ciclo de desenvolvimento, o Test Professional √© um produto direcionado para o ciclo de vida de testes, oferecendo recursos de planejamento, acompanhamento e execu√ß√£o.

11. TestingWhiz: √© uma ferramenta de automa√ß√£o de testes voltada principalmente para equipes que buscam praticidade e velocidade na cria√ß√£o de testes, sem depender fortemente de programa√ß√£o. Diferente de frameworks open source como Selenium, que exigem bastante conhecimento t√©cnico e montagem de infraestrutura, o TestingWhiz aposta em uma abordagem codeless, baseada em uma interface visual intuitiva onde o testador pode construir fluxos de teste arrastando e configurando blocos de a√ß√µes pr√©-definidas. Isso o torna bastante atraente para equipes de QA funcionais ou para empresas que querem introduzir automa√ß√£o de forma r√°pida, sem exigir que todo o time saiba programar.

Existem muitas ferramentas de testes automatizados dispon√≠veis para diversas linguagens de programa√ß√£o e tipos de testes. Aqui est√£o algumas das mais populares, categorizadas por seu prop√≥sito principal:

<img height="377" align="right" src="https://github.com/user-attachments/assets/48562bf1-72a0-453b-aa21-cc58155a6a3c" />

1. **Frameworks de Teste Unit√°rio**:
   - **JUnit**: Framework de testes unit√°rios para Java. 
  
   - **NUnit**: Framework de testes unit√°rios para .NET.

   - **PyTest**: Framework de testes para Python.

   - **Mocha**: Framework de testes para JavaScript e Node.js.
  
   - **RSpec**: Framework de testes para Ruby.

   - **TestNG**: Outro framework de testes para Java.

2. **Ferramentas de Teste de Integra√ß√£o e Funcional**:

   - **Selenium**: Automa√ß√£o de navegadores para testes de aplica√ß√µes web.
  
   - **Cypress**: Ferramenta de teste de front-end para aplica√ß√µes web modernas.
   
   - **Protractor**: Ferramenta de teste de end-to-end para aplica√ß√µes Angular.

   - **Watir**: Ferramenta de automa√ß√£o de testes para aplica√ß√µes web.

3. **Ferramentas de Teste de Interface de Usu√°rio (UI)**:
  
   - **Appium**: Framework de automa√ß√£o para aplica√ß√µes m√≥veis (iOS e Android).
   
   - **TestComplete**: Ferramenta de automa√ß√£o de testes para aplica√ß√µes desktop, web e m√≥veis.
  
   - **Ranorex**: Ferramenta de automa√ß√£o de testes para desktop, web e dispositivos m√≥veis.

4. **Ferramentas de Teste de Performance e Carga**:
  
   - **JMeter**: Ferramenta para testes de carga e performance.
  
   - **Gatling**: Ferramenta de teste de carga focada em aplica√ß√µes web.
  
   - **LoadRunner**: Ferramenta de teste de carga e performance da Micro Focus.

5. **Ferramentas de Teste de Seguran√ßa**:
  
   - **OWASP ZAP**: Ferramenta para testes de penetra√ß√£o de aplica√ß√µes web.
  
   - **Burp Suite**: Ferramenta de teste de seguran√ßa para aplica√ß√µes web.
  
   - **Acunetix**: Ferramenta de varredura de seguran√ßa para aplica√ß√µes web.

6. **Ferramentas de Teste de APIs**:
  
   - **Postman**: Ferramenta para teste de APIs RESTful.
  
   - **SoapUI**: Ferramenta de teste para servi√ßos web SOAP e REST.
  
   - **RestAssured**: Biblioteca para teste de APIs REST em Java.

7. **Ferramentas de Integra√ß√£o Cont√≠nua**:
  
   - **Jenkins**: Ferramenta de integra√ß√£o cont√≠nua que pode ser usada para executar testes automatizados.
  
   - **GitHub Actions**: Servi√ßo de integra√ß√£o e entrega cont√≠nua integrado ao GitHub.

   - **GitLab CI/CD**: Ferramenta de integra√ß√£o cont√≠nua e entrega cont√≠nua do GitLab.

   - **CircleCI**: Servi√ßo de integra√ß√£o cont√≠nua e entrega cont√≠nua.

8. **Ferramentas de An√°lise de C√≥digo e Cobertura de Testes**:

   - **SonarQube**: Ferramenta de an√°lise est√°tica de c√≥digo que tamb√©m mede a cobertura de testes.

   - **JaCoCo**: Ferramenta de cobertura de testes para Java.

   - **Cobertura**: Ferramenta de cobertura de testes para Java.

   - **Istanbul**: Ferramenta de cobertura de testes para JavaScript.

Essas ferramentas ajudam a automatizar diferentes tipos de testes, desde testes unit√°rios b√°sicos at√© testes de performance e seguran√ßa, garantindo a qualidade e a estabilidade do software durante todo o ciclo de desenvolvimento.

## [QA] Unit testing
<img src="https://img.shields.io/badge/Jest-fail-%23C21325?style=flat&logo=jest&logoColor=white"> <img src="https://img.shields.io/badge/Mock-pass-chocolate?style=flat&logo=Mock&logoColor=white"> <img src="https://img.shields.io/badge/Go-passing-00ADD8?style=flat&logo=Go&logoColor=white"> <img src="https://img.shields.io/badge/PHPUnit-8.2-777BB4?style=flat&logo=PHP&logoColor=white"> <img src="https://img.shields.io/badge/-Pytest-blue?style=badge&logo=Pytest&logoColor=white"> <img src="https://img.shields.io/badge/JUnit5-passing-25A162?style=flat&logo=JUnit5&logoColor=white"> <img src="https://img.shields.io/badge/xUnit.net-8_pass_0_fail-512BD4?style=flat&logo=DotNet&logoColor=white">

<img src="https://em-content.zobj.net/source/microsoft-teams/363/test-tube_1f9ea.png" height="77" align="right">

Os **testes unit√°rios** ou **testes de unidade** (unit tests) √© toda a aplica√ß√£o de teste nas assinaturas de entrada e sa√≠da de um sistema. Consiste em validar dados v√°lidos e inv√°lidos via I/O (entrada/sa√≠da) sendo aplicado por desenvolvedores ou analistas de teste (QA). O teste unit√°rio √© uma verifica√ß√£o feita com uma pequena por√ß√£o de c√≥digo, uma unidade de um software. Ou seja, √© diferente do teste geral, que se dedica a testar o fluxo do sistema, com as funcionalidades principais.

Testes unit√°rios s√£o m√©todos que verificam o funcionamento de unidades de c√≥digo, vulgo m√©todos, e seus objetos associados. O grande objetivo, por incr√≠vel que pare√ßa, n√£o √© ter uma grande cobertura, e sim resultar em uma arquitetura melhor, menos acoplada, e de melhor manuten√ß√£o. Classes com muitas dep√™ndencias s√£o muito dif√≠ceis de testar. M√©trica utilizada: cobertura de c√≥digo. 

No unit√°rio, cada parte do sistema ganha uma aten√ß√£o devida e detalhada, de modo a otimizar o processo de identifica√ß√£o de erros. O objetivo √© ajudar a rastrear os bugs e impedir que eles retornem depois que altera√ß√µes forem feitas no produto.

Portanto, s√£o testes que verificam se uma parte espec√≠fica do c√≥digo, costumeiramente a n√≠vel de fun√ß√£o, est√° funcionando corretamente. Em um ambiente orientado a objetos (OOP) √© usualmente a n√≠vel de classes e a m√≠nima unidade de testes inclui construtores e destrutores. 

> üß™ Os testes de unidade verificam unidades, como m√©todos, fun√ß√µes e componentes dentro do software. S√£o os testes mais r√°pidos, baratos de escrever e sua manuten√ß√£o √© simples. Para verificar o <a href="">comportamento</a> dessas pequenas partes isoladas do sistema sem depend√™ncias externas como banco de dados, APIs, arquivos ou rede. Por isso, eles s√£o r√°pidos de executar, baratos de manter e oferecem feedback imediato durante o desenvolvimento. Como testam unidades isoladas, s√£o fundamentais para garantir a estabilidade do c√≥digo √† medida que ele evolui.

Uma **unidade** (unit) √© a menor parte test√°vel de um programa de computador, no programa√ß√£o procedural uma unidade pode ser uma fun√ß√£o individual ou um procedimento do nosso c√≥digo, imagine que toda fun√ß√£o √© uma pequena f√°brica que fabrica alguma coisa que pode sair, sem a necessidade de entrar algo. Idealmente, cada teste de unidade √© independente dos demais, o que possibilita ao programador testar cada m√≥dulo isoladamente.

Rela√ß√£o de conceitos de testes de unidade: 

**I/O Input-Output** (Entrada e Sa√≠da): s√£o todas as entradas e sa√≠das existentes na programa√ß√£o. Portanto, os testes de unidade servem para front-end e back-end. Eles s√£o uma pr√°tica essencial no desenvolvimento de software, pois ajudam a garantir a qualidade do c√≥digo e a facilitar a manuten√ß√£o. Os testes de unidade s√£o realizados em pequenas unidades de c√≥digo, como fun√ß√µes, componentes ou m√≥dulos. Eles s√£o projetados para testar a funcionalidade e a l√≥gica dessas unidades de forma isolada. Isso significa que os testes de unidade n√£o dependem de outros componentes ou m√≥dulos para funcionar.

No **front-end**, os testes de unidade s√£o usados para testar a funcionalidade e a l√≥gica de componentes de interface do usu√°rio, como bot√µes, formul√°rios e listas. Eles tamb√©m s√£o usados para testar a intera√ß√£o entre componentes.

No **back-end**, os testes de unidade s√£o usados para testar a funcionalidade e a l√≥gica de servi√ßos, APIs e outros componentes de back-end. Eles tamb√©m s√£o usados para testar a integra√ß√£o entre componentes de back-end.

Os testes de unidade oferecem uma s√©rie de benef√≠cios, incluindo:

<img src="https://uploads.toptal.io/blog/image/91302/toptal-blog-image-1434578005589-4e6897ec04cc0b3c7075b9b011ee915c.gif" height="377" align="right">

- Aumento da qualidade do c√≥digo: Os testes de unidade ajudam a identificar erros e bugs no c√≥digo antes que eles sejam integrados ao sistema. Isso resulta em um c√≥digo mais confi√°vel e est√°vel.

- Facilidade de manuten√ß√£o: Os testes de unidade facilitam a manuten√ß√£o do c√≥digo, pois permitem verificar se as altera√ß√µes n√£o afetaram o funcionamento de outras partes do c√≥digo.

- Agilidade no desenvolvimento: Os testes de unidade permitem que os desenvolvedores tenham mais confian√ßa ao realizar refatora√ß√µes ou adicionar novos recursos. Isso permite que as equipes desenvolvam de forma mais r√°pida e eficiente.

Portanto, os testes de unidade s√£o uma pr√°tica importante para qualquer desenvolvedor, independentemente da √°rea de atua√ß√£o. 

Sobre os processos de desenvolvimento de software, no terceiro passo no n√≠vel de queda do modelo cascata e no quarto passo do modelo RAPID, entramos na parte de codifica√ß√£o e testes unit√°rios. Ou seja, √© a constru√ß√£o do sistema em si. Ent√£o, s√≥ depois de eu entender todo o problema, s√≥ depois de eu saber das necessidades e se √© poss√≠vel ou vi√°vel para come√ßar a desenvolver. Muitas vezes, para come√ßar a gente se pergunta se √© para pegar logo no processo de codifica√ß√£o, ou seja, a desenvolver logo a aplica√ß√£o o mais r√°pido poss√≠vel. No entanto, percebe-se que o tanto de retrabalho que isso gerava, fazia n√£o valer a pena. E fazia com que estourasse muito o or√ßamento nesse custo. Ent√£o, depois deu definir os requisitos, depois de realizar meus modelos de projetos e provar que aquilo √© vi√°vel, eu ent√£o come√ßo o desenvolvimento do meu software em si.

Ap√≥s o desenvolvimento e junto com o desenvolvimento, entram os testes unit√°rios (unit tests - testes de unidade) que s√£o definidos pelo pr√≥prio desenvolvedor onde eles tendem a testar a menor unidade do sistema. Por exemplo: Se eu estou desenvolvendo um sistema de cadastro de cliente, n√£o importa o tipo do sistema (mercadinho, farm√°cia, padaria, com√©rcio ou de uma grande empresa) e esse desenvolvedor que est√° escrevendo essas linhas de c√≥digo de cadastrar um √∫nico usu√°rio ou funcion√°rio, por exemplo, ele vai desenvolver um caso de teste para que dado uma entrada (input), ele possa receber uma sa√≠da (output) esperada que seria: "usu√°rio cadastrado com sucesso".

Os frameworks de teste de unidade mais populares para **React.js** s√£o:

- <a href="">Jest</a>: O Jest √© um framework de teste de unidade JavaScript criado pelo Facebook. Ele √© r√°pido, f√°cil de usar e oferece uma variedade de recursos, como testes de snapshot, mocking e asser√ß√µes.

- <a href="">Testing Library</a>: A Testing Library √© uma biblioteca de utilit√°rios para testes de componentes React. Ela fornece uma API simples e intuitiva que permite testar componentes sem depender dos detalhes de implementa√ß√£o.

- <a href="">Enzyme</a>: O Enzyme √© uma biblioteca de teste de componentes React que fornece uma API poderosa e flex√≠vel para manipular o DOM e testar eventos.

A escolha do framework de teste de unidade mais adequado depende das necessidades espec√≠ficas do projeto. O Jest √© uma boa op√ß√£o para projetos simples, enquanto frameworks como a Testing Library ou o Enzyme podem ser mais adequados para projetos mais complexos.

Os frameworks de teste de unidade mais populares para **Vue.js** s√£o:

- <a href="">Vue Test Utils</a>: O Vue Test Utils √© um conjunto de utilit√°rios para testes de componentes Vue.js. Ele fornece uma API simples e intuitiva que permite testar componentes sem depender dos detalhes de implementa√ß√£o.

- <a href="">Jest</a>: O Jest √© um framework de teste de unidade JavaScript criado pelo Facebook. Ele tamb√©m pode ser usado para testes de unidade em Vue.js.

- <a href="">Karma</a>: O Karma √© um framework de teste de unidade JavaScript que pode ser usado para executar testes em uma variedade de navegadores. Ele tamb√©m pode ser usado para testes de unidade em Vue.js.

A escolha do framework de teste de unidade mais adequado depende das necessidades espec√≠ficas do projeto. O Vue Test Utils √© uma boa op√ß√£o para projetos simples, enquanto frameworks como o Jest ou o Karma podem ser mais adequados para projetos mais complexos.

O framework Python para web back-end chamado **Django** fornece um framework de teste padr√£o, chamado de **unittest**. Esse framework √© baseado na biblioteca padr√£o unittest do Python e √© adequado para testes unit√°rios e de integra√ß√£o.

Al√©m do unittest, existem outros frameworks de teste de unidade dispon√≠veis para Django. Alguns dos frameworks mais populares incluem:

- <a href="">Pytest</a>: O Pytest √© um framework de teste de unidade completo e flex√≠vel que oferece uma variedade de recursos, como assertion fixtures, parametriza√ß√£o de testes e testes de desempenho.

- <a href="">Mock</a>: O Mock √© um framework de mocking que permite simular o comportamento de objetos externos. Isso pode ser √∫til para testar a funcionalidade de componentes que dependem de outros componentes ou APIs externas.

- <a href="">Selenium</a>: O Selenium √© um framework de automa√ß√£o de testes que permite testar a intera√ß√£o com um navegador web. Isso pode ser √∫til para testar a funcionalidade de componentes de front-end.

A escolha do framework de teste de unidade mais adequado depende das necessidades espec√≠ficas do projeto. O unittest √© uma boa op√ß√£o para projetos simples, enquanto frameworks como Pytest e Mock podem ser mais adequados para projetos mais complexos.

Lembre-se das seguintes diretrizes ao escrever testes para seus m√©todos:

- Teste se a sa√≠da esperada de um m√©todo corresponde √† sa√≠da real.
- Teste se as fun√ß√µes chamadas dentro do m√©todo est√£o ocorrendo o n√∫mero desejado de vezes.
- N√£o tente testar c√≥digo que n√£o fa√ßa parte do m√©todo que est√° sendo testado.
- N√£o fa√ßa chamadas de API, conex√µes de banco de dados ou solicita√ß√µes de rede ao escrever seus testes.

Sobre os conceitos t√©cnicos a respeito de testes de unidades, temos:

<img src="https://github.com/IsaacAlves7/DevSecOps/assets/61624336/f92b16ca-c0a0-40ab-ab33-f8ec9f4cf619" height="77" align="right">

‚úÖ **Testes V√°lidos** (`pass`): S√£o entradas e sa√≠das de dados comuns ao sistema e pertencem ao processo normal. N√£o apresentam tratamento al√©m do normal j√° programado. No caso de retorno dever√° seguir os padr√µes estabelecidos e n√£o permitir retornos fora das regras especificadas. Em testes unit√°rios, estamos nos referindo a casos de teste que exercitam o comportamento correto e esperado da unidade de c√≥digo sob condi√ß√µes normais (v√°lidas), ou seja: Situa√ß√µes em que tudo ocorre como deveria. S√£o aqueles testes que usam entradas v√°lidas e esperadas, esperam resultados corretos, sem exce√ß√µes ou erros. Confirmam que o comportamento da fun√ß√£o est√° conforme o esperado.

Caracter√≠sticas de testes v√°lidos:

| Caracter√≠stica              | Exemplo pr√°tico                                           |
| --------------------------- | --------------------------------------------------------- |
| Entrada no dom√≠nio esperado | CPF v√°lido, n√∫mero positivo, email formatado corretamente |
| Estado inicial v√°lido       | Usu√°rio existente, banco conectado, produto em estoque    |
| Fluxo normal do c√≥digo      | Sem exce√ß√µes, erros, ou retornos inesperados              |
| Resultado esperado          | Retorno certo, estado alterado corretamente               |

Exemplo: Teste manual simples em JavaScript - Aqui, `2` e `3` s√£o valores v√°lidos, e o retorno esperado (`5`) confirma o comportamento correto da fun√ß√£o.

<img src="https://img.shields.io/badge/Jest-1_pass_0_fail-limegreen?style=flat&logo=jest&logoColor=white">

```javascript
function somar(a: number, b: number): number {
  return a + b;
}

test("soma dois n√∫meros positivos", () => {
  expect(somar(2, 3)).toBe(5); // ‚úÖ teste v√°lido
});
```

As _afirma√ß√µes_ (em ingl√™s, **assertions**) determinam se seu teste √© `aprovado` ou `reprovado`. Elas comparam o valor de retorno esperado de um m√©todo com o valor real. H√° uma s√©rie de afirma√ß√µes que voc√™ pode fazer no final do seu teste.

A classe `Assertions` no JUnit consiste em m√©todos est√°ticos que fornecem v√°rias condi√ß√µes para decidir se o teste √© aprovado ou n√£o. Veremos esses m√©todos √† medida que eu o guie por cada exemplo.

<img src="https://github.com/IsaacAlves7/DevSecOps/assets/61624336/1e50bc84-048c-40c7-b7b8-98dfdeec38a2" height="77" align="right">

‚ùå **Testes Inv√°lidos** (`fail`): S√£o entradas e sa√≠das de dados n√£o comuns ao sistema. Apresentam tratamento para validar o tipo de dado inv√°lido ou situa√ß√£o. Pode apresentar at√© dois retornos, uma mensagem para um log no sistema e uma mensagem com formata√ß√£o e escrita adequada ao usu√°rio. S√£o t√£o importantes quanto os testes v√°lidos, porque ajudam a garantir que sua fun√ß√£o se defenda bem contra entradas erradas, estados incorretos ou fluxos inesperados. S√£o testes que usam entradas inv√°lidas, incorretas ou fora do esperado; Esperam que o c√≥digo falhe corretamente (com exce√ß√£o, erro, ou retorno de falha); Verificam se o sistema √© robusto contra dados errados ou uso indevido da fun√ß√£o.

Exemplo:

```txt
Dividir (x int,y int)=z int
```

Caso tenhamos `x=1` e `y=0`, `z` ser√° um valor com erro e dever√° retornar uma mensagem ao usu√°rio, avisando que a opera√ß√£o √© inv√°lida. Caso a express√£o seja um dado comum do sistema, a autoriza√ß√£o para tal valida√ß√£o dever√° ser do usu√°rio, pois faz parte do conjunto de regras de neg√≥cio. N√£o existe retorno inv√°lido sem um tratamento. O tratamento gen√©rico ser√° apenas para condi√ß√µes n√£o vis√≠veis na regra e uso do sistema.

<img src="https://github.com/user-attachments/assets/e80b1013-dd61-4dc1-a997-8addb2209c4e" height="177" align="right">

üëÅÔ∏è‚Äçüó®Ô∏è **Dom√≠nio**: No dom√≠nio de testes, usamos testes unit√°rios para validar a funcionalidade de cada componente do nosso dom√≠nio de neg√≥cio, refere-se √† parte do sistema que √© testada para garantir que a l√≥gica de neg√≥cio e a funcionalidade do c√≥digo est√£o corretas, os testes unit√°rios focam em componentes individuais desse dom√≠nio.

> [!Important]
> √â importante ressaltar sobre um termo muito conhecido em ci√™ncia da computa√ß√£o, chamado **dom√≠nio** (domain), cujo a diferen√ßa est√° no n√≠vel de abstra√ß√£o e no foco de cada conceito. A palavra "dom√≠nio" realmente aparece em contextos diferentes e pode causar confus√£o se n√£o for bem delimitada.

No contexto de testes unit√°rios, "dom√≠nio" pode se referir genericamente √† camada de regras de neg√≥cio ou l√≥gica principal da aplica√ß√£o, que √© o alvo ideal desses testes ‚Äî ou seja, testar a l√≥gica do dom√≠nio sem envolver infraestrutura, banco de dados ou interface.

J√° em DDD (Domain-Driven Design), "dom√≠nio" √© o conceito central: √© o conhecimento do neg√≥cio que est√° sendo modelado, e tudo gira em torno disso ‚Äî √© a √°rea de interesse do sistema, como log√≠stica, financeiro, sa√∫de, etc.

No caso de arquiteturas como Clean Architecture ou Ports & Adapters, "dom√≠nio" √© uma camada bem definida e isolada que representa as regras puras do neg√≥cio, ou seja, aquilo que n√£o muda mesmo que a tecnologia mude; √© o n√∫cleo da aplica√ß√£o.

J√° em TDD e BDD, o termo "dom√≠nio" aparece implicitamente quando voc√™ escreve testes voltados para comportamentos do sistema, especialmente no BDD que foca na linguagem ub√≠qua e no comportamento esperado do dom√≠nio de neg√≥cio, enquanto o TDD tende a atuar mais no detalhe t√©cnico e no design emergente.

Por fim, em design de software e design patterns, o "dom√≠nio" pode surgir como contexto onde os padr√µes s√£o aplicados, mas o foco desses conceitos √© mais estrutural e de solu√ß√£o t√©cnica do que modelagem de neg√≥cio em si.

Ent√£o, "dom√≠nio" em DDD e arquiteturas limpas √© o cora√ß√£o das regras do neg√≥cio, enquanto em testes e padr√µes, √© mais o cen√°rio onde voc√™ aplica as pr√°ticas, muitas vezes sem foco expl√≠cito em representar o neg√≥cio como um modelo coeso.

Voc√™ pode dizer: 

> "Nos nossos testes de unidade, verificamos se os m√©todos da entidade `Pedido` calculam corretamente o total do pedido."

Focado na verifica√ß√£o da funcionalidade de unidades isoladas de c√≥digo (geralmente m√©todos ou fun√ß√µes), tem como objetivo garantir que cada parte do software funcione conforme esperado de maneira isolada. O contexto aqui √© mais t√©cnico e voltado para a qualidade do c√≥digo e a preven√ß√£o de regress√µes.

Pode ser um campo, uma assinatura, um I/O, ou qualquer tipo de local que receba valores externos ao sistema. Todo dom√≠nio deve realizar consist√™ncias de dados v√°lidos e inv√°lidos. Um dom√≠nio s√≥ permite dados com a formata√ß√£o igual ao que ser√° armazenado.

Ex.: Campo DDD dever√° permitir n√∫meros de at√© quatro casas n√£o negativas ou a base de dados deve impedir a entrada de valores inv√°lidos. Receber e guardar o mesmo tipo de dado, o tamanho do campo que recebe os dados deve ser menor ou igual ao campo que ir√° armazenar os dados (em raros casos os campos de armazenamento s√£o menores que os de exibi√ß√£o).

Em suma, dom√≠nio √© o tipo de valor v√°lido para cada campo. Como exemplo podemos citar: 

```txt
Campo nome: Dominio = tipo: string; tamanho:50
```

Ao aplicarmos o particionamento por equival√™ncia e a an√°lise por valor limite, poderemos criar as seguintes classes de testes.

Particionamento por Equival√™ncia: campo nome:

- valor em branco (BLANK); Cen√°rio Negativo
- `valor > 50`; Cen√°rio Negativo
- qualquer valor de `1` a `50`; Cen√°rio Positivo

An√°lise por Valor Limite:

```txt
campo nome: valor em branco; valores 49,50,51; 
```

Usamos um valor exatamente inferior e exatamente posterior ao valor do campo, devido ao fato dos erros aparecerem nas fronteiras da aplica√ß√£o.

O dom√≠nio de testes unit√°rios, o dom√≠nio de DDD (Domain-Driven Design) e o dom√≠nio de microsservi√ßos podem estar inter-relacionados, mas n√£o s√£o exatamente o mesmo dom√≠nio. Embora o dom√≠nio de testes unit√°rios, o dom√≠nio de DDD e o dom√≠nio de microsservi√ßos n√£o sejam exatamente o mesmo, eles est√£o inter-relacionados e podem se complementar. Testes unit√°rios verificam a funcionalidade do c√≥digo, DDD foca na modelagem do dom√≠nio de neg√≥cios, e microsservi√ßos organizam a aplica√ß√£o em componentes pequenos e independentes. Quando usados juntos, esses conceitos podem ajudar a criar sistemas robustos, bem projetados e testados. Voc√™ pode ter uma comunica√ß√£o mais assertiva com o seu time falando da maneira proposta acima que eles ir√£o entender de qual tipo de dom√≠nio se trata.

Quando voc√™ combina esses tr√™s conceitos, voc√™ pode comunicar algo como: 

> "No nosso sistema, utilizamos uma abordagem de Domain-Driven Design (DDD) para modelar nosso dom√≠nio de neg√≥cio. Cada parte do dom√≠nio de neg√≥cio √© implementada como um microsservi√ßo independente, permitindo escalabilidade e independ√™ncia de desenvolvimento. Al√©m disso, garantimos a qualidade e a corre√ß√£o da l√≥gica de neg√≥cio com testes unit√°rios abrangentes, que validam cada componente do nosso dom√≠nio de neg√≥cio."

Agora, imagine que voc√™ precisa validar o funcionamento de sua aplica√ß√£o em um determinado cen√°rio, mas este cen√°rio s√≥ funciona se integrado com uma aplica√ß√£o de terceiros espec√≠fica, a qual voc√™ n√£o tem total acesso.

O fato de voc√™ n√£o ter acesso traz um dilema: ou voc√™ ignora a integra√ß√£o e roda o teste, inviabilizando a obten√ß√£o de resultados assertivos, ou n√£o testa de modo algum.

Nenhuma das op√ß√µes √© realmente a escolha ideal, mesmo se voc√™ encarar aquele ditado ‚Äúfeito √© melhor que perfeito‚Äù. Afinal, √© muito t√™nue a linha entre n√£o trazer os resultados corretos e n√£o testar.

O ideal seria existir algo que possibilitasse que os testes trouxessem os melhores resultados, mesmo sem acesso √† tecnologia necess√°ria. A boa not√≠cia √© que existe! Estamos falando dos _test doubles_.

<img src="https://github.com/IsaacAlves7/DevSecOps/assets/61624336/3963eb3d-ea61-4557-92cb-2f097cfed79a" height="77" align="right">

Os **Test doubles** s√£o objetos usados em testes de software para substituir componentes reais que um sistema ou m√≥dulo depende, permitindo que os testes sejam mais control√°veis, isolados, r√°pidos e confi√°veis. O nome ‚Äúdouble‚Äù vem da ideia de um ‚Äúdubl√™‚Äù no cinema: algu√©m que substitui o ator em cenas arriscadas. No c√≥digo, os test doubles substituem partes reais (como um banco de dados, uma API externa ou at√© um servi√ßo interno) que voc√™ n√£o quer ou n√£o pode usar diretamente durante o teste. Termo gen√©rico para qualquer substitui√ß√£o de objeto de produ√ß√£o em testes.

De acordo com Martin Fowler, test doubles √© um conceito usado quando, para viabilizar a realiza√ß√£o de testes, algum objeto em produ√ß√£o precisa ser substitu√≠do por outro. O termo vem da analogia com os ‚Äúdubl√™s de cinema‚Äù: quando voc√™ n√£o pode (ou n√£o deve) usar um componente real em um teste, voc√™ o substitui por uma vers√£o simulada que cumpre o mesmo papel de forma controlada e previs√≠vel. Os *test doubles* podem ser aplicados **a qualquer depend√™ncia externa ou componente cuja execu√ß√£o real atrapalhe o isolamento do teste**.

<img height="277" align="right" src="https://github.com/user-attachments/assets/b3dfda90-1d63-4672-adfe-67e334ee45cd" />

Em resumo, as duplicatas de teste (test doubles) s√£o usadas para criar testes r√°pidos, independentes, determin√≠sticos e confi√°veis. Eles representam componentes reais, semelhante √† forma como os dubl√™s s√£o usados nos filmes. Um test double pode ser usado para simplificar testes, aumentar a velocidade de execu√ß√£o ou permitir resultados determin√≠sticos de uma a√ß√£o.

Na pr√°tica, isso inclui **APIs externas**, **bancos de dados**, **requisi√ß√µes HTTP**, **filas de mensageria (como RabbitMQ)**, **sistemas de cache (Redis, por exemplo)**, **consultas SQL complexas**, **chamadas a LLMs (modelos de linguagem)** e at√© **fun√ß√µes, classes e m√©todos internos** que geram efeitos colaterais ou dependem de recursos n√£o determin√≠sticos (como hora do sistema, aleatoriedade, IO ou threads).

Por exemplo, em um teste unit√°rio que precisa validar a l√≥gica de neg√≥cio de uma fun√ß√£o que consome uma API REST, voc√™ n√£o quer depender de uma chamada real ‚Äî isso tornaria o teste lento, sujeito a falhas de rede e dependente de algo fora do seu controle. Nesse caso, voc√™ cria um **mock** da API, que retorna uma resposta previs√≠vel. Da mesma forma, se a fun√ß√£o l√™ dados de um banco, voc√™ cria um **stub** ou **fake** para simular a consulta.

<img height="277" align="right" src="https://github.com/user-attachments/assets/22e14580-ed05-4d76-a49f-04f073454f55" />

Ent√£o, resumindo: o conceito de *test doubles* se aplica a **qualquer camada do sistema** ‚Äî desde uma fun√ß√£o pura at√© integra√ß√µes complexas com APIs, bancos ou modelos de IA ‚Äî sempre que o objetivo √© **isolar o teste da depend√™ncia real** para torn√°-lo **determin√≠stico, r√°pido e confi√°vel**.

Por exemplo, um programa que utiliza um servidor de banco de dados √© relativamente lento e consome recursos significativos do sistema, o que prejudica a produtividade dos testes. Um teste pode exigir dados do banco de dados que, sob atividade normal do sistema, est√£o em constante altera√ß√£o, fornecendo, assim, sa√≠das n√£o determin√≠sticas para qualquer consulta. Um test double pode fornecer um valor est√°tico em vez de acessar um banco de dados real, evitando tanto chamadas de rede ou do sistema quanto dados em constante mudan√ßa.

Um test double tamb√©m pode ser usado para testar parte do sistema que est√° pronta para teste, mesmo que suas depend√™ncias n√£o estejam.

Por exemplo, em um sistema com os m√≥dulos `Login`, `Home` e `User`, suponha que `Login` esteja pronto para teste, mas os outros dois n√£o. As fun√ß√µes consumidas de `Home` e `User` podem ser implementadas como test doubles para que `Login` possa ser testado.

Quando falamos em Test Doubles, estamos nos referindo a objetos ‚Äúsubstitutos‚Äù que criamos para simular comportamentos em testes, especialmente quando n√£o queremos ou n√£o podemos usar a implementa√ß√£o real de uma depend√™ncia. O nome vem de uma analogia com o ‚Äústunt double‚Äù do cinema, o dubl√™ que substitui o ator em cenas perigosas. Em testes de software, um test double substitui um componente real para que possamos isolar o c√≥digo que queremos validar. 

Fazendo um paralelo simplista, eles s√£o como dubl√™s de atores em um filme: substituem aplica√ß√µes reais durante a realiza√ß√£o de um teste por simular sua apar√™ncia e comportamento. Isso traz menos complexidade ao teste, al√©m de permitir verificar uma parte de um sistema sem ficar preso em todas as suas outras por√ß√µes.

Advert√™ncias: Embora os test doubles sejam frequentemente usados para facilitar o teste de unidade, existem limita√ß√µes em seu uso, a principal sendo que a conectividade real ao banco de dados ou outros acessos externos n√£o √© comprovada por esses testes. Para evitar erros que podem passar despercebidos por isso, s√£o necess√°rios outros testes que instanciem o c√≥digo com as implementa√ß√µes "reais" das interfaces mencionadas acima. Esses riscos de integra√ß√£o geralmente s√£o cobertos por testes de integra√ß√£o, testes de sistema ou testes de integra√ß√£o de sistema.

Talvez voc√™ n√£o esteja familiarizado com o termo test double. √â que, √†s vezes, eles s√£o generalizados pela palavra mock, ou ent√£o pela express√£o ‚Äúmockar‚Äù . O fato √© que mock √© apenas um dos exemplos de test doubles dentro de uma fam√≠lia muito maior. Al√©m dos mocks, existem, por exemplo, os fakes, os stubs, os dummies‚Ä¶ Abaixo, explico alguns deles.

Eles s√£o fundamentais para testes automatizados, principalmente testes unit√°rios, e ajudam a focar apenas na l√≥gica que voc√™ est√° testando, sem interfer√™ncia de outras partes do sistema. 

Martin Fowler classifica os test doubles em cinco tipos, que s√£o os tipos mais comuns de Test Doubles s√£o geralmente organizados em cinco categorias cl√°ssicas:

<a href="https://pt.slideshare.net/slideshow/sc-mad-tdd-workshop-test-doubles-36543998/36543998"><img src="https://github.com/user-attachments/assets/633f5cc2-e3ff-46ea-a801-44b80ddca48e" height="277" align="right"></a>

1. `Dummy` (Boneco de simula√ß√£o): Passado mas nunca usado; listas de par√¢metros de preenchimentos. Usado apenas para preencher par√¢metros, sem comportamento algum. Objetos de preenchimento e sem funcionalidade.

2. `Fake` (Falso): tem uma implementa√ß√£o funcional, mas n√£o √© adequado para produ√ß√£o. Que tem uma implementa√ß√£o funcional, mas simplificada (por exemplo, um banco de dados em mem√≥ria). Implementa√ß√£o simplificada e funcionalidade b√°sica.

3. `Stub` (Simulacro): Fornece respostas prontas para chamadas feitas durante o teste. Que retorna respostas fixas ou predefinidas. Respostas pr√©-determinadas e imita o comportamento real.

4. `Spy` (Espi√£o): Um esbo√ßo que registra informa√ß√µes sobre como foi chamado. Que registra chamadas e argumentos para verifica√ß√£o posterior. Monitoramento de intera√ß√µes e observa o comportamento.

5. `Mock` (Simulado): Pr√©-programado com expectativas, formando uma especifica√ß√£o das chamadas esperadas. Que define expectativas expl√≠citas de comportamento (quantas vezes deve ser chamado, com quais par√¢metros etc.). Verifica√ß√£o de comportamento e rastreamento de chamadas de m√©todos.

O primeiro √© o **Dummy**, que √© o mais simples: s√£o objetos criados apenas para preencher par√¢metros ou satisfazer assinaturas de m√©todos, mas que nunca s√£o realmente usados. Eles existem para evitar nulls ou falhas de compila√ß√£o, mas n√£o participam da l√≥gica do teste.

Os dummies s√£o dados que substituem dados reais, mas que n√£o chegam a ser realmente utilizados no teste. S√£o normalmente usados para satisfazer determinados par√¢metros.

Como uso de dummies √© poss√≠vel diminuir a complexidade durante a escrita de um teste, ignorando o que n√£o √© relevante no cen√°rio e focando no que realmente importa.

<img height="277" align="right" alt="fake" src="https://github.com/user-attachments/assets/f81524ad-936f-4b9e-9822-05c32d02489c" />

Os **fakes** s√£o test doubles que t√™m implementa√ß√µes reais diferentes √†quelas que existem em produ√ß√£o. √© uma implementa√ß√£o funcional simplificada de um componente real. Ele realmente executa algo, mas de maneira controlada e menos complexa.

Um exemplo cl√°ssico √© um banco de dados em mem√≥ria usado nos testes em vez de um banco de produ√ß√£o, ou um servidor HTTP falso que responde rapidamente sem precisar de rede. 

Os fakes aceleram os testes e evitam depend√™ncias externas pesadas. Podemos consider√°-los como um ‚Äúatalho‚Äù, algo implementado para deixar a execu√ß√£o do teste mais din√¢mica frente ao que √© colocado no ar de fato.

Basicamente, n√£o h√° l√≥gica em um fake ‚Äî ele retorna um valor determinado por quem o implementa e, justamente por isso, n√£o √© um elemento adequado para ir √† produ√ß√£o. Contudo, ele elimina a necessidade de implementar uma funcionalidade real, o que seria bem mais complexo.

<img height="277" align="right" src="https://github.com/user-attachments/assets/4f994eed-d9b0-44fd-8272-3d54b28a4e27" />

O **Stub** √© um objeto que fornece respostas pr√©-determinadas para chamadas feitas durante o teste. Ele n√£o tem l√≥gica real, apenas retorna o que foi configurado. Os stubs s√£o muito √∫teis quando voc√™ quer garantir que o teste receba certos dados sem depender de sistemas externos, como simular uma API retornando um JSON fixo.

S√£o similares aos fakes e aos spies, mas, ao contr√°rio destes, ele consegue alterar seu comportamento com base na maneira como ele foi chamado no teste.

O stub tamb√©m √© uma forma de teste duplo usado para fornecer uma resposta controlada das depend√™ncias de um componente. Esse tipo de teste duplo pode ser usado para fornecer uma resposta controlada sem fazer nenhuma l√≥gica real. Os stubs geralmente n√£o d√£o nenhuma resposta fora do que est√° programado no teste. Isso permite que mais de um cen√°rio para uma √∫nica depend√™ncia seja representado no teste.

As depend√™ncias externas podem n√£o se limitar apenas √†s classes, mas tamb√©m a certos m√©todos. O **stubbing de m√©todo** deve ser feito quando sua fun√ß√£o est√° chamando uma fun√ß√£o externa em sua implementa√ß√£o. Nesse caso, voc√™ faz com que essa fun√ß√£o retorne o valor que voc√™ deseja em vez de chamar o m√©todo real.

Por exemplo, o m√©todo que voc√™ est√° testando (A) est√° chamando um m√©todo externo (B) em sua implementa√ß√£o. B faz uma consulta ao banco de dados, buscando todos os alunos com notas maiores que 80. Fazer uma chamada real ao banco de dados n√£o √© uma boa pr√°tica aqui. Portanto, voc√™ faz um stub do m√©todo e o faz retornar uma lista fict√≠cia de alunos que voc√™ precisa para testar.

Qual √© a diferen√ßa entre Mock e Stub? A julgar pela defini√ß√£o de mock e stub, parece que mock e stub s√£o a mesma coisa. Isso ocorre porque uma simula√ß√£o pode ser considerada uma extens√£o de um esbo√ßo. Um stub √© apenas uma implementa√ß√£o simples usada para fornecer uma resposta controlada. Enquanto isso, a simula√ß√£o n√£o funciona apenas como um stub, mas tamb√©m verifica o comportamento de um componente e sua intera√ß√£o com o objeto que a simula√ß√£o cria.

<img src="https://github.com/user-attachments/assets/4024470e-6396-4b5b-849c-ec7a86e2bc54" height="277" align="right">

Os **mocks** tem expectativas sobre o jeito que deve ser chamado e, caso ele n√£o seja chamado da forma correta, o teste deve falhar. Eles s√£o usados para testar intera√ß√µes entre m√©todos e s√£o √∫teis onde n√£o h√° como verificar algumas mudan√ßas de estado ou retornos do m√©todo testado diretamente.

**Mocking** (Mockado) √© uma t√©cnica usada em testes de software para simular o comportamento de depend√™ncias externas, como servi√ßos, bancos de dados, ou APIs, dentro de uma unidade de c√≥digo que voc√™ est√° testando. Ao inv√©s de usar as implementa√ß√µes reais dessas depend√™ncias, voc√™ cria "mocks" (objetos falsos) que imitam o comportamento esperado, permitindo testar o c√≥digo de forma isolada. 

O principal benef√≠cio do mocking √© garantir que o teste foque apenas no comportamento da unidade de c√≥digo em quest√£o, sem se preocupar com o comportamento ou estado das depend√™ncias externas. A classe cujos m√©todos voc√™ est√° testando pode ter algumas depend√™ncias externas. Como mencionado anteriormente, voc√™ n√£o deve tentar testar c√≥digo que n√£o fa√ßa parte da fun√ß√£o que est√° sendo testada.

Nos casos em que sua fun√ß√£o usa uma classe externa, por√©m, √© uma boa pr√°tica fazer um mock dessa classe, ou seja, ter valores de mock-up (algo como "simula√ß√µes", em portugu√™s) em vez dos valores reais. Usaremos a biblioteca **Mockito** para esse fim.

Exemplo: Se voc√™ estiver testando um servi√ßo que depende de um reposit√≥rio de dados, voc√™ pode usar um mock para simular as respostas do reposit√≥rio, em vez de acessar o banco de dados real.

Mocking e testes unit√°rios s√£o diferentes, mas se complementam para testar unidades isoladas do c√≥digo. Os testes unit√°rios tem o objetivo de testar uma unidade de c√≥digo (como uma fun√ß√£o ou m√©todo) de forma independente, garantindo que ela funcione corretamente em diferentes cen√°rios. Em um teste unit√°rio, voc√™ se preocupa apenas com o comportamento interno dessa unidade. 

J√° o mocking √© uma t√©cnica usada nos testes unit√°rios para simular (mockar) depend√™ncias externas da unidade que est√° sendo testada. Isso permite que voc√™ foque exclusivamente na l√≥gica interna da unidade, sem se preocupar com o comportamento ou estado de servi√ßos, bancos de dados ou APIs reais. Em resumo, os mocks ajudam a garantir que os testes unit√°rios sejam realmente isolados e focados na unidade de c√≥digo que est√° sendo testada, sem interfer√™ncias externas.

<img src="https://github.com/user-attachments/assets/0f2ecf0d-35de-4fe4-a7b7-24530745efd0" height="277" align="right">

Por fim, existe o **Spy**, que √© uma esp√©cie de h√≠brido. Ele √© um objeto real, mas que tem a capacidade de registrar as chamadas que recebeu, permitindo inspecionar posteriormente como foi utilizado. Diferente do mock, o spy n√£o necessariamente substitui a l√≥gica real; ele executa de verdade, mas deixa rastros que podem ser verificados.

Um spy age como um espi√£o sob a implementa√ß√£o real e, como o mock, consegue verificar as intera√ß√µes entre os m√©todos.

A diferen√ßa para o mock √© que o spy chama a implementa√ß√£o real para todos os m√©todos da interface mockada, a n√£o ser que para algum m√©todo este seja configurado para retornar algo espec√≠fico diferente da implementa√ß√£o real.

<img height="210" align="right" src="https://github.com/user-attachments/assets/369cf343-df3c-484d-9611-10042be783e4" />

Existem boas pr√°ticas bem consolidadas no uso de *test doubles*, e as imagens refletem parte disso. A primeira mostra uma distin√ß√£o cl√°ssica: **mocks (e spies)** s√£o usados mais em **commands** (a√ß√µes que mudam estado), enquanto **stubs (stubs, dummies, fakes)** s√£o usados em **queries** (consultas que retornam dados). Essa pr√°tica vem da ideia de **Command Query Separation (CQS)**, que sugere que comandos devem ter efeitos colaterais e n√£o retornar valores, enquanto queries retornam valores mas n√£o mudam estado. Se voc√™ usa stubs para queries, voc√™ s√≥ garante dados de entrada controlados; j√° mocks para comandos te permitem verificar se uma a√ß√£o realmente ocorreu.

Na segunda imagem, vemos os test doubles categorizados em um ‚Äúuniverso‚Äù com sobreposi√ß√µes. A ideia √© refor√ßar que **Dummy, Stub, Fake, Spy e Mock** s√£o varia√ß√µes de substitutos que usamos em testes, mas cada um tem um prop√≥sito espec√≠fico. A boa pr√°tica aqui √© **usar o double mais simples poss√≠vel que resolva o problema do teste**. Por exemplo, se voc√™ s√≥ precisa preencher um par√¢metro, use um dummy. Se precisa de dados controlados, use um stub. Se quer uma implementa√ß√£o leve mas funcional (como um banco em mem√≥ria), use um fake. Se precisa verificar chamadas, use um mock. Se precisa capturar intera√ß√µes sem substituir toda a l√≥gica, use um spy. O erro comum √© usar mocks para tudo, gerando testes fr√°geis, acoplados demais ao c√≥digo interno.

Outra boa pr√°tica √© manter os doubles **pr√≥ximos do contexto do teste** e n√£o generaliz√°-los cedo demais. Doubles gen√©ricos compartilhados entre muitos testes podem virar fonte de inconsist√™ncia ou dificultar a leitura. Em TDD, por exemplo, √© comum criar o double dentro do pr√≥prio teste e s√≥ refatorar para reaproveitar se realmente houver repeti√ß√£o.

<table>
 <tr>
  <td><img width="734" height="361" alt="image_thumb_1789" src="https://github.com/user-attachments/assets/e6816068-49e9-4e62-aee1-690b4c834267" /></td>
  <td><img width="729" height="356" alt="image_thumb_2124" src="https://github.com/user-attachments/assets/a82df8dd-4b3f-444a-bbae-667bef34d27a" /></td>
  <td><img width="733" height="362" alt="image_thumb124" src="https://github.com/user-attachments/assets/56f79bdd-c770-4a02-af69-6b08a4623f24" /></td>
  <td><img width="734" height="341" alt="image_thumb789" src="https://github.com/user-attachments/assets/ed92616b-0163-4fd5-946c-a8277d867352" /></td>
  <td><img width="727" height="497" alt="image_thumbqqq" src="https://github.com/user-attachments/assets/e8328b45-74e9-49f6-9470-1c115b57d299" /></td>
 </tr>
</table>

Tamb√©m √© importante lembrar que test doubles s√£o **ferramentas para testes de unidade**, onde o isolamento √© crucial. Em testes de integra√ß√£o ou end-to-end, eles devem ser usados com cautela, pois nesses n√≠veis o objetivo √© justamente validar a intera√ß√£o real entre componentes. Usar doubles nesses contextos pode dar uma falsa sensa√ß√£o de seguran√ßa, porque o c√≥digo passa no teste, mas falha no ambiente real.

Por fim, existe uma m√°xima importante: **‚Äúdon‚Äôt mock what you don‚Äôt own‚Äù** ‚Äî ou seja, evite criar mocks para depend√™ncias externas de terceiros, como APIs de bibliotecas que voc√™ n√£o controla. Isso acopla seus testes a detalhes que podem mudar fora do seu controle. Em vez disso, prefira abstrair essas depend√™ncias atr√°s de interfaces pr√≥prias e mockar essas interfaces. Isso deixa seus testes mais est√°veis e mant√©m o acoplamento sob seu dom√≠nio.

Ou seja, as boas pr√°ticas s√£o: usar mocks para comandos e stubs para queries, escolher o double mais simples poss√≠vel para o cen√°rio, n√£o abusar de mocks em todos os lugares, restringir o uso a testes de unidade, e nunca mockar diretamente depend√™ncias externas que voc√™ n√£o controla.

<div align="center"><img alt="sociable-vs-solitary" src="https://github.com/user-attachments/assets/c355f0c9-a037-42cb-83a9-bdf46e865df5" /></div>

Pouca gente conhece bem essa distin√ß√£o, embora ela seja bem importante quando o assunto √© qualidade e isolamento de testes unit√°rios. Os termos *solitary tests* e *sociable tests* v√™m de uma classifica√ß√£o proposta por **Gerard Meszaros** no livro *xUnit Test Patterns*. A ideia √© entender como os testes unit√°rios se relacionam com outras unidades de c√≥digo e at√© que ponto o teste realmente est√° isolando a unidade sob teste (o chamado *System Under Test* ‚Äî SUT). A diferen√ßa entre sociable tests e solitary tests praticamente gira em torno de quando e como voc√™ usa test doubles.

Um ***solitary test*** √© um teste **totalmente isolado**. Ele testa **apenas uma unidade** ‚Äî geralmente uma classe, fun√ß√£o ou m√©todo ‚Äî e substitui todas as suas depend√™ncias externas por *test doubles* (como *mocks*, *stubs* ou *fakes*). Assim, o teste verifica exclusivamente o comportamento interno da unidade, sem intera√ß√µes reais com banco de dados, rede, arquivos, APIs ou outros servi√ßos. Esse tipo de teste √© o ideal quando se quer garantir **pureza e velocidade** nos testes unit√°rios, pois eles s√£o r√°pidos, previs√≠veis e n√£o dependem de contexto externo. Por exemplo: ao testar um `OrderService`, voc√™ substitui o `PaymentGateway` por um *mock* que apenas simula o comportamento esperado, sem fazer chamadas reais.

J√° um ***sociable test*** √© o oposto: ele testa uma unidade **em conjunto com suas depend√™ncias reais** ‚Äî ou ao menos com algumas delas. Em vez de isolar completamente a unidade, o teste permite que ela ‚Äúconverse‚Äù com outras classes do mesmo m√≥dulo, desde que ainda esteja dentro do escopo de uma ‚Äúunidade l√≥gica‚Äù. Por exemplo, um teste que exercita `OrderService` chamando `PaymentGateway` e `EmailNotifier` reais (ou parcialmente reais) √© soci√°vel, porque o comportamento observado depende da intera√ß√£o entre v√°rias unidades.

A diferen√ßa central est√° na **abordagem de isolamento**. O teste solit√°rio foca em verificar se a unidade funciona corretamente *sozinha*; o soci√°vel foca em verificar se ela funciona *em conjunto* com outras partes confi√°veis do sistema. Ambos s√£o considerados **testes unit√°rios**, desde que mantenham o escopo pequeno e r√°pido ‚Äî mas o solit√°rio √© mais puro e previs√≠vel, enquanto o soci√°vel tende a ser mais pr√≥ximo da realidade, embora menos determin√≠stico.

Na pr√°tica, bons conjuntos de testes costumam mesclar os dois: **solitary tests** para garantir o comportamento interno de cada componente de forma isolada e r√°pida, e **sociable tests** para verificar a integra√ß√£o leve entre partes da aplica√ß√£o que, juntas, comp√µem uma unidade funcional.

## [QA] Integration Testing
<img src="https://img.shields.io/badge/Jest-fail-%23C21325?style=flat&logo=jest&logoColor=white"> <img src="https://img.shields.io/badge/Cypress-passing-gray?style=flat&logo=Cypress&logoColor=white"> <img src="https://img.shields.io/badge/Mock-passing-chocolate?style=flat&logo=Mock&logoColor=white"> <img src="https://img.shields.io/badge/Go-passing-00ADD8?style=flat&logo=Go&logoColor=white"> <img src="https://img.shields.io/badge/PHPUnit-8.2-777BB4?style=flat&logo=PHP&logoColor=white"> <img src="https://img.shields.io/badge/-Pytest-blue?style=badge&logo=Pytest&logoColor=white"> <img src="https://img.shields.io/badge/JUnit5-passing-25A162?style=flat&logo=JUnit5&logoColor=white"> <img src="https://img.shields.io/badge/xUnit.net-8_pass_0_fail-512BD4?style=flat&logo=DotNet&logoColor=white"> ![xUnit.net](https://img.shields.io/badge/-Moq-512BD4?style=badge&logo=.NET&logoColor=white)

<a href="https://martinfowler.com/bliki/IntegrationTest.html"><img src="https://em-content.zobj.net/source/microsoft-teams/400/woman-and-man-holding-hands_1f46b.png" align="right" height="77"></a>

Os **testes de integra√ß√£o** (integration testing) s√£o de um n√≠vel mais alto, e testam a rela√ß√£o de elementos, como por exemplo um banco de dados e o software. A realiza√ß√£o destes testes √© mais lenta, afinal possuem um outro grau de complexidade. √â um teste em grupos que valida a integra√ß√£o de um sistema com outros sistemas ou banco de dados, √© feito pelo desenvolvedor para validar se existe falha de dados entre integra√ß√µes nos sistemas e se est√° com o comportamento correto.

S√£o testes que verificam se _m√≥dulos_ diferentes do sistema funcionam corretamente juntos, por exemplo: back-end + banco de dados, API + autentica√ß√£o, ou microsservi√ßos se comunicando via fila ou HTTP.

No contexto de testes de integra√ß√£o, **m√≥dulos** s√£o partes distintas de um sistema que t√™m responsabilidade pr√≥pria (ex: autentica√ß√£o, pagamentos, cadastro), podem ou n√£o ser executadas separadamente e precisam se comunicar entre si para o sistema funcionar corretamente. M√≥dulo, em testes de integra√ß√£o, se refere a qualquer parte aut√¥noma do sistema (seja uma classe, servi√ßo, camada ou microservi√ßo) que precisa se comunicar com outras partes para o sistema funcionar. Testes de integra√ß√£o s√£o o que garantem que essas partes realmente funcionam bem juntas, usando dados reais, banco de dados, APIs, filas, etc. Os testes de integra√ß√£o avaliam se a comunica√ß√£o entre esses m√≥dulos est√° funcionando como esperado.

Em testes de integra√ß√£o, m√≥dulos s√£o as **unidades de software intermedi√°rias**, partes funcionais do sistema que j√° foram testadas isoladamente (em testes de unidade) e agora precisam ser verificadas em conjunto para garantir que **interajam corretamente** umas com as outras. Em outras palavras, quando falamos em m√≥dulos, estamos nos referindo a componentes do sistema que possuem fronteiras bem definidas e trocam dados entre si, como classes, servi√ßos, APIs, reposit√≥rios, adaptadores, filas, ou at√© microservices.

<img height="177" align="right" src="https://github.com/user-attachments/assets/7a6de244-4564-4677-abdc-6f2a87551938" />

Por exemplo, imagine uma aplica√ß√£o ASP.NET Core com RabbitMQ. Voc√™ pode ter:

* Um **m√≥dulo de Producer**, respons√°vel por publicar mensagens.
* Um **m√≥dulo de Consumer**, respons√°vel por ler e processar essas mensagens.
* Um **m√≥dulo de persist√™ncia**, que grava os dados no banco.
  Cada um desses m√≥dulos pode ser testado separadamente (testes unit√°rios), mas o **teste de integra√ß√£o** se preocupa em verificar o comportamento **entre eles** ‚Äî por exemplo, se o producer realmente publica no RabbitMQ e se o consumer consome e processa corretamente a mensagem publicada.

O conceito de m√≥dulo em integra√ß√£o √© relativo: em um projeto monol√≠tico, um m√≥dulo pode ser um **conjunto de classes coesas**; em uma arquitetura de microsservi√ßos, um m√≥dulo pode ser **um servi√ßo inteiro**. O importante √© que o m√≥dulo tenha **interfaces de comunica√ß√£o claras** (como endpoints HTTP, filas, m√©todos p√∫blicos, etc.), porque os testes de integra√ß√£o se baseiam exatamente nessas fronteiras.

No fundo, o teste de integra√ß√£o responde √† pergunta: 

> ‚ÄúEsses m√≥dulos, quando combinados, ainda funcionam corretamente como um todo?‚Äù ‚Äî garantindo que o comportamento do sistema emergente seja coerente, e que os dados fluam corretamente entre as partes.

Portanto, testes de integra√ß√£o s√£o uma fase do processo de teste de software em que m√≥dulos ou componentes s√£o combinados e testados em grupo. Ela sucede o teste de unidade, em que os m√≥dulos s√£o testados individualmente, e antecede o teste de sistema, em que o sistema completo √© testado num ambiente que simula o ambiente de produ√ß√£o. Os testes de integra√ß√£o t√™m como objetivo verificar a funcionalidade e a comunica√ß√£o entre m√≥dulos. Eles s√£o projetados para identificar erros de integra√ß√£o, que s√£o erros que ocorrem quando dois ou mais m√≥dulos s√£o combinados.

Exemplo em um sistema web: Suponha que voc√™ tenha um sistema de e-commerce com:

<img height="177" align="right" src="https://github.com/user-attachments/assets/2fcdee58-77a5-42d9-a61f-9b07aab4f16c" />

- `M√≥dulo A`: Autentica√ß√£o

- `M√≥dulo B`: Cat√°logo de produtos

- `M√≥dulo C`: Carrinho de compras

- `M√≥dulo D`: Pagamento

No teste de integra√ß√£o, voc√™ testaria coisas como: 

- ‚úÖ Se um usu√°rio autenticado consegue adicionar produtos ao carrinho (A + C).

- ‚úÖ Se o sistema s√≥ libera o pagamento se os produtos forem v√°lidos (B + D).

- ‚úÖ Se o pedido final √© registrado no banco com todas as depend√™ncias funcionando (A + B + C + D).

Dependendo do contexto, m√≥dulo pode significar:

| Contexto               | O que √© o "m√≥dulo"?                                           | Exemplo pr√°tico                                           |
| ---------------------- | ------------------------------------------------------------- | --------------------------------------------------------- |
| Back-end (monolito)    | Um **componente separado** (servi√ßo, classe, camada)          | M√≥dulo de usu√°rios vs m√≥dulo de produtos                  |
| Microservi√ßos          | Um **servi√ßo inteiro** com banco pr√≥prio e API                | Servi√ßo de checkout vs servi√ßo de cat√°logo                |
| Front-end modularizado | Um conjunto de **fun√ß√µes ou hooks reutiliz√°veis**             | M√≥dulo de autentica√ß√£o + m√≥dulo de requisi√ß√µes            |
| Arquitetura em camadas | Uma **camada** da aplica√ß√£o (Controller, Service, Repository) | Controller depende do Repository funcionando corretamente |

Ent√£o, nos testes de integra√ß√£o, o objetivo √©:

- Testar a colabora√ß√£o entre m√≥dulos reais, sem mocks.
- Verificar se integra√ß√µes entre m√≥dulos distintos (por c√≥digo, HTTP, fila, banco) est√£o funcionando.
- Detectar problemas de acoplamento, depend√™ncia ou contrato entre partes do sistema.

Se voc√™ quer conhecer todas as principais ferramentas e frameworks de testes de integra√ß√£o, aqui vai um apanhado completo, organizado e atualizado, abrangendo m√∫ltiplas linguagens e stacks modernas ‚Äî incluindo ferramentas de prop√≥sito geral, espec√≠ficas para APIs, banco de dados, E2E (fim a fim), e ambientes complexos como microservi√ßos.

<img src="https://github.com/IsaacAlves7/DevSecOps/assets/61624336/fc63a3ad-8a9f-4841-bc0c-9855af158009" align="right" height="377">

**JavaScript / TypeScript**:

- **Jest** embora seja popular para testes de unidade, tamb√©m permite testes de integra√ß√£o. Suporte a mocking, spies, e `supertest` para testes de API.

- **Supertest** testa endpoints HTTP diretamente em apps Node.js/Express/Koa. Muito usado com Jest ou Mocha.

- **Mocha + Chai** flex√≠vel e modular. Excelente para testes de integra√ß√£o com `chai-http` e `supertest`.

- **Playwright / Puppeteer** usados para testes de integra√ß√£o **em aplica√ß√µes web** (navegador). Permitem verificar o fluxo do usu√°rio entre frontend e backend.

- **Vitest** suporte moderno e r√°pido a testes de integra√ß√£o com foco em performance. Alternativa moderna ao Jest com suporte a ES Modules.

Deno com `deno test` embutido no runtime. Suporte nativo a testes de integra√ß√£o (com `fetch`, banco, etc.). Test libraries auxiliares: `assert` (de `std`) e n√£o precisa de Supertest: pode usar `fetch` diretamente no servidor rodando em teste.

**Python**:

- **Pytest** um dos frameworks mais completos. Com plugins como `pytest-django`, `pytest-flask`, `pytest-asyncio`, cobre testes de integra√ß√£o completos.

- **Requests / HTTPX** combinados com `pytest`, s√£o √≥timos para testar APIs REST ou FastAPI/Flask/Django.

- **Behave / Lettuce** estilo BDD com testes de integra√ß√£o escritos em Gherkin.

**Java / Kotlin**:

- **JUnit (5+)** com Spring Boot Test: realiza testes de integra√ß√£o com o contexto da aplica√ß√£o.

- **Testcontainers** executa servi√ßos reais (como PostgreSQL, Kafka, Redis) em containers Docker nos testes.

- **RestAssured** framework fluente para testar endpoints REST em Java.

**Go**:

- **testing + httptest** padr√£o da linguagem. Cria servidores HTTP fake para testar integra√ß√£o de APIs.

- **GoConvey** framework para escrever testes BDD e de integra√ß√£o.

- **Testcontainers-Go** integra servi√ßos externos com Docker no teste (como bancos, filas, etc).

**Rust**:

- `#[tokio::test]`, `reqwest`, `warp::test` ferramentas nativas para rodar testes async com HTTP, banco etc.

- **Testcontainers-rs** similar ao de outras linguagens: banco de dados real em Docker.

**PHP**:

- **PHPUnit** com Laravel ou Symfony, permite testes de integra√ß√£o completos com banco de dados e API.

- **Codeception** espec√≠fico para testes de integra√ß√£o e E2E. Robusto e com suporte a m√∫ltiplos m√≥dulos (HTTP, DB, etc).

**Ruby**:

- **RSpec + Capybara** usado em Rails para testes de integra√ß√£o web.

- **Minitest** leve e nativo do Ruby. Com suporte a integra√ß√£o com bancos e HTTP.

Ferramentas gen√©ricas de integra√ß√£o / multi-linguagem:

- **Postman + Newman** ideal para testar APIs REST/GraphQL com fluxo, autentica√ß√£o, tokens, etc.

- **Insomnia Tests** alternativa ao Postman com foco em GraphQL e REST.

- üß™ **Cypress** (E2E com integra√ß√£o real) testa interface, mas tamb√©m valida backend real.

- üê≥ **Testcontainers** (multi-language: Java, Node, Go, Rust, .NET, etc) executa servi√ßos reais (Redis, MySQL, RabbitMQ) em Docker, durante os testes.

- **WireMock / MockServer**: Simulam servi√ßos externos para testar integra√ß√£o sem depend√™ncias reais.

- **Docker Compose** (para orquestrar m√∫ltiplos servi√ßos nos testes), muito usado para testes de integra√ß√£o entre microsservi√ßos.

Em casos especiais, testes com fila e mensageria (Kafka, RabbitMQ):

* `Testcontainers` (com RabbitMQ/Kafka)
* `docker-compose` para subir o ambiente
* Bibliotecas nativas da linguagem para consumir/produzir

Para testes de integra√ß√£o, voc√™ pode optar por:

| Categoria | Ferramentas-chave                              |
| --------- | ---------------------------------------------- |
| Node.js   | Jest + Supertest, Mocha, Vitest                |
| Deno      | `deno test` + `fetch/assert`                   |
| Python    | Pytest + HTTPX + Testcontainers                |
| Java      | JUnit + SpringBootTest + Testcontainers        |
| Multi     | Postman/Newman, Testcontainers, Docker Compose |
| E2E web   | Playwright, Cypress, Puppeteer                 |
| APIs      | RestAssured, Insomnia, HTTPX, Supertest        |

## [QA] Functional Testing
<img src="https://www.zucisystems.com/wp-content/uploads/2020/06/3-Types-of-Functional-Testing.png" height="277" align="right">

Testes de um n√≠vel ainda maior, s√£o os **functional tests**, que testam o sistema completo e garante a corre√ß√£o de funcionalidades no ponto de vista do cliente.

O que √© importante pensarmos √© no tempo de execu√ß√£o de testes que teremos. Os testes de unidade existem desde o in√≠cio do projeto, qualquer commit deveria ser acompanhada por um teste.

√â comum que o desenvolvedor que queria concluir um projeto rapidamente deixe de fazer testes para otimizar o tempo. Como resolver esse impasse? Antes do commit, devemos executar todos os testes, embora saibamos que isso √© em um plano ideal, e muitas vezes desnecess√°rio dependendo da modifica√ß√£o que foi realizada. At√© mesmo executar todos os testes unit√°rios pode ser complicado.

Uma t√©cnica comum √© executar o que chamamos de **smoke tests**. Na pr√°tica, trata-se de **uma sele√ß√£o de testes que garantem que as funcionalidades mais importantes do sistema estejam operando corretamente**. Esses testes avaliam um conjunto menor de elementos, por isso s√£o mais r√°pidos, e dessa maneira teremos a garantia de que o software est√° operante em sua estrutura b√°sica. Depois disso, podemos aplicar todos os testes e garantir uma varredura maior de erros.

Em resumo, devemos observar a categoria de cada teste; em ambientes diferentes fazer escolhas de desempenho e que melhor atendam nossa demanda; aplicar boas pr√°ticas de testes ( testes isolados, leg√≠veis, expressivos); realizar testes na parte de build e adquirir feedbacks o mais r√°pido o poss√≠vel.

## [QA] Regression testing
<img src="https://github.com/IsaacAlves7/DevSecOps/assets/61624336/8d0cb7bf-a902-4268-8633-73d0e06a2adc" align="right" height="77">

O **teste de regress√£o** √© uma t√©cnica do teste de software que consiste na aplica√ß√£o de vers√µes mais recentes do software, para garantir que n√£o surgiram novos defeitos em componentes j√° analisados. Regression testing, ou teste de regress√£o, √© um tipo de teste de software realizado para garantir que mudan√ßas recentes no c√≥digo, como corre√ß√µes de bugs, novas funcionalidades ou outras modifica√ß√µes, n√£o introduzam novos defeitos ou causem falhas em partes j√° existentes do software. Este processo √© essencial para manter a integridade do software ap√≥s qualquer tipo de altera√ß√£o. 

Em resumo, regression testing √© uma pr√°tica crucial no desenvolvimento de software que visa assegurar que novas mudan√ßas n√£o comprometam funcionalidades existentes, contribuindo para a estabilidade e qualidade cont√≠nua do sistema.

Objetivos do Regression Testing:

1. **Verificar Estabilidade**: Assegurar que as novas mudan√ßas n√£o impactaram negativamente o comportamento existente do software.

2. **Identificar Regress√µes**: Detectar rapidamente qualquer falha que possa ter sido introduzida devido a mudan√ßas recentes.

3. **Manter Qualidade**: Garantir que o software continua funcionando conforme esperado, mantendo a qualidade e a confiabilidade.

Quando Realizar Regression Testing:

- **Ap√≥s Corre√ß√µes de Bugs**: Sempre que um bug √© corrigido, √© importante garantir que a corre√ß√£o n√£o tenha introduzido novos problemas.

- **Ap√≥s Adi√ß√£o de Novas Funcionalidades**: Novas funcionalidades podem afetar o funcionamento existente, por isso testes de regress√£o s√£o necess√°rios.

- **Durante Refatora√ß√£o de C√≥digo**: A refatora√ß√£o melhora o design interno do c√≥digo, mas pode inadvertidamente introduzir erros.

- **Em Atualiza√ß√µes de Depend√™ncias**: Mudan√ßas em bibliotecas ou frameworks subjacentes podem afetar o comportamento do software.

M√©todos de Regression Testing:

1. **Reexecu√ß√£o Completa**: Executar todos os testes existentes para garantir que o software inteiro funcione corretamente. Isso √© muitas vezes impratic√°vel para grandes sistemas devido ao tempo e recursos necess√°rios.

2. **Sele√ß√£o de Casos de Teste**: Escolher um subconjunto de testes que s√£o mais relevantes para as √°reas do c√≥digo que foram alteradas.

3. **Teste de Prioridade**: Focar nos testes mais cr√≠ticos e mais propensos a serem afetados pelas mudan√ßas.

4. **Automa√ß√£o de Testes**: Usar ferramentas de automa√ß√£o para executar testes de regress√£o de forma eficiente e repet√≠vel.

Ferramentas Comuns para Regression Testing:

- **Selenium**: Para automa√ß√£o de testes de interface de usu√°rio em aplica√ß√µes web.

- **JUnit/NUnit/PyTest**: Para testes unit√°rios automatizados.

- **Jenkins/GitLab CI**: Para integra√ß√£o cont√≠nua e execu√ß√£o automatizada de testes.

- **Robot Framework**: Para testes automatizados em diversos contextos.

- **TestNG**: Para organiza√ß√£o e execu√ß√£o de testes em Java.

Benef√≠cios do Regression Testing:

- **Detec√ß√£o Precoce de Defeitos**: Permite a identifica√ß√£o e corre√ß√£o r√°pida de novos problemas.

- **Redu√ß√£o de Riscos**: Minimiza o risco de introdu√ß√£o de erros ao modificar o software.

- **Qualidade Cont√≠nua**: Mant√©m a qualidade do software ao longo de todo o ciclo de desenvolvimento.

Desafios do Regression Testing:

- **Manuten√ß√£o de Testes**: Manter um conjunto de testes atualizado pode ser desafiador √† medida que o software evolui.

- **Tempo e Recursos**: A execu√ß√£o de um grande conjunto de testes pode ser demorada e consumir muitos recursos.

- **Falsos Positivos/Negativos**: Pode haver casos onde testes falham ou passam erroneamente, exigindo investiga√ß√£o adicional.

## [QA] E2E - End-to-end
<img src="https://img.shields.io/badge/Cypress-E2E-gray?style=badge&logo=Cypress&logoColor=white"> <img src="https://img.shields.io/badge/Playwright-E2E-red?style=badge&logo=Playwright&logoColor=white"> <img src="https://img.shields.io/badge/Zod-E2E-blue?style=badge&logo=Zod&logoColor=white"> <img src="https://img.shields.io/badge/Selenium-E2E-lime?style=badge&logo=Selenium&logoColor=white"> <img src="https://img.shields.io/badge/Appium-E2E-silver?style=badge&logo=Appium&logoColor=white"> <img src="https://img.shields.io/badge/Moqups-E2E-blue?style=badge&logo=Moqups&logoColor=white"> <img src="https://img.shields.io/badge/Mural-E2E-tomato?style=badge&logo=Mural&logoColor=white">

<img src="https://github.com/IsaacAlves7/DevSecOps/assets/61624336/5c4e2a17-1197-42fb-b43a-d32d15bf5be5" align="right" height="77">

O **E2E - End-to-end** refere-se a um tipo de teste ou processo que envolve a verifica√ß√£o de um sistema ou fluxo de trabalho em sua totalidade, desde o in√≠cio at√© o fim, simulando as condi√ß√µes reais de uso pelo usu√°rio final. Em resumo, "end-to-end" se refere √† abordagem de teste que abrange todo o sistema ou processo, do in√≠cio ao fim, para garantir seu funcionamento correto e eficaz.

O E2E verifica se todos os componentes de um sistema (front-end, back-end, bancos de dados, APIs externas, etc.) funcionam juntos conforme esperado, do in√≠cio ao fim. Em um contexto de desenvolvimento de software, os testes end-to-end s√£o realizados para garantir que todas as partes do sistema estejam funcionando corretamente juntas, desde a interface do usu√°rio at√© o backend, incluindo integra√ß√µes com outros sistemas, se aplic√°vel. Isso √© feito para garantir que o sistema esteja se comportando conforme o esperado e atendendo aos requisitos do usu√°rio final.

Os testes end-to-end s√£o frequentemente usados para validar fluxos de trabalho completos em um aplicativo ou site, simulando a intera√ß√£o do usu√°rio final com o sistema. Eles podem envolver a automa√ß√£o de cliques de mouse, preenchimento de formul√°rios, navega√ß√£o entre p√°ginas e verifica√ß√£o de resultados. No entanto, a valida√ß√£o √© um conceito que se aplica a m√∫ltiplos n√≠veis de teste, incluindo o E2E, mas n√£o √© exclusiva dele. 

As principais ferramentas para testes *E2E (End-to-End)* e solu√ß√µes complementares (como Zod) para valida√ß√£o de dados, organizadas por contexto de uso:

Ferramentas Especializadas em E2E:

<img height="277" align="right" src="https://github.com/user-attachments/assets/b2033462-bc2a-46e7-bdaf-2db51a548358" />

1. **Para Aplica√ß√µes Web**  
   - **Cypress**: Framework completo para testes E2E em navegadores, com suporte a simula√ß√£o de intera√ß√µes (cliques, formul√°rios) e debug em tempo real. Inclui **Cypress Testing Library** para boas pr√°ticas de sele√ß√£o de elementos.  

   - **Playwright**: Suporta m√∫ltiplos navegadores (Chromium, Firefox, WebKit) e linguagens (JS/TS, Python, .NET). Recursos como auto-wait, grava√ß√£o de testes e testes em paralelo. O Playwright √© uma biblioteca de automa√ß√£o de c√≥digo aberto para testes de navegador e web scraping desenvolvida pela Microsoft e lan√ßada em 31 de janeiro de 2020, que desde ent√£o se tornou popular entre programadores e desenvolvedores web.

    - **Selenium**: Mais antigo, mas ainda usado em projetos legados. Requer mais configura√ß√£o (WebDriver).  

3. **Para APIs**  
   - **Supertest** (Node.js): Biblioteca para testar APIs HTTP integrada ao Jest/Mocha. Valida status codes, responses e headers.  
   - **Postman/Newman**: Cole√ß√µes de requisi√ß√µes podem ser automatizadas como testes E2E (com scripts em JavaScript).  

4. **Para Mobile**  
   - **Appium**: Framework open-source para testes E2E em aplicativos Android/iOS.  
   - **Detox**: Focado em React Native e aplica√ß√µes nativas, com suporte a sincroniza√ß√£o autom√°tica.  

5. **Para Desktop**  
   - **Spectron** (para Electron): Integra Selenium com o Electron para testar aplica√ß√µes desktop.  

Ferramentas Complementares (como Zod):

1. **Valida√ß√£o de Dados em Testes E2E**  
   - **Zod**: Valida esquemas de respostas de API ou estados da UI durante testes. Exemplo:  
       ```typescript  
       const LoginResponseSchema = z.object({ token: z.string() });  
       const data = LoginResponseSchema.parse(await response.json());  
       ```  
   - **Joi**: Similar ao Zod, mas mais usado em back-end (Node.js) para validar objetos.  

2. **Mock de Dados/APIs**  
   - **MSW (Mock Service Worker)**: Intercepta requisi√ß√µes HTTP em testes E2E para simular APIs sem depender do back-end real.  

   - **JSON Server**: Cria uma API fake baseada em um arquivo JSON para testes iniciais.  

4. **Asser√ß√µes Avan√ßadas**  
   - **Jest/Vitest**: Oferecem matchers (como `.toMatchObject()`) para validar estruturas de dados em testes.  

   - **Chai**: Biblioteca de asser√ß√µes para Mocha, com sintaxe leg√≠vel (ex.: `expect(user).to.have.property('name')`).  

6. **Monitoramento e Relat√≥rios**  
   - **Allure Report**: Gera relat√≥rios visuais detalhados de testes E2E.  

   - **Sentry**: Captura erros em tempo real durante testes (√∫til para debug em CI/CD).  

Exemplo de Fluxo com Ferramentas Combinadas

1. **Playwright** simula um usu√°rio fazendo login.  
2. **MSW** mocka a API de login (opcional).  
3. **Zod** valida se a resposta da API cont√©m `{ token: string }`.  
4. **Allure Report** gera um dashboard com os resultados.  

Quando Usar Cada Uma?

- **Testes de UI Completa**: Cypress/Playwright.  
- **APIs**: Supertest + Zod/Joi.  
- **Mobile**: Appium/Detox.  
- **Valida√ß√£o de Dados**: Zod (TypeScript) ou Joi (JavaScript).  
- **Mock**: MSW ou JSON Server.  

Essas ferramentas podem ser combinadas para cobrir todos os aspectos de testes E2E, desde a intera√ß√£o do usu√°rio at√© a integridade dos dados.

## [QA] UAT - User Acceptance Testing
<img src="https://img.shields.io/badge/Python-3.10.7-3776AB?style=flat&logo=Python&logoColor=white"> <img src="https://img.shields.io/badge/Node.js-16.17.0-339933?style=flat&logo=Node.js&logoColor=white"> <img src="https://img.shields.io/badge/Ruby-3.3-CC342D?style=flat&logo=Ruby&logoColor=white"> <img src="https://img.shields.io/badge/Go-1.21-00ADD8?style=flat&logo=Go&logoColor=white"> <img src="https://img.shields.io/badge/PHP-8.2-777BB4?style=flat&logo=PHP&logoColor=white"> <img src="https://img.shields.io/badge/C++-23-F5455C?style=flat&logo=CPlusPlus&logoColor=white"> <img src="https://img.shields.io/badge/Java-22.0.1-chocolate?style=flat&logo=OpenJDK&logoColor=white"> <img src="https://img.shields.io/badge/.NET-8.0.300-512BD4?style=flat&logo=DotNet&logoColor=white"> <img src="https://img.shields.io/badge/Rust-1.82.0-dda584?style=flat&logo=Rust&logoColor=white"> <img src="https://img.shields.io/badge/UML-diagrams-purple?style=flat&logo=UML&logoColor=white"> 

<img src="https://github.com/user-attachments/assets/280f6440-0109-4b54-98b4-f664b2e9af9b" align="right" height="77">

O **User Acceptance Testing (UAT)**, ou Teste de Aceita√ß√£o do Usu√°rio, √© uma etapa final e crucial dentro do ciclo de testes de software. Ele acontece quando o sistema j√° passou por testes internos como unit√°rios, de integra√ß√£o, funcionais e de sistema e est√° teoricamente pronto para ser colocado em produ√ß√£o. A ideia do UAT √© validar se o software realmente atende √†s necessidades do usu√°rio final e aos requisitos de neg√≥cio. Aqui, o foco n√£o √© tanto verificar se o c√≥digo funciona sem erros t√©cnicos, mas se a solu√ß√£o √© √∫til, intuitiva e cumpre aquilo que foi solicitado e esperado. Por isso, normalmente √© realizado pelos pr√≥prios usu√°rios, clientes, stakeholders ou representantes do neg√≥cio, com o suporte da equipe de QA.

Dentro do ecossistema de QA, o UAT se integra como a camada de valida√ß√£o final que coroa todo o pipeline de testes. Em um fluxo t√≠pico, o software passa por testes unit√°rios para verificar pequenos blocos de c√≥digo isolados, depois vai para testes de integra√ß√£o para garantir que os m√≥dulos funcionem em conjunto, segue para testes funcionais e de sistema que avaliam requisitos e comportamento completo, pode ainda passar por testes n√£o funcionais como performance, seguran√ßa e usabilidade. S√≥ depois desse ciclo √© que entra o UAT, pois n√£o faria sentido colocar o usu√°rio para validar algo que ainda tem falhas b√°sicas de funcionamento ou de estabilidade.

O UAT funciona quase como um ‚Äúfiltro de realidade‚Äù: ele conecta a linguagem t√©cnica do QA com a linguagem de neg√≥cio do cliente. Muitas vezes, mesmo um sistema tecnicamente correto pode falhar no UAT se n√£o atender ao fluxo real que o usu√°rio precisa seguir no dia a dia. √â comum, por exemplo, que durante o UAT se descubra que um processo est√° tecnicamente certo, mas exige muitos cliques desnecess√°rios, ou n√£o reflete a forma como o trabalho √© feito na pr√°tica. Assim, ele serve para alinhar expectativas, corrigir ajustes de usabilidade e garantir que, no momento do go-live, o software n√£o s√≥ funcione, mas tamb√©m seja aceito pelo p√∫blico a que se destina.

Em termos de QA, voc√™ pode pensar no UAT como o elo entre testes de qualidade t√©cnica e testes de valor de neg√≥cio. Ele n√£o substitui os outros, mas se apoia neles: se os testes anteriores garantem que o software √© confi√°vel, o UAT garante que ele √© √∫til e aprovado pelo cliente.

Muita gente acaba confundindo os pap√©is de **UAT, MVP, Release e Continuous Delivery**, porque todos est√£o ligados √† entrega e valida√ß√£o do software, mas cada um tem uma posi√ß√£o e fun√ß√£o distintas dentro do ciclo de desenvolvimento. Para n√£o misturar os conceitos, vale enxergar como uma sequ√™ncia natural, onde cada etapa se apoia na anterior.

O ciclo come√ßa antes mesmo do UAT, com a concep√ß√£o do **MVP (Minimum Viable Product)**. Aqui o objetivo √© construir a vers√£o m√≠nima do produto que j√° entrega valor real para o usu√°rio, mesmo que com funcionalidades limitadas. Esse MVP √© fruto de testes t√©cnicos e de neg√≥cio, mas ainda n√£o √© a vers√£o que vai para produ√ß√£o de forma plena ‚Äî ele serve como uma forma de validar hip√≥teses, ganhar feedback r√°pido e evitar investimentos pesados em algo que o usu√°rio n√£o queira.

Uma vez que o MVP esteja pronto em termos t√©cnicos, entra o *UAT (User Acceptance Testing)*. √â nessa fase que o usu√°rio final, ou representantes de neg√≥cio, testam se o que foi constru√≠do atende de fato √†s suas necessidades. √â o momento de validar se o software n√£o s√≥ funciona, mas se est√° *apto a ser aceito*. Esse ponto √© delicado: n√£o se deve liberar uma Release ou acionar um pipeline de Continuous Delivery antes de o UAT aprovar. O UAT funciona como um ‚Äúcheckpoint‚Äù de aceita√ß√£o.

Com o UAT aprovado, abre-se espa√ßo para a **Release**, que √© a entrega oficial de uma vers√£o do software. A Release pode ser do pr√≥prio MVP (caso aprovado), ou de incrementos posteriores. Aqui o software deixa o ambiente de homologa√ß√£o/teste e vai para produ√ß√£o. √â importante diferenciar: Release n√£o √© sin√¥nimo de deploy. O deploy pode ser frequente (parte do CD), mas a Release √© uma decis√£o de neg√≥cio, de colocar uma vers√£o nas m√£os do cliente com um pacote de funcionalidades definido.

O **Continuous Delivery (CD)** √© a engrenagem que sustenta tudo isso. Ele garante que o software esteja sempre em condi√ß√£o de ser liberado: builds automatizados, testes automatizados, pipelines de integra√ß√£o e entrega prontos. O CD assegura que qualquer mudan√ßa de c√≥digo possa ser validada e empacotada rapidamente para uma poss√≠vel Release, mas n√£o substitui a decis√£o de liberar, que continua dependendo de crit√©rios como UAT e estrat√©gia de produto.

O passo a passo adequado, sem bagun√ßa, pode ser entendido assim: primeiro voc√™ constr√≥i o MVP para validar hip√≥teses ‚Üí depois submete esse MVP (ou incrementos subsequentes) ao UAT para valida√ß√£o de neg√≥cio ‚Üí com o UAT aprovado, gera uma Release oficial que pode ser entregue aos usu√°rios finais ‚Üí e todo esse processo √© sustentado pelo Continuous Delivery, que d√° agilidade e confiabilidade ao ciclo.

Ou seja, MVP √© o ‚Äúo qu√™‚Äù inicial, UAT √© o ‚Äúpode ser aceito?‚Äù, Release √© o ‚Äúvai para produ√ß√£o‚Äù, e Continuous Delivery √© o ‚Äúcomo fazer isso de forma cont√≠nua e confi√°vel‚Äù.

Nos diferentes ecossistemas de linguagens, o conceito de testes de aceita√ß√£o varia bastante, mas em geral envolve frameworks que permitem validar o comportamento da aplica√ß√£o do ponto de vista do usu√°rio final, muitas vezes com suporte a **BDD (Behavior Driven Development)** ou integra√ß√£o com navegadores. Vou listar os mais conhecidos em cada um dos ecossistemas:

**C/C++** Como o foco dessas linguagens √© mais baixo n√≠vel, h√° menos ferramentas prontas para testes de aceita√ß√£o de aplica√ß√µes web. Ainda assim, existem op√ß√µes:

* **CppUnit** ‚Äì mais voltado para testes de unidade, mas pode ser usado em cen√°rios de aceita√ß√£o.
* **Cucumber-Cpp** ‚Äì integra√ß√£o do Cucumber com C++, permite escrever testes de aceita√ß√£o em Gherkin.
* **GoogleTest (gtest)** ‚Äì √© mais unit√°rio, mas com a disciplina certa pode ser usado para aceita√ß√£o.

**C# (.NET)** O ecossistema .NET tem um conjunto forte de ferramentas de testes de aceita√ß√£o:

* **SpecFlow** ‚Äì equivalente ao Cucumber, usa Gherkin para BDD.
* **Selenium WebDriver** ‚Äì para testes de aceita√ß√£o de interfaces web.
* **Playwright for .NET** ‚Äì automa√ß√£o de browsers moderna, usada tamb√©m em testes de aceita√ß√£o.
* **xBehave.net** ‚Äì extens√£o do xUnit para BDD.

**Ruby** √â um dos ecossistemas mais ricos nesse aspecto:

* **Capybara** ‚Äì padr√£o de fato em Rails para testes de aceita√ß√£o.
* **Cucumber** ‚Äì BDD com escrita em Gherkin.
* **RSpec + Capybara** ‚Äì combina√ß√£o cl√°ssica para acceptance testing.
* **Turnip** ‚Äì DSL alternativa integrada ao RSpec para cen√°rios de aceita√ß√£o.

**PHP** A comunidade PHP tem boas ferramentas para BDD e acceptance testing:

* **Behat** ‚Äì inspirado no Cucumber, usa Gherkin.
* **Codeception** ‚Äì framework poderoso que cobre testes unit√°rios, funcionais e de aceita√ß√£o.
* **Laravel Dusk** ‚Äì no ecossistema Laravel, usado para testes de aceita√ß√£o com browser automation.

**JavaScript (Node.js e frontend)** Um dos ecossistemas mais ativos em testes de aceita√ß√£o:

* **Cypress** ‚Äì muito popular para testes end-to-end e aceita√ß√£o de aplica√ß√µes web.
* **Playwright** ‚Äì concorrente moderno do Cypress, altamente est√°vel.
* **Puppeteer** ‚Äì automa√ß√£o do Chrome/Chromium, usado para acceptance testing.
* **Nightwatch.js** ‚Äì framework baseado em Selenium.
* **Jest + Testing Library (React Testing Library, por exemplo)** ‚Äì pode ser usado para acceptance em SPAs.

**Python** A comunidade Python tamb√©m √© forte em BDD e testes de aceita√ß√£o:

* **Behave** ‚Äì equivalente ao Cucumber, usa Gherkin.
* **Lettuce** ‚Äì BDD inspirado no Cucumber.
* **Robot Framework** ‚Äì muito popular para acceptance testing, com DSL pr√≥pria.
* **pytest-bdd** ‚Äì extens√£o do pytest para BDD.
* **Selenium / Playwright Python** ‚Äì para automa√ß√£o de browser em testes de aceita√ß√£o.

**Go (Golang)** Go tende a ser mais pragm√°tico, mas h√° bibliotecas para acceptance/BDD:

* **Godog** ‚Äì equivalente ao Cucumber, com Gherkin.
* **Agouti** ‚Äì para acceptance testing com integra√ß√£o a Selenium e PhantomJS.
* **Ginkgo** ‚Äì framework BDD muito usado, ainda que mais comum em unit/integra√ß√£o.

**Rust** Rust ainda est√° amadurecendo em testes de aceita√ß√£o, mas j√° h√° ferramentas:

* **Cucumber-rs** ‚Äì implementa√ß√£o do Cucumber para Rust.
* **cucumber (new)** ‚Äì projeto moderno para BDD em Rust.
* **assert\_cmd** + **predicates** ‚Äì muitas vezes usados juntos para acceptance testing de CLIs.
* **Thirtyfour** ‚Äì WebDriver client para Rust (similar ao Selenium).

**Elixir** O ecossistema Elixir tem boas ferramentas alinhadas ao Phoenix (framework web):

* **Wallaby** ‚Äì biblioteca para acceptance testing de aplica√ß√µes web com browser automation.
* **Hound** ‚Äì wrapper em Elixir para Selenium/WebDriver.
* **ExUnit + BDD-style DSLs** ‚Äì muitas vezes usado diretamente com helpers de alto n√≠vel.

Se voc√™ reparar, h√° um padr√£o: quase todos os ecossistemas t√™m algum tipo de integra√ß√£o com **Cucumber/Gherkin** para cen√°rios de aceita√ß√£o e ferramentas ligadas a **browser automation** (Selenium, Playwright, Cypress etc.), e depois cada comunidade cria bibliotecas mais idiom√°ticas para seu ambiente.

## [QA] DDD - Domain-Driven Design
<img src="https://img.shields.io/badge/Python-3.10.7-3776AB?style=flat&logo=Python&logoColor=white"> <img src="https://img.shields.io/badge/Node.js-16.17.0-339933?style=flat&logo=Node.js&logoColor=white"> <img src="https://img.shields.io/badge/Ruby-3.3-CC342D?style=flat&logo=Ruby&logoColor=white"> <img src="https://img.shields.io/badge/Go-1.21-00ADD8?style=flat&logo=Go&logoColor=white"> <img src="https://img.shields.io/badge/PHP-8.2-777BB4?style=flat&logo=PHP&logoColor=white"> <img src="https://img.shields.io/badge/C++-23-F5455C?style=flat&logo=CPlusPlus&logoColor=white"> <img src="https://img.shields.io/badge/Java-22.0.1-chocolate?style=flat&logo=OpenJDK&logoColor=white"> <img src="https://img.shields.io/badge/.NET-8.0.300-512BD4?style=flat&logo=DotNet&logoColor=white"> <img src="https://img.shields.io/badge/Rust-1.82.0-dda584?style=flat&logo=Rust&logoColor=white"> <img src="https://img.shields.io/badge/UML-diagrams-purple?style=flat&logo=UML&logoColor=white"> 

<a href=""><img src="https://em-content.zobj.net/source/microsoft-teams/363/ferris-wheel_1f3a1.png" align="right" height="77"></a>

O **DDD - Domain-Driven Design** (Projeto Orientado a Dom√≠nio) √© uma abordagem de desenvolvimento de software que se concentra em entender o **dom√≠nio do neg√≥cio** e modelar o software em torno desses conceitos e regras de neg√≥cio. √â um tipo de <a href="">modelagem de software</a> e um <a href="">design de software</a> orientado a objetos (OOP) que procura refor√ßar conceitos e boas pr√°ticas relacionadas √† OOP e surgiu como uma resposta √†s dificuldades enfrentadas por desenvolvedores ao lidarem com sistemas complexos, especialmente em dom√≠nios de neg√≥cio onde a l√≥gica e os requisitos mudam frequentemente. 

Isso vem em contrapartida com o uso comum do <a href="">Data-Driven Design</a> (Projeto Orientado a Dados), que a maioria dos desenvolvedores usa sem mesmo ter consci√™ncia disso. 

A defini√ß√£o mais simples que encontrei foi ao ler o livro Fundamentals of Software Architecture de Neal Ford e Mark Richards:

> O design orientado a dom√≠nio (DDD) √© uma t√©cnica de modelagem que permite a decomposi√ß√£o organizada de dom√≠nios de problemas complexos. - Neal Ford e Mark Richards. Fundamentos da Arquitetura de Software. 2020.

O objetivo do DDD √©, em primeiro lugar, adquirir conhecimento sobre o problema para identificar a solu√ß√£o. Em seguida, concordaremos com os v√°rios componentes desta solu√ß√£o para implement√°-la. Esse objetivo √© alcan√ßado por meio dos padr√µes fundamentais do DDD: padr√µes estrat√©gicos e t√°ticos. Os padr√µes estrat√©gicos respondem √† pergunta: "Por que estamos construindo este software e quais s√£o seus componentes?". Por outro lado, os padr√µes t√°ticos d√£o a resposta √† pergunta: "Como esses componentes s√£o implementados?"

Em seu livro Clean Architecture: A Craftsman's Guide to Software Structure and Design, Uncle Bob chama uma arquitetura que informa ao leitor sobre o sistema, n√£o as estruturas usadas no sistema, de "Arquitetura Gritante".

Ent√£o, faz sentido para mim pensar em design de software como design gritante quando fala alto e claro sobre o dom√≠nio do problema. Geralmente, o ativo mais cr√≠tico no design de uma solu√ß√£o √© adquirir conhecimento sobre os problemas que estamos tentando resolver, o processo que queremos automatizar ou as dificuldades que queremos facilitar. Ent√£o, para nos aproximarmos da solu√ß√£o, t√≠nhamos que j√° estar pr√≥ximos do problema.

Falaremos sobre a maneira de se aproximar do problema e da solu√ß√£o: o caminho do Domain-Driven Design (DDD) em dire√ß√£o a um design gritante, o design que informa ao leitor sobre o dom√≠nio do neg√≥cio, n√£o sobre os frameworks usados.

O DDD (Domain-Driven Design) entra no fluxo do desenvolvimento de produto antes do MVP, como um alicerce. Ele n√£o √© um artefato de entrega como MVP, UAT ou Release, mas sim uma abordagem de modelagem que orienta como o software deve ser desenhado para refletir o dom√≠nio do problema.

Se voc√™ pensar em sequ√™ncia, o fluxo ficaria assim:

1. **DDD ‚Äì Domain-Driven Design**: Aqui voc√™ faz a imers√£o no dom√≠nio de neg√≥cio, conversa com especialistas e stakeholders, descobre a linguagem ub√≠qua e modela o sistema em termos que fa√ßam sentido para o neg√≥cio. √â nessa etapa que surgem conceitos como entidades, agregados, bounded contexts e eventos de dom√≠nio. O objetivo √© garantir que a estrutura do software nas√ßa aderente √† realidade que ele pretende resolver.

2. **MVP ‚Äì Minimum Viable Product**: Uma vez que o dom√≠nio esteja bem modelado, voc√™ constr√≥i o MVP. Esse MVP j√° se beneficia do DDD, porque mesmo sendo m√≠nimo, ele est√° fundamentado em um design que respeita a linguagem e as regras do neg√≥cio. Isso evita que o MVP vire um ‚Äúprot√≥tipo descart√°vel‚Äù e aumenta a chance de evoluir para produto de verdade.

3. **QA interno** ‚Üí **UAT** ‚Üí **Release** ‚Üí **Continuous Delivery**: Depois disso, o fluxo segue normalmente como te expliquei antes.

Ent√£o, se o MVP √© o ‚Äúprimeiro produto que entrega valor real‚Äù, o **DDD √© o mapa que garante que esse valor seja o certo**, modelando desde o in√≠cio com consist√™ncia e vis√£o de futuro. Sem o DDD, corre-se o risco de o MVP ser feito de qualquer jeito e depois ser dif√≠cil ou custoso de evoluir.

<img width="720" height="267" alt="image" src="https://github.com/user-attachments/assets/cc8dad6f-afc7-4b1b-8ebd-30df9b57b557" />

O DDD nos permite planejar uma arquitetura de microsservi√ßos decompondo o sistema maior em unidades independentes, compreendendo as responsabilidades de cada uma e identificando seus relacionamentos, ele n√£o √© um design pattern espec√≠fico, mas sim uma importante abordagem de design de software, com foco na modelagem de software para corresponder a um **dom√≠nio** de acordo com as informa√ß√µes dos especialistas desse dom√≠nio. O Domain-Driven Design (DDD) surgiu como uma metodologia revolucion√°ria para a modelagem de software, desenvolvida com o intuito de refinar e otimizar a correspond√™ncia entre o design do software e o dom√≠nio do software e o dom√≠nio do problema que ele busca resolver.

> Os microsservi√ßos s√£o a forma mais escal√°vel de desenvolver software. Mas voc√™ precisa de um bom design que permita que as equipes de desenvolvedores trabalhem de forma aut√¥noma e implementem sem atrapalhar umas √†s outras, caso contr√°rio, voc√™ perder√° os benef√≠cios de escalabilidade. O DDD ajuda a delimitar responsabilidades claras entre os servi√ßos, o que permite que equipes atuem de forma independente e coordenada.

Embora o design orientado a dom√≠nio (DDD) exista desde 2004, o conceito n√£o foi capaz de se espalhar excessivamente em todo esse tempo. Nos √∫ltimos anos, no entanto, o termo experimentou uma segunda primavera. Portanto, √© hora de perguntar o que √© design orientado a dom√≠nio.

O desenvolvimento de software n√£o √© um fim em si mesmo. Em vez disso, o software √© desenvolvido para resolver problemas t√©cnicos do mundo real. Isso requer tecnologia, mas esse n√£o √© o foco, √© apenas um meio para um fim. O foco real est√° no assunto (o dom√≠nio)! Portanto, uma boa compreens√£o disso √© essencial para um desenvolvimento bem-sucedido e direcionado.

A exig√™ncia de construir um entendimento profissional tamb√©m se aplica aos desenvolvedores. Uma boa compreens√£o do assunto (dom√≠nio) surge da comunica√ß√£o regular e de uma linguagem comum, o que representa um desafio, principalmente em equipes interdisciplinares: Afinal, cada disciplina tem sua linguagem t√©cnica, por isso os mal-entendidos s√£o inevit√°veis.

Eric Evans cunhou o termo Domain-Driven Design (DDD) como parte do t√≠tulo de seu livro de 2004, Domain-Driven Design: Tackling Complexity in the Heart of Software.

<a href=""><img src="https://github.com/user-attachments/assets/47723806-ab10-490c-844f-6c5e8980e08f" align="right" height="177"></a>

> [!Important]
> Foi popularizado por Eric Evans em seu livro **Domain-Driven Design: Tackling Complexity in the Heart of Software**, publicado em 2003. Esse livro n√£o √© leve, especialmente se voc√™ ainda est√° no in√≠cio da jornada. Ele exige uma certa base em desenvolvimento orientado a objetos (OOP), arquitetura de software e experi√™ncia pr√°tica com projetos reais. Geralmente, ele √© mais proveitoso depois que voc√™ j√° trabalhou em sistemas mais complexos ou com arquitetura em camadas.

A ideia central √© trazer o dom√≠nio (o sujeito, a raz√£o) √† tona...O DDD acaba aparecendo muito em code reviews (revis√µes de c√≥digo) porque ele n√£o √© s√≥ um conjunto de padr√µes t√©cnicos, mas uma maneira de organizar o racioc√≠nio e o design do sistema a partir do dom√≠nio de neg√≥cio. Diferente de TDD e BDD, que s√£o mais voltados ao como testar e como validar comportamento, o DDD toca no como estruturar o c√≥digo para refletir a realidade do problema que a aplica√ß√£o resolve.

Num code review, o time n√£o est√° apenas olhando se o c√≥digo ‚Äúfunciona‚Äù, mas se ele est√° leg√≠vel, sustent√°vel e alinhado ao dom√≠nio. √â a√≠ que DDD se torna um guia. Por exemplo, quando voc√™ define entidades e value objects, o revisor consegue avaliar se voc√™ est√° representando o dom√≠nio corretamente ou se misturou regras de neg√≥cio com detalhes de infraestrutura. Se voc√™ trabalha com bounded contexts, o code review ajuda a garantir que cada m√≥dulo est√° respeitando suas fronteiras e n√£o est√° acoplando responsabilidades que deveriam estar separadas. E quando se usa a linguagem ub√≠qua, qualquer pessoa envolvida no projeto pode bater o olho no c√≥digo e identificar termos familiares do neg√≥cio, reduzindo ambiguidades.

Isso muda o tom da revis√£o: em vez de ser s√≥ ‚Äúesse m√©todo est√° mal nomeado‚Äù ou ‚Äúesse if pode virar um switch‚Äù, passa a ser ‚Äúessa entidade realmente pertence a este contexto?‚Äù ou ‚Äúessa regra deveria estar no dom√≠nio ou no servi√ßo de aplica√ß√£o?‚Äù. S√£o discuss√µes de mais alto n√≠vel, que evitam d√≠vida t√©cnica e fortalecem a coer√™ncia do sistema. Por isso, times que adotam DDD costumam ter code reviews mais ricos, que n√£o param na forma, mas questionam se a ess√™ncia do c√≥digo est√° fiel ao problema que ele resolve.

Sem levar em conta o DDD, as **t√©cnicas de modelagem de dom√≠nio** s√£o m√©todos utilizados na engenharia de software para compreender e representar o dom√≠nio de um problema espec√≠fico. O dom√≠nio refere-se √† √°rea de conhecimento, contexto ou setor de neg√≥cios em que o software est√° sendo desenvolvido. A modelagem de dom√≠nio tem como objetivo capturar os conceitos, regras e relacionamentos do dom√≠nio em um formato compreens√≠vel e utiliz√°vel pelos desenvolvedores. Ent√£o, o DDD (Domain-Driven Design) √© uma abordagem para o desenvolvimento de software que combina conceitos de design de software e t√©cnicas de modelagem de dom√≠nio. N√£o √© considerado um design pattern espec√≠fico, mas sim uma abordagem geral para projetar e estruturar sistemas de software. Domain-Driven Design (DDD) √© um m√©todo de design de software em que os desenvolvedores constroem modelos para entender os requisitos de neg√≥cios de um dom√≠nio. Esses modelos servem como base conceitual para o desenvolvimento de software.

No entanto, suas ra√≠zes v√™m de pr√°ticas e ideias que estavam sendo discutidas na ind√∫stria desde os anos 1990. Durante esse per√≠odo, muitas empresas estavam adotando metodologias √°geis e enfrentando problemas ao construir sistemas que n√£o apenas funcionassem, mas que tamb√©m fossem f√°ceis de entender, modificar e expandir. Um dos grandes desafios era a chamada "lacuna sem√¢ntica" entre os especialistas de dom√≠nio (pessoas que entendem o neg√≥cio) e os desenvolvedores (que implementam solu√ß√µes t√©cnicas). Essa lacuna frequentemente levava a softwares que funcionavam de forma errada ou que eram dif√≠ceis de adaptar a mudan√ßas nos requisitos.

A ideia inicial do DDD √© voltar √† uma modelagem OO mais pura, por assim dizer. Devemos esquecer de como os dados s√£o persistidos e nos preocupar em como representar melhor as necessidades de neg√≥cio em classes e comportamentos (m√©todos). Isso significa que em DDD um `Cliente` pode n√£o ter um *setter* para os seus atributos comuns, mas pode ter m√©todos com l√≥gica de neg√≥cio que neste dom√≠nio de neg√≥cio pertencem ao `cliente`, como `void associarNovoCartao(Cartao)` ou `Conta recuperarInformacoesConta()`. Em resumo, as classes modeladas e os seus m√©todos deveriam representar o neg√≥cio da empresa, usando inclusive a mesma nomenclatura. A persist√™ncia dos dados √© colocada em segundo plano, sendo apenas uma camada complementar.

O DDD nasceu da necessidade de aproximar esses dois mundos. Eric Evans observou que o software bem-sucedido em contextos complexos era constru√≠do em torno de um **modelo de dom√≠nio** que capturava com precis√£o o conhecimento do neg√≥cio. Ele tamb√©m percebeu que os sistemas mais sustent√°veis utilizavam linguagens comuns entre especialistas e desenvolvedores, al√©m de t√©cnicas para isolar a complexidade e tornar o c√≥digo mais alinhado com as regras do dom√≠nio.

Com a evolu√ß√£o do desenvolvimento de softwares e no aumento da complexidade dos requisitos da aplica√ß√£o, √© extremamente relevante definirmos uma comunica√ß√£o clara entre as v√°rias partes envolvidas em um projeto de software. √â bastante comum haver conflitos entre os termos t√©cnicos utilizados pelas diferentes √°reas, seja entre analistas de neg√≥cios, desenvolvedores, especialistas financeiros ou de vendas. Nada mais natural haja visto que as equipes est√£o cada vez mais multidisciplinares. Para auxiliar em uma comunica√ß√£o fluida, os conceitos do DDD ‚Äî Domain Driven Design, prop√µem como um dos seus pilares a defini√ß√£o de uma _Linguagem Ub√≠qua_.

<a href=""><img src="https://github.com/user-attachments/assets/4873d674-b778-448b-a311-26f9307e624f"></a>

O DDD formalizou essas pr√°ticas ao introduzir conceitos como **Ubiquitous Language** (Linguagem Ub√≠qua), o cerne do DDD, que promove a cria√ß√£o de uma linguagem compartilhada entre todas as partes interessadas, e **Bounded Contexts** (Contextos Limitados), que ajudam a dividir sistemas grandes e complexos em partes menores e mais compreens√≠veis. Al√©m disso, o DDD trouxe aten√ß√£o para padr√µes arquiteturais que d√£o suporte ao dom√≠nio, como **Entidades** (Entity), **Agregados** (), **Reposit√≥rios** () e **Servi√ßos de Dom√≠nio** (), estabelecendo um design centrado na l√≥gica de neg√≥cios em vez de nas tecnologias subjacentes.

Para que possamos iniciar uma compreens√£o acerca de Linguagem Ub√≠qua (Ubiquitous Language), podemos nos valer da an√°lise sem√¢ntica do termo ub√≠quo: `u-b√≠-quo` (latim _ubiquus_, -a, -um), adjetivo:

- Que est√° ao mesmo tempo em toda a parte. = `ONIPRESENTE`
- Que tem dom da ubiquidade. = `ONIPRESENTE`
- Que est√° difundido em todo o lado. = `GERAL, UNIVERSAL`.

De forma conceitual, a linguagem ub√≠qua √© o conjunto de termos e inter-rela√ß√µes que fornecem a sem√¢ntica da comunica√ß√£o do dom√≠nio, que reflete a vis√£o do neg√≥cio. E de forma pr√°tica, ao se trabalhar com DDD, entende-se como comunica√ß√£o de mesma linguagem, em um √∫nico modelo, de forma que todos os envolvidos no projeto tenham a mesma compreens√£o acerca dos termos utilizados. Linguagem ub√≠qua pode parecer um termo complexo de se compreender, mas outro termo tamb√©m utilizado para identificar este tipo de comunica√ß√£o, nos auxilia em uma melhor compreens√£o: _Linguagem Onipresente_.

**Linguagem Onipresente** √© essencialmente os termos, palavras e defini√ß√µes utilizadas por todo o dom√≠nio do projeto. √â o idioma utilizado no cotidiano da empresa, as terminologias da realidade do neg√≥cio. Quando um projeto n√£o respeita a **linguagem do dom√≠nio** diversos problemas de comunica√ß√£o surgem, dificultando o desenvolvimento, implanta√ß√£o e sustenta√ß√£o da solu√ß√£o.

Quando termos utilizados no projeto v√£o sendo traduzidos, de acordo com o uso em cada departamento, a comunica√ß√£o se torna an√™mica e a assimila√ß√£o do conhecimento disperso. Em seu livro Domain Driven Design ‚Äî Atacando as Complexidades no Cora√ß√£o do Software, Eric Evans descreve de maneira clara esta problem√°tica:

> O custo de toda a tradu√ß√£o, al√©m do risco de entendimento errado, √© simplesmente muito alto. Um projeto precisa de uma linguagem em comum que seja mais robusta que o m√≠nimo denominador comum.

<a href=""><img src="https://github.com/user-attachments/assets/5ac09617-ba80-4f3f-955a-62bd9dfe77ee" align="right" height="77"></a>

A Linguagem Onipresente (ubiquitous language) n√£o est√° limitada a diagramas em <a href="">UML (Unified Modeling Languages, ou Linguagem de Modelagem Unificada)</a>, mas principalmente, define em seu vocabul√°rio nome das classes e opera√ß√µes de destaque. Inclui regras para implantar um dicion√°rio uniforme e expl√≠cito para o modelo, para que o mesmo possa ser utilizado com o m√°ximo de efici√™ncia poss√≠vel.

O **Diagram as code** (Diagrama como c√≥digo) √© uma abordagem de cria√ß√£o de diagramas que utiliza c√≥digo, em vez de ferramentas gr√°ficas, para desenhar e manter diagramas. Essa abordagem permite que os diagramas sejam criados e atualizados utilizando linguagens de programa√ß√£o ou marcadores, em vez de ferramentas de desenho gr√°fico. A pr√°tica de "Diagram as code" (Diagrama como c√≥digo) pode auxiliar no Domain-Driven Design (DDD), pois √© uma pr√°tica √∫til no DDD que ajuda a manter a documenta√ß√£o atualizada, facilita a colabora√ß√£o, fornece controle de vers√£o e permite a gera√ß√£o autom√°tica de diagramas. Vantagens do "Diagram as code" no DDD:

1. **Melhor documenta√ß√£o**: Com o "Diagram as code", voc√™ pode manter a documenta√ß√£o do seu modelo de dom√≠nio atualizada e sincronizada com o c√≥digo. Isso ajuda a garantir que a documenta√ß√£o seja precisa e refletida nas mudan√ßas no c√≥digo.
2. **Modelagem colaborativa**: O "Diagram as code" permite que os membros da equipe colaborativamente trabalhem no modelo de dom√≠nio, tornando mais f√°cil para os desenvolvedores, especialistas em dom√≠nio e outros stakeholders discutirem e refinarem o modelo.
3. **Vers√£o e controle**: Com o "Diagram as code", voc√™ pode usar sistemas de controle de vers√£o (como Git) para rastrear as altera√ß√µes no modelo de dom√≠nio. Isso ajuda a garantir que todas as altera√ß√µes sejam documentadas e possam ser revertidas se necess√°rio.
4. **Gera√ß√£o autom√°tica de diagramas**: Muitas ferramentas de "Diagram as code" permitem que voc√™ gere diagramas automaticamente a partir do c√≥digo. Isso pode economizar tempo e reduzir a chance de erros manuais.
5. **Integra√ß√£o com o ciclo de desenvolvimento**: O "Diagram as code" pode ser integrado ao ciclo de desenvolvimento de software, permitindo que os desenvolvedores trabalhem no modelo de dom√≠nio em paralelo com o desenvolvimento do c√≥digo.

As ferramentas permitem que voc√™ crie diagramas como c√≥digo, utilizando sintaxes espec√≠ficas para desenhar os diagramas. Em seguida, elas geram imagens ou diagramas a partir do c√≥digo. Algumas ferramentas populares para "Diagram as code" incluem:

<a href="https://www.plantuml.com/plantuml/uml/SyfFKj2rKt3CoKnELR1Io4ZDoSa700003"><img src="https://github.com/user-attachments/assets/cd3deff0-176a-4d9b-8735-0a1b2b1d2a33" align="right" height="77"></a>

- Mermaid
- **PlantUML**
- Graphviz
- C4 (abordagem de modelagem de software)

Normalmente os especialistas de um dom√≠nio, diretores, administradores, analistas, t√©cnicos, possuem pouca familiaridade com o jarg√£o t√©cnico utilizado no desenvolvimento de software, mas utilizam os jarg√µes pr√≥prios de sua √°rea de atua√ß√£o. A partir desta realidade, os especialistas de um dom√≠nio descrevem superficialmente o que necessitam, fazendo com que desenvolvedores criem abstra√ß√µes que sustentem o design da aplica√ß√£o. Com isso, uma compreens√£o uniforme vai se deteriorando exponencialmente.

<a href="https://www.plantuml.com/plantuml/uml/SyfFKj2rKt3CoKnELR1Io4ZDoSa700003"><img src="https://github.com/user-attachments/assets/d51f18a5-193c-49ef-8a83-83f42f1924f5" align="right" height="277"></a>

Como solu√ß√£o a esta dispers√£o na comunica√ß√£o, devemos usar a linguagem baseada no modelo de forma exaustiva at√© que a comunica√ß√£o seja fluida e compreens√≠vel entre os diversos setores envolvidos no projeto. Para que possamos alcan√ßar esta flu√™ncia, os especialistas do dom√≠nio devem vetar termos ou estruturas que n√£o transmitam uma compreens√£o clara acerca das funcionalidades envolvidas; os desenvolvedores devem se empenhar no cuidado com ambiguidades ou inconsist√™ncias que possam corromper o modelo proposto. Ou seja, √© um esfor√ßo conjunto entre todos os envolvidos, mas, √© essencialmente necess√°rio que ocorra.

Como identificar os especialistas de dom√≠nio? Especialistas de dom√≠nio s√£o os profissionais envolvidos no dia a dia da opera√ß√£o, nos mais diferentes setores, ou seja, s√£o os ‚Äúconhecedores‚Äù do neg√≥cio (stakeholders). Normalmente estes especialistas s√£o analistas, t√©cnicos, engenheiros, podendo ser todo aquele que possui a compreens√£o acerca do fluxo de opera√ß√£o da empresa. Os especialistas de dom√≠nio det√©m o conhecimento sobre as necessidades e requisitos necess√°rios para o processamento das atividades organizacionais.

<img src="https://github.com/user-attachments/assets/3e5b0f4e-5517-4b6d-a8a8-cd650c6f577d" align="right" height="277">

Em ess√™ncia, o DDD surgiu para enfrentar a complexidade inerente ao desenvolvimento de software em dom√≠nios desafiadores, permitindo que os sistemas sejam projetados de forma que o c√≥digo seja uma express√£o direta das regras e processos do neg√≥cio. Com o tempo, o DDD ganhou popularidade e passou a ser usado em diversos contextos, especialmente em sistemas corporativos onde o dom√≠nio de neg√≥cio √© complexo e sujeito a constantes mudan√ßas.

Para o sucesso de um projeto de software, o DDD sugere que tanto especialistas de dom√≠nio quanto desenvolvedores devem falar a mesma l√≠ngua.

A figura acima, ilustra a exist√™ncia de termos que s√≥ os especialistas de dom√≠nio conhecem e apresentam express√µes somente de car√°ter tecnol√≥gico, os quais s√£o de uso apenas do time de desenvolvimento. Contudo, √© necess√°rio que exista um conjunto de termos que devem ser de conhecimento universal, no que se refere ao dom√≠nio da aplica√ß√£o, formando a Linguagem Ub√≠qua do sistema. A defini√ß√£o de uma linguagem onipresente objetiva principalmente dois prop√≥sitos:

- Possibilitar uma comunica√ß√£o fluida entre os membros de equipes multidisciplinares; Nomear elementos do c√≥digo da aplica√ß√£o, como classes, m√©todos, vari√°veis, fun√ß√µes, m√≥dulos, tabelas de bancos de dados, rotas de APIs, etc.

- Ademais a padroniza√ß√£o na comunica√ß√£o prop√µe elucidar o significado dos termos, de um forma simples, objetiva e compreens√≠vel para facilitar os relacionamentos e associa√ß√µes entre todos m√≥dulos necess√°rios.

Qualquer pessoa t√©cnica contribuindo para o modelo deve programar, pelo menos tocar no c√≥digo, independente do papel desempenhado no projeto. Um respons√°vel por mudar o c√≥digo deve sempre aprender a expressar o modelo atrav√©s do c√≥digo. Todo desenvolvedor deve estar envolvido na discuss√£o sobre o modelo e ter contato com os especialistas do dom√≠nio. (EVANS, 2016).

Em seu livro Implementando Domain Driven Design, Vaughn Vernon, pontua que um especialista de dom√≠nio tem uma forte influ√™ncia sobre a linguagem utilizada, devido ao maior conhecimento acerca do neg√≥cio, que no final √© o contexto imperativo de todo projeto. Estes especialistas tendem a ser influenciados pelos padr√µes da ind√∫stria, contudo, uma linguagem universal deve ser centrada em como o pr√≥prio neg√≥cio pensa e opera. Ou seja, cada empresa possui seu pr√≥prio dom√≠nio acerca da execu√ß√£o de seus processos.

N√£o entenda Linguagem Ub√≠qua como um conjunto de jarg√µes de neg√≥cios sendo impostos ao time de desenvolvimento, e nem mesmo uma sobreposi√ß√£o de termos t√©cnicos sobre o contexto de neg√≥cio, mas sim, uma linguagem real que √© criada por toda a equipe e que √© propagada por toda a corpora√ß√£o.

Compreende-se que haver√° discord√¢ncias em rela√ß√£o aos termos utilizados e que est√£o na mente dos especialistas, mas, a partir do uso aberto da linguagem, a evolu√ß√£o √© natural e consolidada por este processo de matura√ß√£o da comunica√ß√£o.

O DDD enfatiza a compreens√£o profunda do dom√≠nio do problema e o uso de uma linguagem ub√≠qua compartilhada entre as equipes de desenvolvimento e especialistas do dom√≠nio. Ele prop√µe a organiza√ß√£o do c√≥digo em torno do dom√≠nio do problema, separando-o dos detalhes t√©cnicos e infraestrutura. 

Embora o DDD n√£o seja um design pattern em si, ele pode ser combinado com v√°rios design patterns e princ√≠pios de design, como Agregado, Reposit√≥rio, Especifica√ß√£o, Event Sourcing, entre outros. O DDD fornece diretrizes e conceitos para ajudar na cria√ß√£o de uma arquitetura de software robusta e flex√≠vel.

Portanto, podemos dizer que o DDD √© uma abordagem de design e uma metodologia de modelagem que pode ser aplicada em diferentes arquiteturas de software, como arquitetura em camadas, arquitetura hexagonal, arquitetura de microsservi√ßos, entre outras. Ele fornece princ√≠pios e pr√°ticas para projetar e estruturar o c√≥digo em torno do dom√≠nio do problema, visando um modelo de dom√≠nio rico, desacoplamento e flexibilidade.

√â uma abordagem mais ampla para o design de software que abrange v√°rios conceitos e t√©cnicas. DDD enfatiza a modelagem do dom√≠nio, a colabora√ß√£o entre especialistas do dom√≠nio e desenvolvedores, e a cria√ß√£o de um c√≥digo baseado em um entendimento profundo do dom√≠nio do problema.

No contexto do DDD, existem design patterns espec√≠ficos que s√£o frequentemente utilizados para ajudar a implementar os conceitos e princ√≠pios do DDD. Alguns desses padr√µes incluem:

<a href=""><img src="https://github.com/IsaacAlves7/DevSecOps/assets/61624336/0ade6281-cdca-47d3-8b95-57e81b61d04a" align="right" height="377"></a>

1. <a href="">Agregado</a>: Se refere a um padr√£o de design que agrupa um conjunto de objetos relacionados em uma √∫nica unidade coesa. O Agregado √© uma das principais constru√ß√µes utilizadas para modelar e organizar o dom√≠nio em DDD;

2. <a href="">Reposit√≥rio</a>: Fornece uma interface para acessar cole√ß√µes de objetos agregados, permitindo que o dom√≠nio permane√ßa livre de preocupa√ß√µes com persist√™ncia. Ele atua como uma camada intermedi√°ria entre o dom√≠nio e a fonte de dados (como bancos de dados).

3. <a href="">Servi√ßo de Dom√≠nio</a>: Representa opera√ß√µes ou a√ß√µes do dom√≠nio que n√£o pertencem naturalmente a uma √∫nica entidade ou value object. Encapsula l√≥gica de neg√≥cio que depende de m√∫ltiplos objetos.

4. <a href="">Value Object</a>: Objetos que n√£o possuem identidade pr√≥pria e s√£o definidos apenas por seus atributos. S√£o imut√°veis e usados para representar conceitos como dinheiro, coordenadas ou medidas.

5. <a href="">Entidade</a>: Objetos do dom√≠nio que possuem identidade pr√≥pria (geralmente um ID) e um ciclo de vida distinto. Diferente de value objects, entidades podem mudar seus atributos ao longo do tempo.

6. <a href="">Factory</a>: Padr√£o respons√°vel por encapsular a l√≥gica de cria√ß√£o complexa de objetos, especialmente agregados. Evita a polui√ß√£o do construtor com l√≥gica de montagem de objetos.

7. <a href="">Especifica√ß√£o</a>: Define regras de neg√≥cio reutiliz√°veis e combin√°veis para verificar se um objeto atende a determinados crit√©rios. √â √∫til para separa√ß√£o de responsabilidades e clareza das regras de dom√≠nio.

8. <a href="">Event Sourcing</a>: T√©cnica onde o estado do sistema √© determinado por uma sequ√™ncia de eventos (ao inv√©s de snapshots de dados). Permite reconstruir o estado do sistema e ter um hist√≥rico detalhado das mudan√ßas.

9. <a href="">Inje√ß√£o de Depend√™ncia (DI - Dependency Injection)</a>: T√©cnica que permite desacoplar componentes do sistema, facilitando testes, manuten√ß√£o e extensibilidade. No DDD, √© comum para injetar reposit√≥rios, servi√ßos de dom√≠nio e unidades de trabalho nos agregados e servi√ßos de aplica√ß√£o.

Esses padr√µes, juntamente com outros conceitos e t√©cnicas, podem ser aplicados para construir uma arquitetura que segue os princ√≠pios do DDD. O DDD, portanto, n√£o √© um design pattern em si, mas uma abordagem que pode ser implementada usando diversos padr√µes de design espec√≠ficos.

<img width="2250" height="2840" alt="unnamed" src="https://github.com/user-attachments/assets/c7b24ba8-f883-4fcf-a89b-6b864209ccd4" />

Quando n√£o usar DDD? √Äs vezes s√≥ √© necess√°rio um CRUD! DDD n√£o √© uma solu√ß√£o para tudo. A maioria dos sistemas possui uma boa parte composta por cadastros b√°sicos (CRUD) e n√£o seria adequado usar DDD para isso.

O DDD deve ajudar na modelagem das classes mais importantes e mais centrais do sistema de forma e diminuir a complexidade e ajudar na manuten√ß√£o das mesmas, afinal este √© o objetivo dos princ√≠pios de orienta√ß√£o a objetos.

Outro ponto √© sobre n√≥s desenvolvedores estarmos compartilhando dados com outros sistemas, as rotinas de integra√ß√£o que recebem ou disponibilizam dados para outros sistemas n√£o devem ser "inteligentes". Muitos desenvolvedores acabam modelando suas classes de neg√≥cios tentando resolver as quest√µes internas do sistema e, ao mesmo tempo, pensando em como essas classes ser√£o expostas para outros sistemas. Padr√µes como DTO (Data Transfer Object) que usam objetos "burros" s√£o mais adequados para isso.

Portanto, o DDD n√£o tenta resolver todos os problemas de todas as camadas de um sistema. Seu foco √© na modelagem das entidades principais de neg√≥cio usando a linguagem adequada daquele dom√≠nio para facilitar a manuten√ß√£o, extens√£o e entendimento. Particularmente, eu n√£o seguiria √† risca o padr√£o, at√© porque existem in√∫meros padr√µes e varia√ß√µes de modelagem OO. Estude os princ√≠pios por detr√°s desses padr√µes, pois eles s√£o geralmente parecidos e veja o que funciona melhor para cada projeto.

A maioria dos softwares n√£o quebra por causa de erros de sintaxe ou l√≥gica if-else falha.

Ele quebra porque as equipes perdem o alinhamento com o problema de neg√≥cios que deveriam resolver. Os sistemas se emaranham com suposi√ß√µes t√©cnicas que envelhecem mal. Os recursos s√£o implementados sem considera√ß√µes de design adequadas. E com o tempo, cada novo requisito cria mais problemas que continuam se acumulando.

Muitas vezes, isso n√£o √© um problema de ferramentas. √â um problema de modelagem.

O DDD (Design Controlado por Dom√≠nio) tenta resolver esse problema de frente. Em sua ess√™ncia, o DDD √© uma maneira de projetar software que mant√©m o dom√≠nio de neg√≥cios, n√£o o esquema de banco de dados ou a estrutura mais recente, no centro da tomada de decis√µes. Ele insiste que os engenheiros colaborem profundamente com especialistas de dom√≠nio durante o ciclo de vida do projeto, n√£o apenas para reunir requisitos uma vez e desaparecer nos tickets do Jira. Ele fornece √†s equipes o vocabul√°rio, os padr√µes e os limites para modelar sistemas complexos sem serem enterrados na complexidade acidental.

Claro, o DDD n√£o √© uma bala de prata. Ele n√£o gera c√≥digo e n√£o conserta magicamente um mon√≥lito legado. Mas oferece algo mais valioso a longo prazo: clareza sobre o que o sistema deve fazer e onde pode mudar.

Essa abordagem se torna especialmente valiosa quando:

- O dom√≠nio n√£o √© trivial e continua evoluindo. Pense em finan√ßas, sa√∫de, log√≠stica ou mercados gigantes.
- V√°rias equipes est√£o trabalhando em partes sobrepostas do sistema.
- O c√≥digo precisa refletir o comportamento do mundo real, n√£o constru√ß√µes t√©cnicas abstratas.

O DDD n√£o se importa se a arquitetura √© monol√≠tica ou baseada em microsservi√ßos. O que importa √© se o modelo reflete as regras e a linguagem do mundo real do dom√≠nio e se esse modelo pode evoluir com seguran√ßa √† medida que o dom√≠nio muda.

Exploramos as ideias centrais do DDD (como Contextos Limitados, Agregados e Linguagem Ub√≠qua) e explicamos como eles funcionam juntos na pr√°tica. Tamb√©m veremos como o DDD se encaixa nos sistemas do mundo real, onde ele brilha e onde pode falhar.

<table>
 <tr>
  <td><img src="https://github.com/user-attachments/assets/40876f04-b257-4eca-a7b0-72af3adc66a6" height="777" /></td>
  <td><img src="https://github.com/user-attachments/assets/6f12e517-635b-4959-ac10-0d1c2af6aa25" height="777" /></td>
 </tr>
</table>

**DDD - Segrega√ß√£o de Responsabilidade de Consulta de Comando (CQRS)** os comandos s√£o complexos, as consultas s√£o simples, anteriormente, examinamos as Entidades DDD, que t√™m **estado**, e **Eventos**, onde o estado muda. Para reduzir a complexidade, podemos ser espec√≠ficos sobre o que tem estado e encapsular onde ele muda. Os eventos s√£o c√≥digos de alto n√≠vel, situados no meio da Onion Architecture. Veremos como os comandos de n√≠vel inferior vinculam a interface do usu√°rio ou a API a eventos para permitir que os usu√°rios alterem o estado.

Os eventos de dom√≠nio existem no centro de dom√≠nio de alto n√≠vel de um diagrama Onion Architecture, coberto por Robert C. Martin em Clean Architecture. A camada externa da cebola cont√©m detalhes de baixo n√≠vel, entradas e sa√≠das, como armazenamento, interfaces de usu√°rio e APIs. Os comandos est√£o em algum lugar no meio, vinculando as entradas ao dom√≠nio de n√≠vel superior para que os usu√°rios possam acionar os eventos para alterar o estado.

<img width="720" height="313" alt="image" src="https://github.com/user-attachments/assets/2ed856b3-baf7-49f2-bf70-c4d3c52e17f2" />

Para que um usu√°rio interaja com um sistema e para que ele seja √∫til, precisamos ser capazes de fazer duas coisas. A primeira √© exibir informa√ß√µes para o usu√°rio.

O Clean Architecture (CA) √© a diretriz de arquitetura de sistemas proposta por Robert C. Martin (Uncle Bob) derivada de muitas diretrizes arquitet√¥nicas como Hexagonal Architecture e Onion Architecture, entre outras.

Eric Evans introduziu o conceito de Domain-Driven Design (DDD). Ele escreveu sobre isso em seu livro Domain-driven Design em 2004 (tamb√©m conhecido como "The Big Blue Book").

O Design Orientado a Dom√≠nio √© uma abordagem para o desenvolvimento de software que centra o desenvolvimento na programa√ß√£o de um modelo de dom√≠nio com uma rica compreens√£o dos processos e regras de um dom√≠nio.

Comecei com minha equipe na Taager.com a adotar o Domain-Driven Design (DDD) em nosso trabalho, e nossa miss√£o era tirar o m√°ximo proveito do DDD e do CA, se poss√≠vel. √Ä medida que a ado√ß√£o cresce, estamos cada vez mais perto do neg√≥cio e do dom√≠nio que estamos abordando; come√ßamos a falar a linguagem onipresente do dom√≠nio. Este artigo √© um excelente come√ßo para obter mais conhecimento sobre DDD.

> [!Note]
> N√£o existe tal arquitetura que sirva para todos. Toda arquitetura ou padr√£o de desenvolvimento de software tem pr√≥s e contras; Baseie sua decis√£o no projeto, no escopo e na equipe. Vamos descrever o caminho que tomamos.

Este artigo se concentrar√° em como estruturamos o c√≥digo de acordo com DDD e Clean Architecture, para que o c√≥digo tamb√©m fale a linguagem onipresente do dom√≠nio com mais facilidade.

Primeiro, dividimos o sistema em partes independentes menores em torno dos subdom√≠nios de neg√≥cios por meio de algumas itera√ß√µes (ferramentas <a href="https://vaadin.com/blog/ddd-part-1-strategic-domain-driven-design">estrat√©gicas de DDD</a>, como tempestade de eventos, narrativa e muito mais). Idealmente, essas partes devem ser implant√°veis de forma independente (microsservi√ßos), mas nem sempre √© esse o caso. Muitas vezes, podemos ter um c√≥digo legado que n√£o podemos alterar facilmente, ent√£o temos que mant√™-lo por um tempo. Nesses casos, temos esses subdom√≠nios em um √∫nico projeto (mon√≥lito), com cada subdom√≠nio em uma pasta ou pacote separado.

**Estrutura de c√≥digo de contexto limitado**: Depois de dividir o dom√≠nio extenso em partes menores, tamb√©m chamadas de subdom√≠nios. Em seguida, tentamos resolver cada subdom√≠nio; Um "contexto limitado" implementar√° um subdom√≠nio. Cada contexto limitado pode ser um microsservi√ßo separado ou um pacote separado que encapsula esse contexto limitado dentro de um servi√ßo atual. Ent√£o, vamos falar sobre essa parte agora, como projetamos cada contexto limitado, quantas camadas de alto n√≠vel temos e como elas se comunicariam juntas.

Exemplos de contextos limitados em um sistema de com√©rcio eletr√¥nico

```txt
‚îú‚îÄ‚îÄ‚îÄwallet       
‚îú‚îÄ‚îÄ‚îÄorderManagement
‚îú‚îÄ‚îÄ‚îÄshipping  
‚îú‚îÄ‚îÄ‚îÄ..
```

## [QA] TDD - Test-Driven Development 
![Jest](https://img.shields.io/badge/-Jest-EF2D5E?style=badge&logo=jest&logoColor=white)
![Mocha](https://img.shields.io/badge/-Mocha-EF2D5E?style=badge&logo=mocha&logoColor=white)
![JUnit5](https://img.shields.io/badge/-JUnit5-EF2D5E?style=badge&logo=JUnit5&logoColor=white) 
![xUnit](https://img.shields.io/badge/-xUnit-EF2D5E?style=badge&logo=.NET&logoColor=white) 
![Jest](https://img.shields.io/badge/-Jest-00D564?style=badge&logo=jest&logoColor=white)
![Mocha](https://img.shields.io/badge/-Mocha-00D564?style=badge&logo=mocha&logoColor=white)
![JUnit5](https://img.shields.io/badge/-JUnit5-00D564?style=badge&logo=JUnit5&logoColor=white) 
![Jest](https://img.shields.io/badge/-Jest-FFDF6F?style=badge&logo=jest&logoColor=black)
![Mocha](https://img.shields.io/badge/-Mocha-FFDF6F?style=badge&logo=mocha&logoColor=black)
![JUnit5](https://img.shields.io/badge/-JUnit5-FFDF6F?style=badge&logo=JUnit5&logoColor=black) 
![JUnit5](https://img.shields.io/badge/-xUnit-FFDF6F?style=badge&logo=.NET&logoColor=black) 

<img src="https://github.com/IsaacAlves7/DevSecOps/assets/61624336/555d9d87-5698-46e3-b39f-713da277205e" align="right" height="77">

O **TDD - Test-Driven Development**, ou em portugu√™s "Desenvolvimento guiado por testes" ou Desenvolvimento Orientado a testes ou Desenvolvimento digirido por testes, √© uma t√©cnica de desenvolvimento de software que se relaciona com o conceito de verifica√ß√£o e valida√ß√£o e se baseia em um ciclo curto de repeti√ß√µes: Primeiramente o desenvolvedor escreve um caso de teste automatizado que define uma melhoria desejada ou uma nova funcionalidade. Logo, √© produzido c√≥digo que possa ser validado pelo teste para posteriormente o c√≥digo ser refatorado para um c√≥digo sob padr√µes aceit√°veis. 

Basicamente, ela ajuda a aumentar a produtividade a partir de testes j√° consolidados. O TDD (Test-Driven Development) foca em um tipo espec√≠fico de teste chamado <a href="">teste de unidade</a>. No entanto, ele pode influenciar outros tipos de testes durante o ciclo de desenvolvimento.

Kent Beck, considerado o criador ou o 'descobridor' da t√©cnica, declarou em 2003 que TDD encoraja designs de c√≥digo simples e inspira confian√ßa. Desenvolvimento dirigido por testes √© relacionado a conceitos de programa√ß√£o de <a href="">XP - Extreme Programming</a>, iniciado em 1999, mas recentemente tem-se criado maior interesse pela mesma em fun√ß√£o de seus pr√≥prios ideais. Atrav√©s de TDD, programadores podem aplicar o conceito de melhorar e depurar c√≥digo legado desenvolvido a partir de t√©cnicas antigas.

> O TDD √© considerado uma t√©cnica ou metodologia, muito adotada nos times de desenvolvimento. Isso porque ele √© direcionado ao desenvolvimento de softwares. Contudo, pelo fato de inverter a ordem dos trabalhos ‚Äì do teste para o c√≥digo ‚Äì √© um pouco impopular entre os Devs. No entanto, ap√≥s pegar o jeito, o desenvolvimento ganha um up, e a t√©cnica traz muitos resultados positivos ao projeto.

<img src="https://github.com/user-attachments/assets/08e14244-2f2f-42eb-8e9f-049efca12ce5" align="right" height="177">

> [!Important]
> O livro **Test-Driven Development: By Example** do Kent Beck, √© considerado a obra fundamental sobre TDD (Test-Driven Development). Ele √© importante por alguns motivos hist√≥ricos e pr√°ticos. Primeiro, porque o Kent Beck foi um dos criadores originais do TDD como pr√°tica estruturada dentro do movimento Extreme Programming (XP) e um dos autores do Manifesto √Ågil. Ou seja, ele n√£o s√≥ ajudou a popularizar o conceito, como tamb√©m foi quem deu a forma mais clara e pr√°tica para sua aplica√ß√£o. Segundo, porque esse livro √© did√°tico e pr√°tico: Beck explica a ideia de TDD usando exemplos pequenos, progressivos e reais. Ele mostra o famoso ciclo do TDD ‚Äî Red, Green, Refactor ‚Äî de maneira muito detalhada, quase como se estivesse pair programming com o leitor. Ele come√ßa com problemas bem simples, como implementar uma calculadora de dinheiro com opera√ß√µes b√°sicas, e vai aumentando a complexidade, at√© chegar em casos mais sofisticados.

O TDD segue a l√≥gica do ciclo: Red, Green e Refactor. Este ciclo √© uma abordagem estruturada para escrever e melhorar c√≥digo de software de maneira incremental, garantindo que ele seja test√°vel, funcional e de alta qualidade. Aqui est√° uma explica√ß√£o detalhada de cada fase do ciclo:

<img src="https://github.com/IsaacAlves7/DevSecOps/assets/61624336/63318aff-ad59-4c3e-b858-172ec4154f85" align="right" height="277">

üî¥ **Red**: Escreva um teste que apresenta erros, que falhe. A√ß√£o: voc√™ come√ßa escrevendo um teste automatizado para a funcionalidade que deseja implementar. Este teste √© baseado nos requisitos e especifica√ß√µes do que o c√≥digo deve fazer. Resultado: O teste falha, pois a funcionalidade ainda n√£o foi implementada. A falha confirma que o teste √© v√°lido e que a funcionalidade n√£o existe no momento.

üü¢ **Green**: Logo ap√≥s, escreva um c√≥digo que passe no teste, que funcione e fa√ßa o teste passar. A√ß√£o: Escrever a quantidade m√≠nima de c√≥digo necess√°rio para fazer o teste passar. Nesta fase, o foco est√° em implementar a funcionalidade de maneira r√°pida e simples, sem se preocupar muito com a qualidade ou eleg√¢ncia do c√≥digo. Resultado: O teste passa, indicando que a funcionalidade b√°sica foi implementada corretamente.

üü° **Refactor**: Depois disso, "refatorar" o que foi feito, ou seja, eliminar a redund√¢ncia e melhorar a qualidade do c√≥digo, ou seja, melhorar e otimizar o c√≥digo sem alterar sua funcionalidade, mantendo todos os testes passando. A√ß√£o: Refatorar o c√≥digo escrito na fase anterior para torn√°-lo mais limpo com princ√≠pios de <a href="">C√≥digo Limpo (Clean Code)</a>, eficiente e f√°cil de manter. Isso pode incluir a remo√ß√£o de duplica√ß√µes, melhoria da legibilidade, e conformidade com padr√µes de design. Resultado: O c√≥digo √© melhorado sem alterar seu comportamento externo. Os testes (novos e antigos) continuam passando, garantindo que a funcionalidade permanece correta ap√≥s as melhorias. 

A **Refatora√ß√£o** √© o processo de reestruturar o c√≥digo de um software para melhorar sua qualidade interna, sem alterar seu comportamento externo. A principal finalidade da refatora√ß√£o √© tornar o c√≥digo mais limpo, leg√≠vel, e f√°cil de manter, otimizando aspectos como desempenho, organiza√ß√£o e modularidade. 

Ela costuma envolver a remo√ß√£o de duplica√ß√£o de c√≥digo, simplifica√ß√£o de estruturas complexas, e melhoria na nomenclatura de vari√°veis, classes e fun√ß√µes, al√©m de aplicar padr√µes de design e princ√≠pios como o <a href="">SOLID</a>. 

Refatorar tamb√©m ajuda a prevenir a "d√≠vida t√©cnica", que ocorre quando decis√µes de design ou implementa√ß√£o apressadas criam problemas futuros. Em metodologias √°geis, a refatora√ß√£o √© geralmente integrada ao processo de desenvolvimento cont√≠nuo, sendo realizada entre ciclos de implementa√ß√£o de novas funcionalidades. Portanto, a refatora√ß√£o se encaixa como uma pr√°tica regular dentro da fase de desenvolvimento, especificamente na etapa de Integra√ß√£o Cont√≠nua (CI), que foca na qualidade do c√≥digo e na automa√ß√£o de testes.

<img src="https://github.com/user-attachments/assets/620b69eb-5d3b-4339-ad75-7d4dc78839d1" align="right" height="177">

> [!Important]
> Por mais de vinte anos, programadores experientes no mundo inteiro contaram com o livro **Refatora√ß√£o: Aperfei√ßoando o Design de C√≥digos Existentes** de Martin Fowler para aperfei√ßoar o design de c√≥digos existentes e melhorar a manutenibilidade do software, assim como para deixar o c√≥digo existente mais f√°cil de entender. Essa nova edi√ß√£o ansiosamente esperada foi atualizada por completo para refletir mudan√ßas vitais no dom√≠nio da programa√ß√£o. Refatora√ß√£o 2¬™ edi√ß√£o cont√©m um cat√°logo atualizado das refatora√ß√µes e inclui exemplos de c√≥digo JavaScript bem como novos exemplos funcionais que demonstram a refatora√ß√£o sem classes. Assim como na edi√ß√£o original, este livro explica o que √© refatora√ß√£o, por que voc√™ deve refatorar, como reorganizar um c√≥digo que precise de refatora√ß√£o e como fazer isso de forma bem-sucedida, independentemente da linguagem usada. Para aperfei√ßoar o design de c√≥digos existentes e melhorar a manutenibilidade de software, assim como para deixar o c√≥digo existente mais f√°cil de entender.

Ap√≥s ler este livro, voc√™ ser√° capaz de:

<img src="https://github.com/user-attachments/assets/77f87103-de9e-49e9-85d2-b29a8ed47608" align="right" height="277">

- Entenda o processo e os princ√≠pios b√°sicos da refatora√ß√£o;
- Aplique rapidamente refatora√ß√µes convenientes para deixar um programa mais f√°cil de entender e de alterar;
- Reconhe√ßa ‚Äúmaus cheiros‚Äù no c√≥digo que sinalizam oportunidades para refatorar;
- Explore as refatora√ß√µes, cada uma com suas explica√ß√µes, a motiva√ß√£o, o mecanismo e exemplos simples;
- Escreva testes robustos para suas refatora√ß√µes;
- Reconhe√ßa as contrapartidas e os obst√°culos para a refatora√ß√£o.

O Desenvolvimento dirigido por testes requer dos desenvolvedores criar testes automatizados que definam requisitos em c√≥digo antes de escrever o c√≥digo da aplica√ß√£o. Os testes cont√©m asser√ß√µes que podem ser verdadeiras ou falsas. Ap√≥s as mesmas serem consideradas verdadeiras ap√≥s sua execu√ß√£o, os testes confirmam o comportamento correto, permitindo os desenvolvedores evoluir e refatorar o c√≥digo. Normalmente todos os testes s√£o efetuados de forma continua de acordo com o desenvolvimento cada funcionalidade criada deve ser acompanhada de um teste bem descrito e projetado, ent√£o deve-se escolher a √°rea do projeto ou requisitos da tarefa para melhor orientar o desenvolvimento destes testes.

Desenvolvedores normalmente usam frameworks de testes, como **xUnit**, para criar e executar automaticamente uma s√©rie de casos de teste.

> As empresas esperam que seus colaboradores sejam realmente muito bons em testes unit√°rios e a melhor forma de garantir isso √© pedindo TDD. Muitas pessoas aprendem testes de forma muito superficial, mas um profissional que j√° praticou TDD em alguma codebase real tem uma vantagem sobre os outros, pois j√° enfrentou diversos problemas e sabe como contorn√°-los.

<img src="https://caelum-online-public.s3.amazonaws.com/1629+-+integracao_continua/03/3_1_1_design.png" height="177" align="right">

Os testes em integra√ß√£o cont√≠nua s√£o sobre **feedback do software**, como a maioria dos m√©todos √°geis. Feedback √© o ponto chave para um desenvolvimento com qualidade, seja ele a n√≠vel t√©cnico, de gest√£o ou pessoal. O Feedback √© o ponto chave para um desenvolvimento com qualidade, seja ele a n√≠vel t√©cnico, de gest√£o ou pessoal.

Bom, muito provavelmente n√£o fui eu quem inventou o nome Ciclo de Feedback para desenvolvimento de Software mas estou adicionando o guiado a Testes. Legal mas o que isso quer dizer? Quer dizer que, quando trabalhando no desenvolvimento de uma tarefa qualquer, que seja guiada a testes, n√≥s temos que trabalhar em cima do feedback que os testes nos trazem e n√£o com o pensamento de que temos apenas que codar a `feature` e adicionar testes para garanti-las. Realizar uma tarefa guiada a testes com esse pensamento √© disperdi√ßar boa parte do potencial da abordagem do TDD.

![tdd,bdd,ddd](https://github.com/user-attachments/assets/999df44a-f250-4287-b80c-e7725401d917)

Ent√£o, o TDD, BDD e DDD s√£o tr√™s abordagens diferentes que se complementam no desenvolvimento de software. O **TDD (Test-Driven Development)** √© uma pr√°tica focada no ciclo de escrita de testes antes da implementa√ß√£o do c√≥digo. A ideia central √© escrever primeiro um teste que falha porque a funcionalidade ainda n√£o existe, depois escrever o c√≥digo m√≠nimo necess√°rio para faz√™-lo passar e, em seguida, refatorar para manter a qualidade. Esse ciclo de ‚Äúred, green, refactor‚Äù garante que o sistema nas√ßa j√° com testes cobrindo a funcionalidade, evita sobrecarga de bugs e mant√©m o design do c√≥digo limpo e orientado ao que realmente precisa ser implementado. Com o tempo, voc√™ ganha confian√ßa para refatorar e evoluir a aplica√ß√£o porque sabe que os testes automatizados garantem que nada quebrou.

J√° o **BDD (Behavior-Driven Development)** nasceu como uma evolu√ß√£o do TDD, com foco maior na comunica√ß√£o entre time de neg√≥cios e desenvolvimento. A ideia √© descrever o comportamento esperado do sistema em linguagem natural, geralmente em formato de cen√°rios (‚ÄúDado que‚Äù, ‚ÄúQuando‚Äù, ‚ÄúEnt√£o‚Äù), o que torna os testes leg√≠veis at√© para quem n√£o programa. Isso aproxima desenvolvedores, QA, product owners e at√© clientes, porque todos falam a mesma l√≠ngua sobre o que o software deve fazer. Enquanto o TDD guia o c√≥digo a partir de testes t√©cnicos, o BDD guia o c√≥digo a partir do comportamento esperado do usu√°rio ou do neg√≥cio, trazendo clareza e diminuindo ambiguidades nos requisitos.

O **DDD (Domain-Driven Design)**, por sua vez, √© mais abrangente, √© uma forma de estruturar todo o sistema a partir do dom√≠nio de neg√≥cio. O ponto central √© que o design da aplica√ß√£o deve emergir do entendimento profundo do problema que se quer resolver, criando um modelo de dom√≠nio claro, organizado e rico, que reflete a realidade do neg√≥cio. DDD traz conceitos como entidades, agregados, value objects, bounded contexts e ubiquitous language, para garantir que o c√≥digo represente fielmente as regras do dom√≠nio e que diferentes partes do sistema conversem de forma coerente. Ele n√£o √© uma t√©cnica de testes como TDD ou BDD, mas sim uma filosofia arquitetural que ajuda a manter a complexidade sob controle e tornar o software mais alinhado √†s necessidades reais do neg√≥cio. Por isso, o DDD √© amplamente adotado em Code Reviews.

Quando voc√™ junta as tr√™s abordagens, tem um fluxo bastante poderoso: o DDD te ajuda a entender e modelar corretamente o dom√≠nio; o BDD garante que os comportamentos mais importantes estejam claros e validados com o neg√≥cio; e o TDD d√° a base t√©cnica para implementar cada parte com qualidade e seguran√ßa. Assim, voc√™ cobre desde a concep√ß√£o do sistema at√© a implementa√ß√£o e os testes, reduzindo riscos, aumentando a clareza e facilitando a manuten√ß√£o e evolu√ß√£o ao longo do tempo.

Esse diagrama mostra o **ciclo do TDD** expandido para al√©m do ‚Äúred-green-refactor‚Äù cl√°ssico, conectando os diferentes n√≠veis de testes (caixa preta, cinza e branca) dentro do ciclo de desenvolvimento. Destrinchando o que ele est√° representando:

<img width="1200" height="635" alt="Test-driven-development-cycle-Cybus-Nordic-APIs" src="https://github.com/user-attachments/assets/c1a8a96e-1c48-4152-95e3-003afbdcd210" />

√Ä esquerda, temos a **Black Box**, que √© onde entram os **testes de aceita√ß√£o**. Eles validam se o sistema, como um todo, faz o que o usu√°rio ou o neg√≥cio espera. √â aqui que entra aquele ‚ÄúDado‚ÄìQuando‚ÄìEnt√£o‚Äù do BDD, por exemplo. 

1. Esse √© o primeiro passo (1): escrever o teste de aceita√ß√£o que vai falhar porque o sistema ainda n√£o implementa a funcionalidade.

2. Na sequ√™ncia (2), entra a parte de **testes funcionais**, ainda numa vis√£o de alto n√≠vel. Eles descrevem como cada funcionalidade deve se comportar dentro do sistema. √â a ponte entre aceita√ß√£o e c√≥digo.

3.4 Indo para a direita, temos a **White Box**, com **testes unit√°rios**. Esse √© o n√∫cleo do TDD cl√°ssico: para cada pequena parte do c√≥digo (fun√ß√£o, m√©todo, classe), voc√™ escreve um teste que falha (3), implementa o c√≥digo m√≠nimo para passar (4) e depois refatora (ciclo interno de unidade).

5. Depois de escrever e passar os testes unit√°rios, voc√™ volta para os **testes funcionais** (5), garantindo que aquela unidade est√° contribuindo corretamente para o comportamento esperado.

6. Daqui em diante, surgem os **testes de integra√ß√£o** (6), que validam se as diferentes partes do sistema trabalham bem juntas (por exemplo, se um servi√ßo conversa com outro via API, se a camada de aplica√ß√£o integra corretamente com o banco).

6.7 Os testes funcionais e de integra√ß√£o se retroalimentam (6 e 7), porque quando voc√™ conecta m√≥dulos, √© comum ajustar tanto o comportamento funcional quanto a integra√ß√£o.

8. Por fim, quando tudo isso passa, voc√™ retorna para os **testes de aceita√ß√£o** (8). Se eles agora passam, significa que o sistema como um todo est√° atendendo ao que foi pedido. Se ainda falham, o ciclo recome√ßa at√© que os crit√©rios de aceita√ß√£o estejam cumpridos.

Resumindo: o ciclo mostra que o TDD n√£o vive s√≥ no n√≠vel unit√°rio (teste‚Äìc√≥digo‚Äìrefatora), mas pode ser entendido como um **encadeamento de ciclos em diferentes camadas**: come√ßa com aceita√ß√£o (vis√£o do usu√°rio), vai para funcional (vis√£o do sistema), integra√ß√µes (m√≥dulos se falando) e finalmente unidades (blocos de c√≥digo). √â um processo iterativo que desce do mais abstrato at√© o mais concreto e depois sobe de volta, validando em todos os n√≠veis.

## [QA] BDD - Behavior-Driven Development
![Cucumber](https://img.shields.io/badge/-Cucumber-23D96C?style=badge&logo=cucumber&logoColor=white) ![Behave](https://img.shields.io/badge/-Behave-00D564?style=Behave&logo=Python&logoColor=white) ![Specflow](https://img.shields.io/badge/-Specflow-00D564?style=badge&logo=.NET&logoColor=white) ![Speculate](https://img.shields.io/badge/-Speculate-00D564?style=badge&logo=Rust&logoColor=white) ![Mocha](https://img.shields.io/badge/-Mocha-00D564?style=badge&logo=Mocha&logoColor=white) ![Chai](https://img.shields.io/badge/-Chai-00D564?style=badge&logo=Chai&logoColor=white) ![Jest](https://img.shields.io/badge/-Jest-00D564?style=badge&logo=Jest&logoColor=white) ![Sinon](https://img.shields.io/badge/-Sinon-00D564?style=badge&logo=Node.js&logoColor=white) ![Gherkin](https://img.shields.io/badge/-Gherkin-00D564?style=badge&logo=Gherkin&logoColor=white) ![Gherkin](https://img.shields.io/badge/-Gherkin-00D564?style=badge&logo=Gherkin&logoColor=white) ![Gherkin](https://img.shields.io/badge/-Gherkin-00D564?style=badge&logo=Gherkin&logoColor=white) 

<img src="https://github.com/user-attachments/assets/51f4d9a0-47ce-49a9-baeb-f8b9d4c15b3e" align="right" height="77">

O **BDD - Behavior-Driven Development** (Desenvolvimento Orientado a Comportamento), √© uma metodologia de desenvolvimento √°gil que tem como foco a colabora√ß√£o entre desenvolvedores, QA (Quality Assurance) e partes interessadas n√£o t√©cnicas para criar uma compreens√£o compartilhada do comportamento desejado de um software. O BDD √© uma evolu√ß√£o do TDD (Test-Driven Development) e adiciona uma √™nfase maior na comunica√ß√£o e na clareza dos requisitos.

Em resumo, o BDD promove uma abordagem colaborativa para o desenvolvimento de software, focando em comportamentos e resultados esperados do sistema, o que ajuda a garantir que o software entregue atenda √†s necessidades reais dos usu√°rios e stakeholders.

Aqui est√£o os componentes chave do BDD:

<img height="177" align="right" src="https://github.com/user-attachments/assets/1886b145-5f12-4bc5-b096-fe3d0849e991" />

1. **Foco no Comportamento**: Em vez de se concentrar apenas na implementa√ß√£o t√©cnica e nos testes de unidade, o BDD foca em como o software deve se comportar sob v√°rias condi√ß√µes, incluindo o comportamento do usu√°rio final.

2. **Linguagem Ub√≠qua (Ubiquitous Language)**: Utiliza uma linguagem comum (frequentemente baseada em linguagens naturais como o ingl√™s) que pode ser compreendida por todos os membros da equipe, incluindo desenvolvedores, QA, e stakeholders n√£o t√©cnicos. Isso ajuda a reduzir ambiguidades e garantir que todos tenham a mesma compreens√£o dos requisitos. A Linguagem Ub√≠qua (Ubiquitous Language) √© um conceito central no <a href="">Design Orientado a Dom√≠nio (DDD)</a> que visa criar uma linguagem comum entre todos os envolvidos em um projeto, seja para os especialistas no dom√≠nio, desenvolvedores, ou mesmo os usu√°rios finais. Essa linguagem comum facilita a comunica√ß√£o e colabora√ß√£o, reduzindo a possibilidade de mal-entendidos e melhorando a qualidade do desenvolvimento. 

3. **Especifica√ß√µes Execut√°veis**: No BDD, os requisitos s√£o escritos em forma de especifica√ß√µes que podem ser executadas como testes. Essas especifica√ß√µes geralmente seguem um formato estruturado, como <a href="">Gherkin</a> que √© uma linguagem de dom√≠nio espec√≠fico usada para descrever comportamentos esperados de um sistema de forma clara e compreens√≠vel por todos os envolvidos no desenvolvimento de software, incluindo pessoas n√£o t√©cnicas, que usa palavras-chave como "`Given`" (Dado), "`When`" (Quando), e "`Then`" (Ent√£o) para descrever cen√°rios de teste:

   - `Given` (Dado): Descreve o contexto inicial ou o estado do sistema antes de uma a√ß√£o espec√≠fica.

   - `When` (Quando): Descreve a a√ß√£o ou evento que ocorre.

   - `Then` (Ent√£o): Descreve o resultado esperado ou o comportamento do sistema ap√≥s a a√ß√£o.

Exemplo: Login no Sistema

[![Login.feature](https://img.shields.io/badge/-Login.feature-pink?style=social&logo=googledocs&logoColor=purple)](#)

```gherkin
Feature: Login no Sistema

Scenario: Login com credenciais v√°lidas
  Given: o usu√°rio est√° na p√°gina de login
  When: o usu√°rio insere suas credenciais v√°lidas
  Then: o usu√°rio √© redirecionado para a p√°gina inicial
```

Exemplo 2: Pesquisar produto

[![Pesquisar.feature](https://img.shields.io/badge/-Pesquisar.feature-pink?style=social&logo=googledocs&logoColor=purple)](#)

```gherkin
Funcionalidade: Pesquisar produto
  Eu como cliente
  Quero fazer pesquisas no site da OLX
  Para buscar por produtos

Cen√°rio: Buscar produto com sucesso
  Dado que estou no site da OLX como um comprador de SP
  Quando eu fizer uma busca por um produto
  Ent√£o ser√£o exibidos os resultados de busca para o produto em SP
```

5. **Ferramentas de BDD**: Existem v√°rias ferramentas que suportam BDD, ajudando a automatizar as especifica√ß√µes execut√°veis. Algumas das ferramentas populares incluem <a href="">Cucumber</a> (para v√°rias linguagens como Java, Ruby), <a href="">SpecFlow</a> (para .NET), <a href="">Behave</a> (para Python), entre outras.

<img src="https://github.com/IsaacAlves7/DevSecOps/assets/61624336/93228869-20dc-414f-b89e-4ae549ac96b4" align="right" height="277">

5. **Benef√≠cios do BDD**: Uma das maiores virtudes do BDD - Behavior-Driven Development √© unir os dois mundos TDD e DDD, de fato √© representar uma interse√ß√£o entre TDD (Test-Driven Development) e DDD (Domain-Driven Design), pois ele nasce da necessidade de alinhar o desenvolvimento t√©cnico com o entendimento do neg√≥cio, garantindo que o software reflita o comportamento esperado do sistema a partir da perspectiva do usu√°rio ou dom√≠nio. BDD pode ser visto como a interse√ß√£o onde a clareza de inten√ß√£o do dom√≠nio (trazida pelo DDD) se encontra com a pr√°tica de testar antes de desenvolver (como prop√µe o TDD).

   - **Melhor Comunica√ß√£o**: Facilita a comunica√ß√£o entre todos os membros da equipe, garantindo que todos entendam os requisitos de maneira clara e compartilhada.

   - **Desenvolvimento Orientado a Valor**: Foca no que realmente importa para os usu√°rios finais e stakeholders, ajudando a priorizar o desenvolvimento de funcionalidades de maior valor.

   - **Menos Retrabalho**: Reduz ambiguidades nos requisitos, diminuindo o risco de desenvolvimento de funcionalidades incorretas ou desnecess√°rias.

   - **Documenta√ß√£o Viva**: As especifica√ß√µes atuam como uma documenta√ß√£o viva que est√° sempre em sincronia com o comportamento atual do sistema.

## [QA] ATDD - Acceptance Test-Driven Development
<img src="https://github.com/user-attachments/assets/dcf5ece6-9b99-4a82-aca2-4af7351d944a" align="right" height="277">

O **ATDD - Acceptance Test-Driven Development** √© uma pr√°tica e uma varia√ß√£o do desenvolvimento orientado a testes (TDD) que coloca o **teste de aceita√ß√£o** como ponto central do ciclo. Enquanto no TDD tradicional o desenvolvedor escreve primeiro testes unit√°rios para depois implementar o c√≥digo que os satisfaz, no ATTD o processo come√ßa com a defini√ß√£o dos testes de aceita√ß√£o, geralmente descritos em linguagem mais pr√≥xima do neg√≥cio, representando os crit√©rios que o sistema precisa cumprir para ser aceito pelo cliente ou pelo usu√°rio final.

A ideia √© alinhar desde o in√≠cio o que ser√° constru√≠do com o que realmente tem valor para o neg√≥cio. Os testes de aceita√ß√£o funcionam como especifica√ß√µes execut√°veis: descrevem cen√°rios, entradas, sa√≠das e comportamentos esperados do sistema em termos que os stakeholders entendem. Depois disso, os desenvolvedores implementam o c√≥digo necess√°rio para fazer esses testes passarem. Em muitos casos, ferramentas como Cucumber, SpecFlow ou Behave s√£o usadas para escrever cen√°rios em Gherkin (‚ÄúGiven, When, Then‚Äù), permitindo que as pr√≥prias partes interessadas consigam validar e at√© revisar os testes.

Na pr√°tica, o ATTD acaba funcionando como uma ponte entre BDD e TDD. Ele compartilha com o BDD a preocupa√ß√£o de usar exemplos de neg√≥cio como base para o desenvolvimento, mas mant√©m a disciplina do TDD de usar testes automatizados como motor do ciclo. Isso ajuda a garantir que o software entregue n√£o s√≥ funcione tecnicamente, mas tamb√©m atenda ao valor esperado pelos usu√°rios, reduzindo retrabalho e mal-entendidos.

O *ATDD (Acceptance Test-Driven Development)* √© uma pr√°tica de desenvolvimento guiada por *testes de aceita√ß√£o*, escritos antes do c√≥digo, em colabora√ß√£o entre desenvolvedores, QA e stakeholders. O foco dele √© garantir que o software atenda aos crit√©rios de aceita√ß√£o do neg√≥cio. Em ess√™ncia, ele antecipa o que seria validado l√° na frente pelo *UAT (User Acceptance Testing)*, mas de forma automatizada e cont√≠nua, desde o in√≠cio do ciclo.

O **TDD (Test-Driven Development)** √© mais granular: foca no n√≠vel do c√≥digo. Primeiro voc√™ escreve um teste unit√°rio que falha, depois escreve o m√≠nimo de c√≥digo para passar no teste e, por fim, refatora. Ele garante qualidade t√©cnica, mas n√£o necessariamente que o software atenda ao que o usu√°rio quer.

J√° o **UAT (User Acceptance Testing)** √© uma fase final, manual ou semi-manual, em que os usu√°rios ou representantes de neg√≥cio validam se o sistema est√° de acordo com suas expectativas. Ele √© mais subjetivo e humano, enquanto ATDD tenta trazer essa vis√£o de aceita√ß√£o para dentro do ciclo t√©cnico.

D√° pra pensar assim:

* O **ATDD** cria um **ciclo colaborativo** (neg√≥cio + dev + QA) para escrever crit√©rios de aceita√ß√£o como testes automatizados.
* O **TDD** atua no detalhe t√©cnico para garantir que cada unidade de c√≥digo funciona.
* O **UAT** √© a valida√ß√£o real pelo usu√°rio antes da release.

Ou seja, o ATDD n√£o √© o UAT implementado dentro do ciclo TDD, mas ele **faz uma ponte**: traz os crit√©rios de aceita√ß√£o (que seriam verificados no UAT) para dentro do desenvolvimento, lado a lado com o TDD. Em um fluxo maduro, voc√™ teria TDD para o n√≠vel de c√≥digo, ATDD para o n√≠vel de aceita√ß√£o de requisitos, e UAT no fim para validar com pessoas reais.

## [QA] SDD - Specification-Driven Development
<img height="377" align="right" src="https://github.com/user-attachments/assets/f1d7c1dc-adde-4604-b310-f8dd82f287f6" />

O **SDD - Specification-Driven Development** √© uma abordagem de desenvolvimento de software em que o ponto de partida e o guia principal de todo o ciclo de cria√ß√£o √© a especifica√ß√£o formal e clara do sistema a ser constru√≠do. 

Em vez de come√ßar direto pela implementa√ß√£o de c√≥digo ou at√© mesmo pelos testes, a ideia central do SDD √© produzir especifica√ß√µes bem definidas que podem ser documentos estruturados, contratos formais, modelos de comportamento ou at√© DSLs (linguagens espec√≠ficas de dom√≠nio) e a partir delas orientar o design, os testes e a implementa√ß√£o. 

No desenvolvimento tradicional, o c√≥digo vem primeiro, seguido pela documenta√ß√£o, testes e explica√ß√£o.

Mas no desenvolvimento orientado a especifica√ß√µes, invertemos o roteiro. A especifica√ß√£o se torna a fonte da verdade e o c√≥digo flui a partir dela. Com a IA no circuito, esse fluxo de trabalho se torna ainda mais poderoso. Gera especifica√ß√µes a partir da inten√ß√£o do usu√°rio. Deriva c√≥digo a partir de especifica√ß√µes e valida a l√≥gica com linguagem natural.

Neste t√≥pico, voc√™ aprender√° como fluxos de trabalho com tecnologia de IA permitem sistemas mais r√°pidos, seguros e modulares, especialmente para aplica√ß√µes embarcadas e distribu√≠das na borda. O desenvolvimento orientado a especifica√ß√µes come√ßa definindo o que o sistema deve fazer.

Antes de tocar no c√≥digo, as especifica√ß√µes podem delinear o comportamento funcional, relacionamentos de entrada/sa√≠da, casos extremos (edge cases), failure cases, Temporal logic e.g. do x, y, and z.

O prop√≥sito √© reduzir ambiguidades que frequentemente aparecem em m√©todos tradicionais, onde requisitos em linguagem natural muitas vezes d√£o margem a interpreta√ß√µes diferentes por desenvolvedores, testadores e stakeholders. No SDD, a especifica√ß√£o n√£o √© apenas um requisito no papel, mas sim um artefato execut√°vel ou valid√°vel, que pode ser usado para gerar c√≥digo, validar regras de neg√≥cio automaticamente ou servir de refer√™ncia inequ√≠voca para testes.

Dessa forma, o SDD busca criar um fluxo em que a especifica√ß√£o √© a fonte da verdade. Em muitas implementa√ß√µes dessa pr√°tica, as especifica√ß√µes podem ser escritas em formatos que permitam serem executadas ou verificadas, como contratos formais, modelos l√≥gicos ou at√© arquivos que depois geram c√≥digo de suporte, documenta√ß√£o ou casos de teste. Isso cria uma forte liga√ß√£o entre o que o cliente espera, o que o time desenvolve e o que √© testado. Diferente do TDD (Test-Driven Development), que coloca os testes como guia para a implementa√ß√£o, ou do BDD (Behavior-Driven Development), que enfatiza a escrita de cen√°rios de comportamento em linguagem quase natural, o SDD √© mais r√≠gido e sistem√°tico, focando na **especifica√ß√£o t√©cnica ou formal** como ponto de converg√™ncia, de forma que a implementa√ß√£o n√£o seja ‚Äúinterpretada‚Äù pelos desenvolvedores, mas derivada da especifica√ß√£o.

Essa abordagem √© especialmente √∫til em dom√≠nios onde erros de interpreta√ß√£o podem ser cr√≠ticos, como sistemas financeiros, governamentais, industriais e m√©dicos, porque minimiza a dist√¢ncia entre o que foi pedido e o que √© entregue. Al√©m disso, o SDD facilita auditorias, compliance e rastreabilidade, j√° que a especifica√ß√£o pode ser usada tanto como documento de contrato entre as partes quanto como mecanismo t√©cnico para validar que o software est√° aderente √†s regras. Por outro lado, aplicar SDD de forma efetiva exige disciplina, ferramentas adequadas e equipes acostumadas a lidar com formalismo maior do que em metodologias mais flex√≠veis, o que pode ser uma barreira em times √°geis que preferem rapidez de itera√ß√£o.
