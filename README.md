# üë®üèæ‚Äçüî¨ QA - Quality Assurance
Imagine-se como um entusiasta da tecnologia, ansioso por entender como um software pode ser eficaz e confi√°vel. Como garantir que um software atenda √†s expectativas dos usu√°rios e funcione sem falhas? Esse dilema cria um conflito cognitivo que nos impulsiona a mergulhar mais fundo.

A hist√≥ria da **Qualidade de Software** nos mostra a evolu√ß√£o dos processos, desde as abordagens mais tradicionais at√© as metodologias √°geis modernas. Aprender sobre modelos de qualidade, como o ISO 25000, e as dimens√µes da qualidade, como funcionalidade e usabilidade, enriquece nossa compreens√£o. As pe√ßas se encaixam, transformando a quest√£o inicial em um quebra-cabe√ßa conceitual.
 
Imagine que voc√™ √© um membro de uma equipe de desenvolvimento de software. Voc√™ √© desafiado a aplicar os conceitos aprendidos em um cen√°rio real. Voc√™ participa de revis√µes, que s√£o an√°lises colaborativas do c√≥digo, e auditorias, que avaliam os processos utilizados. Essa simula√ß√£o o coloca no ambiente profissional, onde as decis√µes t√™m impacto direto na qualidade do software.

Ao concluir as revis√µes e auditorias, voc√™ reflete sobre os processos e a efic√°cia das t√©cnicas aplicadas. Reconhece a import√¢ncia de identificar falhas cedo e como as revis√µes sistem√°ticas podem prevenir erros custosos. Voc√™ compreende que, assim como o software, o aprendizado √© um processo cont√≠nuo (Continuous Learning). E √† medida que voc√™ assimila esses conceitos, torna-se mais apto a contribuir para o desenvolvimento de software de alta qualidade, solidificando sua jornada na compreens√£o da Qualidade de Software

> [!Tip]
> Vamos recordar a import√¢ncia das boas pr√°ticas de programa√ß√£o como um elemento essencial na busca pela qualidade de software. Revisitarmos a no√ß√£o de c√≥digo limpo e bem estruturado, que n√£o s√≥ facilita a manuten√ß√£o, mas tamb√©m reduz erros e falhas futuras. Recordar como padr√µes de nomenclatura consistentes, coment√°rios claros e modulariza√ß√£o do c√≥digo s√£o cruciais para criar um produto de software robusto e de f√°cil compreens√£o. Isso nos lembrar√° que a qualidade n√£o se limita apenas aos processos de teste, mas come√ßa desde a concep√ß√£o do c√≥digo-fonte.

Primeiro, precisamos entender que a qualidade de software √© uma √°rea de grande import√¢ncia no mercado de tecnologia da informa√ß√£o. E para garantir a qualidade de um software, √© preciso conhecer seus fundamentos, entender sua hist√≥ria, compreender os custos envolvidos, realizar atividades de apoio, seguir padr√µes e avaliar seus atributos. A seguir, apresentamos alguns desses atributos:

> [!Note]
> **FUNDAMENTOS DA QUALIDADE DE SOFTWARE**: Incluem a defini√ß√£o de requisitos, o planejamento de testes e a execu√ß√£o de testes de forma sistem√°tica. Esses processos s√£o essenciais para garantir que o software desenvolvido atenda √†s necessidades do usu√°rio e atinja a qualidade esperada.

No antigo Egito, h√° aproximadamente 4 mil anos, para que as constru√ß√µes fossem feitas com **qualidade**, definiu-se o c√∫bito, que era a dist√¢ncia do cotovelo √† ponta do indicador do fara√≥. Uma das primeiras tentativas da humanidade de _padronizar_ as medidas, gerando qualidade nas constru√ß√µes.

Nesta escultura, temos na base um compilado com as regras e leis a serem seguidas, impostas por Hamurabi, Rei da Babil√¥nia, que era aplicada a cidad√£os livres, comerciantes, escravos, etc. Uma das primeiras tentativas de _padronizar_ as regras de conv√≠vio da sociedade, h√° aproximadamente 3.800 anos atr√°s.

> [!Important]
> **Defini√ß√£o**: ‚ÄúQualidade √© a medida de quanto um projeto atende aos requisitos especificados no escopo.‚Äù

Historicamente, o conceito de qualidade est√° ligado √† ideia de atender padr√µes e requisitos acordados, com base em comunica√ß√£o clara e objetivos definidos, seja na qualidade do ar, qualidade da √°gua, da qualidade de vida ou qualidade do software. Portanto, a qualidade de software √© a investiga√ß√£o do software a fim de fornecer informa√ß√µes sobre sua qualidade em rela√ß√£o ao contexto em que ele deve operar.

Os **requisitos** s√£o funcionalidades que o produto precisa ter para atender √†s expectativas e necessidades das partes interessadas.

O **escopo** √© o conjunto de caracter√≠sticas desejadas que descrevem o resultado final do projeto.

Portanto, o **teste de software** para os profissionais de QA‚Äôs √© a forma que utilizamos para avaliar um software, com um objetivo de assegurar e garantir a qualidade do mesmo, nos pontos de vista t√©cnico e funcional.

Vantagens dos testes:

- Qualidade
- Evitar a continua√ß√£o dos bugs
- Redu√ß√£o de Custos

A defini√ß√£o de ‚Äúpronto‚Äù nada mais √© do que um contrato firmado entre o time e o PO, que lista de forma clara os requisitos que determinam que uma User Story est√° completa.

E a resposta √© simples: normalmente, quando perguntam se uma funcionalidade ou story est√° pronta, respondem: ‚Äúsim, mas falta testar‚Ä¶‚Äù.

 Isso significa que ao definir o conceito de ‚Äúpronto‚Äù, √© importante que o QA ‚Äì que faz parte do time ‚Äì esteja envolvido e possa sensibilizar os membros do time e PO para que os testes fa√ßam parte deste conceito.

Dessa forma, garantimos:

- Integra√ß√£o entre desenvolvedores e QA;
- Maior qualidade do time;
- Que n√£o haja desentendimentos desnecess√°rios;
- Story testada e com aceite formal.¬†

## [QA] Custos x Fases
Regra 10 de Myers

## [QA] DDD - Domain-Driven Design
<img src="https://img.shields.io/badge/Python-3.10.7-3776AB?style=flat&logo=Python&logoColor=white"> <img src="https://img.shields.io/badge/Node.js-16.17.0-339933?style=flat&logo=Node.js&logoColor=white"> <img src="https://img.shields.io/badge/Ruby-3.3-CC342D?style=flat&logo=Ruby&logoColor=white"> <img src="https://img.shields.io/badge/Go-1.21-00ADD8?style=flat&logo=Go&logoColor=white"> <img src="https://img.shields.io/badge/PHP-8.2-777BB4?style=flat&logo=PHP&logoColor=white"> <img src="https://img.shields.io/badge/C++-23-F5455C?style=flat&logo=CPlusPlus&logoColor=white"> <img src="https://img.shields.io/badge/Java-22.0.1-chocolate?style=flat&logo=OpenJDK&logoColor=white"> <img src="https://img.shields.io/badge/.NET-8.0.300-512BD4?style=flat&logo=DotNet&logoColor=white"> <img src="https://img.shields.io/badge/Rust-1.82.0-dda584?style=flat&logo=Rust&logoColor=white"> <img src="https://img.shields.io/badge/UML-diagrams-purple?style=flat&logo=UML&logoColor=white"> 

<a href=""><img src="https://em-content.zobj.net/source/microsoft-teams/363/ferris-wheel_1f3a1.png" align="right" height="77"></a>

O **DDD - Domain-Driven Design** (Projeto Orientado a Dom√≠nio) √© uma abordagem de desenvolvimento de software que se concentra em entender o **dom√≠nio do neg√≥cio** e modelar o software em torno desses conceitos e regras de neg√≥cio. √â um tipo de <a href="">modelagem de software</a> e um <a href="">design de software</a> orientado a objetos (OOP) que procura refor√ßar conceitos e boas pr√°ticas relacionadas √† OOP e surgiu como uma resposta √†s dificuldades enfrentadas por desenvolvedores ao lidarem com sistemas complexos, especialmente em dom√≠nios de neg√≥cio onde a l√≥gica e os requisitos mudam frequentemente. Isso vem em contrapartida com o uso comum do <a href="">Data-Driven Design</a> (Projeto Orientado a Dados), que a maioria dos desenvolvedores usa sem mesmo ter consci√™ncia disso. 

O DDD nos permite planejar uma arquitetura de microsservi√ßos decompondo o sistema maior em unidades independentes, compreendendo as responsabilidades de cada uma e identificando seus relacionamentos, ele n√£o √© um design pattern espec√≠fico, mas sim uma importante abordagem de design de software, com foco na modelagem de software para corresponder a um **dom√≠nio** de acordo com as informa√ß√µes dos especialistas desse dom√≠nio. O Domain-Driven Design (DDD) surgiu como uma metodologia revolucion√°ria para a modelagem de software, desenvolvida com o intuito de refinar e otimizar a correspond√™ncia entre o design do software e o dom√≠nio do software e o dom√≠nio do problema que ele busca resolver.

> Os microsservi√ßos s√£o a forma mais escal√°vel de desenvolver software. Mas voc√™ precisa de um bom design que permita que as equipes de desenvolvedores trabalhem de forma aut√¥noma e implementem sem atrapalhar umas √†s outras, caso contr√°rio, voc√™ perder√° os benef√≠cios de escalabilidade. O DDD ajuda a delimitar responsabilidades claras entre os servi√ßos, o que permite que equipes atuem de forma independente e coordenada.

<a href=""><img src="https://github.com/user-attachments/assets/47723806-ab10-490c-844f-6c5e8980e08f" align="right" height="177"></a>

Foi popularizado por Eric Evans em seu livro **Domain-Driven Design: Tackling Complexity in the Heart of Software**, publicado em 2003. Esse livro n√£o √© leve, especialmente se voc√™ ainda est√° no in√≠cio da jornada. Ele exige uma certa base em desenvolvimento orientado a objetos (OOP), arquitetura de software e experi√™ncia pr√°tica com projetos reais. Geralmente, ele √© mais proveitoso depois que voc√™ j√° trabalhou em sistemas mais complexos ou com arquitetura em camadas.

Sem levar em conta o DDD, as **t√©cnicas de modelagem de dom√≠nio** s√£o m√©todos utilizados na engenharia de software para compreender e representar o dom√≠nio de um problema espec√≠fico. O dom√≠nio refere-se √† √°rea de conhecimento, contexto ou setor de neg√≥cios em que o software est√° sendo desenvolvido. A modelagem de dom√≠nio tem como objetivo capturar os conceitos, regras e relacionamentos do dom√≠nio em um formato compreens√≠vel e utiliz√°vel pelos desenvolvedores. Ent√£o, o DDD (Domain-Driven Design) √© uma abordagem para o desenvolvimento de software que combina conceitos de design de software e t√©cnicas de modelagem de dom√≠nio. N√£o √© considerado um design pattern espec√≠fico, mas sim uma abordagem geral para projetar e estruturar sistemas de software. Domain-Driven Design (DDD) √© um m√©todo de design de software em que os desenvolvedores constroem modelos para entender os requisitos de neg√≥cios de um dom√≠nio. Esses modelos servem como base conceitual para o desenvolvimento de software.

No entanto, suas ra√≠zes v√™m de pr√°ticas e ideias que estavam sendo discutidas na ind√∫stria desde os anos 1990. Durante esse per√≠odo, muitas empresas estavam adotando metodologias √°geis e enfrentando problemas ao construir sistemas que n√£o apenas funcionassem, mas que tamb√©m fossem f√°ceis de entender, modificar e expandir. Um dos grandes desafios era a chamada "lacuna sem√¢ntica" entre os especialistas de dom√≠nio (pessoas que entendem o neg√≥cio) e os desenvolvedores (que implementam solu√ß√µes t√©cnicas). Essa lacuna frequentemente levava a softwares que funcionavam de forma errada ou que eram dif√≠ceis de adaptar a mudan√ßas nos requisitos.

A ideia inicial do DDD √© voltar √† uma modelagem OO mais pura, por assim dizer. Devemos esquecer de como os dados s√£o persistidos e nos preocupar em como representar melhor as necessidades de neg√≥cio em classes e comportamentos (m√©todos). Isso significa que em DDD um `Cliente` pode n√£o ter um *setter* para os seus atributos comuns, mas pode ter m√©todos com l√≥gica de neg√≥cio que neste dom√≠nio de neg√≥cio pertencem ao `cliente`, como `void associarNovoCartao(Cartao)` ou `Conta recuperarInformacoesConta()`. Em resumo, as classes modeladas e os seus m√©todos deveriam representar o neg√≥cio da empresa, usando inclusive a mesma nomenclatura. A persist√™ncia dos dados √© colocada em segundo plano, sendo apenas uma camada complementar.

O DDD nasceu da necessidade de aproximar esses dois mundos. Eric Evans observou que o software bem-sucedido em contextos complexos era constru√≠do em torno de um **modelo de dom√≠nio** que capturava com precis√£o o conhecimento do neg√≥cio. Ele tamb√©m percebeu que os sistemas mais sustent√°veis utilizavam linguagens comuns entre especialistas e desenvolvedores, al√©m de t√©cnicas para isolar a complexidade e tornar o c√≥digo mais alinhado com as regras do dom√≠nio.

Com a evolu√ß√£o do desenvolvimento de softwares e no aumento da complexidade dos requisitos da aplica√ß√£o, √© extremamente relevante definirmos uma comunica√ß√£o clara entre as v√°rias partes envolvidas em um projeto de software. √â bastante comum haver conflitos entre os termos t√©cnicos utilizados pelas diferentes √°reas, seja entre analistas de neg√≥cios, desenvolvedores, especialistas financeiros ou de vendas. Nada mais natural haja visto que as equipes est√£o cada vez mais multidisciplinares. Para auxiliar em uma comunica√ß√£o fluida, os conceitos do DDD ‚Äî Domain Driven Design, prop√µem como um dos seus pilares a defini√ß√£o de uma _Linguagem Ub√≠qua_.

<a href=""><img src="https://github.com/user-attachments/assets/4873d674-b778-448b-a311-26f9307e624f"></a>

O DDD formalizou essas pr√°ticas ao introduzir conceitos como **Ubiquitous Language** (Linguagem Ub√≠qua), o cerne do DDD, que promove a cria√ß√£o de uma linguagem compartilhada entre todas as partes interessadas, e **Bounded Contexts** (Contextos Limitados), que ajudam a dividir sistemas grandes e complexos em partes menores e mais compreens√≠veis. Al√©m disso, o DDD trouxe aten√ß√£o para padr√µes arquiteturais que d√£o suporte ao dom√≠nio, como **Entidades** (Entity), **Agregados** (), **Reposit√≥rios** () e **Servi√ßos de Dom√≠nio** (), estabelecendo um design centrado na l√≥gica de neg√≥cios em vez de nas tecnologias subjacentes.

Para que possamos iniciar uma compreens√£o acerca de Linguagem Ub√≠qua (Ubiquitous Language), podemos nos valer da an√°lise sem√¢ntica do termo ub√≠quo: `u-b√≠-quo` (latim _ubiquus_, -a, -um), adjetivo:

- Que est√° ao mesmo tempo em toda a parte. = `ONIPRESENTE`
- Que tem dom da ubiquidade. = `ONIPRESENTE`
- Que est√° difundido em todo o lado. = `GERAL, UNIVERSAL`.

De forma conceitual, a linguagem ub√≠qua √© o conjunto de termos e inter-rela√ß√µes que fornecem a sem√¢ntica da comunica√ß√£o do dom√≠nio, que reflete a vis√£o do neg√≥cio. E de forma pr√°tica, ao se trabalhar com DDD, entende-se como comunica√ß√£o de mesma linguagem, em um √∫nico modelo, de forma que todos os envolvidos no projeto tenham a mesma compreens√£o acerca dos termos utilizados. Linguagem ub√≠qua pode parecer um termo complexo de se compreender, mas outro termo tamb√©m utilizado para identificar este tipo de comunica√ß√£o, nos auxilia em uma melhor compreens√£o: _Linguagem Onipresente_.

**Linguagem Onipresente** √© essencialmente os termos, palavras e defini√ß√µes utilizadas por todo o dom√≠nio do projeto. √â o idioma utilizado no cotidiano da empresa, as terminologias da realidade do neg√≥cio. Quando um projeto n√£o respeita a **linguagem do dom√≠nio** diversos problemas de comunica√ß√£o surgem, dificultando o desenvolvimento, implanta√ß√£o e sustenta√ß√£o da solu√ß√£o.

Quando termos utilizados no projeto v√£o sendo traduzidos, de acordo com o uso em cada departamento, a comunica√ß√£o se torna an√™mica e a assimila√ß√£o do conhecimento disperso. Em seu livro Domain Driven Design ‚Äî Atacando as Complexidades no Cora√ß√£o do Software, Eric Evans descreve de maneira clara esta problem√°tica:

> O custo de toda a tradu√ß√£o, al√©m do risco de entendimento errado, √© simplesmente muito alto. Um projeto precisa de uma linguagem em comum que seja mais robusta que o m√≠nimo denominador comum.

<a href=""><img src="https://github.com/user-attachments/assets/5ac09617-ba80-4f3f-955a-62bd9dfe77ee" align="right" height="77"></a>

A Linguagem Onipresente (ubiquitous language) n√£o est√° limitada a diagramas em <a href="">UML (Unified Modeling Languages, ou Linguagem de Modelagem Unificada)</a>, mas principalmente, define em seu vocabul√°rio nome das classes e opera√ß√µes de destaque. Inclui regras para implantar um dicion√°rio uniforme e expl√≠cito para o modelo, para que o mesmo possa ser utilizado com o m√°ximo de efici√™ncia poss√≠vel.

O **Diagram as code** (Diagrama como c√≥digo) √© uma abordagem de cria√ß√£o de diagramas que utiliza c√≥digo, em vez de ferramentas gr√°ficas, para desenhar e manter diagramas. Essa abordagem permite que os diagramas sejam criados e atualizados utilizando linguagens de programa√ß√£o ou marcadores, em vez de ferramentas de desenho gr√°fico. A pr√°tica de "Diagram as code" (Diagrama como c√≥digo) pode auxiliar no Domain-Driven Design (DDD), pois √© uma pr√°tica √∫til no DDD que ajuda a manter a documenta√ß√£o atualizada, facilita a colabora√ß√£o, fornece controle de vers√£o e permite a gera√ß√£o autom√°tica de diagramas. Vantagens do "Diagram as code" no DDD:

1. **Melhor documenta√ß√£o**: Com o "Diagram as code", voc√™ pode manter a documenta√ß√£o do seu modelo de dom√≠nio atualizada e sincronizada com o c√≥digo. Isso ajuda a garantir que a documenta√ß√£o seja precisa e refletida nas mudan√ßas no c√≥digo.
2. **Modelagem colaborativa**: O "Diagram as code" permite que os membros da equipe colaborativamente trabalhem no modelo de dom√≠nio, tornando mais f√°cil para os desenvolvedores, especialistas em dom√≠nio e outros stakeholders discutirem e refinarem o modelo.
3. **Vers√£o e controle**: Com o "Diagram as code", voc√™ pode usar sistemas de controle de vers√£o (como Git) para rastrear as altera√ß√µes no modelo de dom√≠nio. Isso ajuda a garantir que todas as altera√ß√µes sejam documentadas e possam ser revertidas se necess√°rio.
4. **Gera√ß√£o autom√°tica de diagramas**: Muitas ferramentas de "Diagram as code" permitem que voc√™ gere diagramas automaticamente a partir do c√≥digo. Isso pode economizar tempo e reduzir a chance de erros manuais.
5. **Integra√ß√£o com o ciclo de desenvolvimento**: O "Diagram as code" pode ser integrado ao ciclo de desenvolvimento de software, permitindo que os desenvolvedores trabalhem no modelo de dom√≠nio em paralelo com o desenvolvimento do c√≥digo.

As ferramentas permitem que voc√™ crie diagramas como c√≥digo, utilizando sintaxes espec√≠ficas para desenhar os diagramas. Em seguida, elas geram imagens ou diagramas a partir do c√≥digo. Algumas ferramentas populares para "Diagram as code" incluem:

<a href="https://www.plantuml.com/plantuml/uml/SyfFKj2rKt3CoKnELR1Io4ZDoSa700003"><img src="https://github.com/user-attachments/assets/cd3deff0-176a-4d9b-8735-0a1b2b1d2a33" align="right" height="77"></a>

- Mermaid
- **PlantUML**
- Graphviz
- C4 (abordagem de modelagem de software)

Normalmente os especialistas de um dom√≠nio, diretores, administradores, analistas, t√©cnicos, possuem pouca familiaridade com o jarg√£o t√©cnico utilizado no desenvolvimento de software, mas utilizam os jarg√µes pr√≥prios de sua √°rea de atua√ß√£o. A partir desta realidade, os especialistas de um dom√≠nio descrevem superficialmente o que necessitam, fazendo com que desenvolvedores criem abstra√ß√µes que sustentem o design da aplica√ß√£o. Com isso, uma compreens√£o uniforme vai se deteriorando exponencialmente.

<a href="https://www.plantuml.com/plantuml/uml/SyfFKj2rKt3CoKnELR1Io4ZDoSa700003"><img src="https://github.com/user-attachments/assets/d51f18a5-193c-49ef-8a83-83f42f1924f5" align="right" height="277"></a>

Como solu√ß√£o a esta dispers√£o na comunica√ß√£o, devemos usar a linguagem baseada no modelo de forma exaustiva at√© que a comunica√ß√£o seja fluida e compreens√≠vel entre os diversos setores envolvidos no projeto. Para que possamos alcan√ßar esta flu√™ncia, os especialistas do dom√≠nio devem vetar termos ou estruturas que n√£o transmitam uma compreens√£o clara acerca das funcionalidades envolvidas; os desenvolvedores devem se empenhar no cuidado com ambiguidades ou inconsist√™ncias que possam corromper o modelo proposto. Ou seja, √© um esfor√ßo conjunto entre todos os envolvidos, mas, √© essencialmente necess√°rio que ocorra.

Como identificar os especialistas de dom√≠nio? Especialistas de dom√≠nio s√£o os profissionais envolvidos no dia a dia da opera√ß√£o, nos mais diferentes setores, ou seja, s√£o os ‚Äúconhecedores‚Äù do neg√≥cio (stakeholders). Normalmente estes especialistas s√£o analistas, t√©cnicos, engenheiros, podendo ser todo aquele que possui a compreens√£o acerca do fluxo de opera√ß√£o da empresa. Os especialistas de dom√≠nio det√©m o conhecimento sobre as necessidades e requisitos necess√°rios para o processamento das atividades organizacionais.

<img src="https://github.com/user-attachments/assets/3e5b0f4e-5517-4b6d-a8a8-cd650c6f577d" align="right" height="277">

Em ess√™ncia, o DDD surgiu para enfrentar a complexidade inerente ao desenvolvimento de software em dom√≠nios desafiadores, permitindo que os sistemas sejam projetados de forma que o c√≥digo seja uma express√£o direta das regras e processos do neg√≥cio. Com o tempo, o DDD ganhou popularidade e passou a ser usado em diversos contextos, especialmente em sistemas corporativos onde o dom√≠nio de neg√≥cio √© complexo e sujeito a constantes mudan√ßas.

Para o sucesso de um projeto de software, o DDD sugere que tanto especialistas de dom√≠nio quanto desenvolvedores devem falar a mesma l√≠ngua.

A figura acima, ilustra a exist√™ncia de termos que s√≥ os especialistas de dom√≠nio conhecem e apresentam express√µes somente de car√°ter tecnol√≥gico, os quais s√£o de uso apenas do time de desenvolvimento. Contudo, √© necess√°rio que exista um conjunto de termos que devem ser de conhecimento universal, no que se refere ao dom√≠nio da aplica√ß√£o, formando a Linguagem Ub√≠qua do sistema. A defini√ß√£o de uma linguagem onipresente objetiva principalmente dois prop√≥sitos:

- Possibilitar uma comunica√ß√£o fluida entre os membros de equipes multidisciplinares; Nomear elementos do c√≥digo da aplica√ß√£o, como classes, m√©todos, vari√°veis, fun√ß√µes, m√≥dulos, tabelas de bancos de dados, rotas de APIs, etc.

- Ademais a padroniza√ß√£o na comunica√ß√£o prop√µe elucidar o significado dos termos, de um forma simples, objetiva e compreens√≠vel para facilitar os relacionamentos e associa√ß√µes entre todos m√≥dulos necess√°rios.

Qualquer pessoa t√©cnica contribuindo para o modelo deve programar, pelo menos tocar no c√≥digo, independente do papel desempenhado no projeto. Um respons√°vel por mudar o c√≥digo deve sempre aprender a expressar o modelo atrav√©s do c√≥digo. Todo desenvolvedor deve estar envolvido na discuss√£o sobre o modelo e ter contato com os especialistas do dom√≠nio. (EVANS, 2016).

Em seu livro Implementando Domain Driven Design, Vaughn Vernon, pontua que um especialista de dom√≠nio tem uma forte influ√™ncia sobre a linguagem utilizada, devido ao maior conhecimento acerca do neg√≥cio, que no final √© o contexto imperativo de todo projeto. Estes especialistas tendem a ser influenciados pelos padr√µes da ind√∫stria, contudo, uma linguagem universal deve ser centrada em como o pr√≥prio neg√≥cio pensa e opera. Ou seja, cada empresa possui seu pr√≥prio dom√≠nio acerca da execu√ß√£o de seus processos.

N√£o entenda Linguagem Ub√≠qua como um conjunto de jarg√µes de neg√≥cios sendo impostos ao time de desenvolvimento, e nem mesmo uma sobreposi√ß√£o de termos t√©cnicos sobre o contexto de neg√≥cio, mas sim, uma linguagem real que √© criada por toda a equipe e que √© propagada por toda a corpora√ß√£o.

Compreende-se que haver√° discord√¢ncias em rela√ß√£o aos termos utilizados e que est√£o na mente dos especialistas, mas, a partir do uso aberto da linguagem, a evolu√ß√£o √© natural e consolidada por este processo de matura√ß√£o da comunica√ß√£o.

O DDD enfatiza a compreens√£o profunda do dom√≠nio do problema e o uso de uma linguagem ub√≠qua compartilhada entre as equipes de desenvolvimento e especialistas do dom√≠nio. Ele prop√µe a organiza√ß√£o do c√≥digo em torno do dom√≠nio do problema, separando-o dos detalhes t√©cnicos e infraestrutura. 

Embora o DDD n√£o seja um design pattern em si, ele pode ser combinado com v√°rios design patterns e princ√≠pios de design, como Agregado, Reposit√≥rio, Especifica√ß√£o, Event Sourcing, entre outros. O DDD fornece diretrizes e conceitos para ajudar na cria√ß√£o de uma arquitetura de software robusta e flex√≠vel.

Portanto, podemos dizer que o DDD √© uma abordagem de design e uma metodologia de modelagem que pode ser aplicada em diferentes arquiteturas de software, como arquitetura em camadas, arquitetura hexagonal, arquitetura de microsservi√ßos, entre outras. Ele fornece princ√≠pios e pr√°ticas para projetar e estruturar o c√≥digo em torno do dom√≠nio do problema, visando um modelo de dom√≠nio rico, desacoplamento e flexibilidade.

√â uma abordagem mais ampla para o design de software que abrange v√°rios conceitos e t√©cnicas. DDD enfatiza a modelagem do dom√≠nio, a colabora√ß√£o entre especialistas do dom√≠nio e desenvolvedores, e a cria√ß√£o de um c√≥digo baseado em um entendimento profundo do dom√≠nio do problema.

No contexto do DDD, existem design patterns espec√≠ficos que s√£o frequentemente utilizados para ajudar a implementar os conceitos e princ√≠pios do DDD. Alguns desses padr√µes incluem:

<a href=""><img src="https://github.com/IsaacAlves7/DevSecOps/assets/61624336/0ade6281-cdca-47d3-8b95-57e81b61d04a" align="right" height="377"></a>

1. <a href="">Agregado</a>: Se refere a um padr√£o de design que agrupa um conjunto de objetos relacionados em uma √∫nica unidade coesa. O Agregado √© uma das principais constru√ß√µes utilizadas para modelar e organizar o dom√≠nio em DDD;

2. <a href="">Reposit√≥rio</a>: Fornece uma interface para acessar cole√ß√µes de objetos agregados, permitindo que o dom√≠nio permane√ßa livre de preocupa√ß√µes com persist√™ncia. Ele atua como uma camada intermedi√°ria entre o dom√≠nio e a fonte de dados (como bancos de dados).

3. <a href="">Servi√ßo de Dom√≠nio</a>: Representa opera√ß√µes ou a√ß√µes do dom√≠nio que n√£o pertencem naturalmente a uma √∫nica entidade ou value object. Encapsula l√≥gica de neg√≥cio que depende de m√∫ltiplos objetos.

4. <a href="">Value Object</a>: Objetos que n√£o possuem identidade pr√≥pria e s√£o definidos apenas por seus atributos. S√£o imut√°veis e usados para representar conceitos como dinheiro, coordenadas ou medidas.

5. <a href="">Entidade</a>: Objetos do dom√≠nio que possuem identidade pr√≥pria (geralmente um ID) e um ciclo de vida distinto. Diferente de value objects, entidades podem mudar seus atributos ao longo do tempo.

6. <a href="">Factory</a>: Padr√£o respons√°vel por encapsular a l√≥gica de cria√ß√£o complexa de objetos, especialmente agregados. Evita a polui√ß√£o do construtor com l√≥gica de montagem de objetos.

7. <a href="">Especifica√ß√£o</a>: Define regras de neg√≥cio reutiliz√°veis e combin√°veis para verificar se um objeto atende a determinados crit√©rios. √â √∫til para separa√ß√£o de responsabilidades e clareza das regras de dom√≠nio.

8. <a href="">Event Sourcing</a>: T√©cnica onde o estado do sistema √© determinado por uma sequ√™ncia de eventos (ao inv√©s de snapshots de dados). Permite reconstruir o estado do sistema e ter um hist√≥rico detalhado das mudan√ßas.

9. <a href="">Inje√ß√£o de Depend√™ncia (DI - Dependency Injection)</a>: T√©cnica que permite desacoplar componentes do sistema, facilitando testes, manuten√ß√£o e extensibilidade. No DDD, √© comum para injetar reposit√≥rios, servi√ßos de dom√≠nio e unidades de trabalho nos agregados e servi√ßos de aplica√ß√£o.

Esses padr√µes, juntamente com outros conceitos e t√©cnicas, podem ser aplicados para construir uma arquitetura que segue os princ√≠pios do DDD. O DDD, portanto, n√£o √© um design pattern em si, mas uma abordagem que pode ser implementada usando diversos padr√µes de design espec√≠ficos.

Quando n√£o usar DDD? √Äs vezes s√≥ √© necess√°rio um CRUD! DDD n√£o √© uma solu√ß√£o para tudo. A maioria dos sistemas possui uma boa parte composta por cadastros b√°sicos (CRUD) e n√£o seria adequado usar DDD para isso.

O DDD deve ajudar na modelagem das classes mais importantes e mais centrais do sistema de forma e diminuir a complexidade e ajudar na manuten√ß√£o das mesmas, afinal este √© o objetivo dos princ√≠pios de orienta√ß√£o a objetos.

Outro ponto √© sobre n√≥s desenvolvedores estarmos compartilhando dados com outros sistemas, as rotinas de integra√ß√£o que recebem ou disponibilizam dados para outros sistemas n√£o devem ser "inteligentes". Muitos desenvolvedores acabam modelando suas classes de neg√≥cios tentando resolver as quest√µes internas do sistema e, ao mesmo tempo, pensando em como essas classes ser√£o expostas para outros sistemas. Padr√µes como DTO (Data Transfer Object) que usam objetos "burros" s√£o mais adequados para isso.

Portanto, o DDD n√£o tenta resolver todos os problemas de todas as camadas de um sistema. Seu foco √© na modelagem das entidades principais de neg√≥cio usando a linguagem adequada daquele dom√≠nio para facilitar a manuten√ß√£o, extens√£o e entendimento. Particularmente, eu n√£o seguiria √† risca o padr√£o, at√© porque existem in√∫meros padr√µes e varia√ß√µes de modelagem OO. Estude os princ√≠pios por detr√°s desses padr√µes, pois eles s√£o geralmente parecidos e veja o que funciona melhor para cada projeto.

## [QA] BDD - Behavior-Driven Development
![Cucumber](https://img.shields.io/badge/-Cucumber-23D96C?style=badge&logo=cucumber&logoColor=white) ![Behave](https://img.shields.io/badge/-Behave-00D564?style=Behave&logo=Python&logoColor=white) ![Specflow](https://img.shields.io/badge/-Specflow-00D564?style=badge&logo=.NET&logoColor=white) ![Speculate](https://img.shields.io/badge/-Speculate-00D564?style=badge&logo=Rust&logoColor=white) ![Mocha](https://img.shields.io/badge/-Mocha-00D564?style=badge&logo=Mocha&logoColor=white) ![Chai](https://img.shields.io/badge/-Chai-00D564?style=badge&logo=Chai&logoColor=white) ![Jest](https://img.shields.io/badge/-Jest-00D564?style=badge&logo=Jest&logoColor=white) ![Sinon](https://img.shields.io/badge/-Sinon-00D564?style=badge&logo=Node.js&logoColor=white) ![Gherkin](https://img.shields.io/badge/-Gherkin-00D564?style=badge&logo=Gherkin&logoColor=white) ![Gherkin](https://img.shields.io/badge/-Gherkin-00D564?style=badge&logo=Gherkin&logoColor=white) ![Gherkin](https://img.shields.io/badge/-Gherkin-00D564?style=badge&logo=Gherkin&logoColor=white) 

<img src="https://github.com/user-attachments/assets/51f4d9a0-47ce-49a9-baeb-f8b9d4c15b3e" align="right" height="77">

O **BDD - Behavior-Driven Development** (Desenvolvimento Orientado a Comportamento), √© uma metodologia de desenvolvimento √°gil que tem como foco a colabora√ß√£o entre desenvolvedores, QA (Quality Assurance) e partes interessadas n√£o t√©cnicas para criar uma compreens√£o compartilhada do comportamento desejado de um software. O BDD √© uma evolu√ß√£o do TDD (Test-Driven Development) e adiciona uma √™nfase maior na comunica√ß√£o e na clareza dos requisitos. Em resumo, o BDD promove uma abordagem colaborativa para o desenvolvimento de software, focando em comportamentos e resultados esperados do sistema, o que ajuda a garantir que o software entregue atenda √†s necessidades reais dos usu√°rios e stakeholders.

Aqui est√£o os componentes chave do BDD:

1. **Foco no Comportamento**: Em vez de se concentrar apenas na implementa√ß√£o t√©cnica e nos testes de unidade, o BDD foca em como o software deve se comportar sob v√°rias condi√ß√µes, incluindo o comportamento do usu√°rio final.

2. **Linguagem Ub√≠qua (Ubiquitous Language)**: Utiliza uma linguagem comum (frequentemente baseada em linguagens naturais como o ingl√™s) que pode ser compreendida por todos os membros da equipe, incluindo desenvolvedores, QA, e stakeholders n√£o t√©cnicos. Isso ajuda a reduzir ambiguidades e garantir que todos tenham a mesma compreens√£o dos requisitos. A Linguagem Ub√≠qua (Ubiquitous Language) √© um conceito central no <a href="">Design Orientado a Dom√≠nio (DDD)</a> que visa criar uma linguagem comum entre todos os envolvidos em um projeto, seja para os especialistas no dom√≠nio, desenvolvedores, ou mesmo os usu√°rios finais. Essa linguagem comum facilita a comunica√ß√£o e colabora√ß√£o, reduzindo a possibilidade de mal-entendidos e melhorando a qualidade do desenvolvimento. 

3. **Especifica√ß√µes Execut√°veis**: No BDD, os requisitos s√£o escritos em forma de especifica√ß√µes que podem ser executadas como testes. Essas especifica√ß√µes geralmente seguem um formato estruturado, como <a href="">Gherkin</a> que √© uma linguagem de dom√≠nio espec√≠fico usada para descrever comportamentos esperados de um sistema de forma clara e compreens√≠vel por todos os envolvidos no desenvolvimento de software, incluindo pessoas n√£o t√©cnicas, que usa palavras-chave como "`Given`" (Dado), "`When`" (Quando), e "`Then`" (Ent√£o) para descrever cen√°rios de teste:

   - `Given` (Dado): Descreve o contexto inicial ou o estado do sistema antes de uma a√ß√£o espec√≠fica.
   - `When` (Quando): Descreve a a√ß√£o ou evento que ocorre.
   - `Then` (Ent√£o): Descreve o resultado esperado ou o comportamento do sistema ap√≥s a a√ß√£o.

Exemplo: Login no Sistema
   
```gherkin
Feature: Login no Sistema

Scenario: Login com credenciais v√°lidas
  Given: o usu√°rio est√° na p√°gina de login
  When: o usu√°rio insere suas credenciais v√°lidas
  Then: o usu√°rio √© redirecionado para a p√°gina inicial
```

Exemplo 2: Pesquisar produto

```gherkin
Funcionalidade: Pesquisar produto
  Eu como cliente
  Quero fazer pesquisas no site da OLX
  Para buscar por produtos

Cen√°rio: Buscar produto com sucesso
  Dado que estou no site da OLX como um comprador de SP
  Quando eu fizer uma busca por um produto
  Ent√£o ser√£o exibidos os resultados de busca para o produto em SP
```

5. **Ferramentas de BDD**: Existem v√°rias ferramentas que suportam BDD, ajudando a automatizar as especifica√ß√µes execut√°veis. Algumas das ferramentas populares incluem <a href="">Cucumber</a> (para v√°rias linguagens como Java, Ruby), <a href="">SpecFlow</a> (para .NET), <a href="">Behave</a> (para Python), entre outras.

<img src="https://github.com/IsaacAlves7/DevSecOps/assets/61624336/93228869-20dc-414f-b89e-4ae549ac96b4" align="right" height="277">

5. **Benef√≠cios do BDD**: Uma das maiores virtudes do BDD - Behavior-Driven Development √© unir os dois mundos TDD e DDD, de fato √© representar uma interse√ß√£o entre TDD (Test-Driven Development) e DDD (Domain-Driven Design), pois ele nasce da necessidade de alinhar o desenvolvimento t√©cnico com o entendimento do neg√≥cio, garantindo que o software reflita o comportamento esperado do sistema a partir da perspectiva do usu√°rio ou dom√≠nio. BDD pode ser visto como a interse√ß√£o onde a clareza de inten√ß√£o do dom√≠nio (trazida pelo DDD) se encontra com a pr√°tica de testar antes de desenvolver (como prop√µe o TDD).

   - **Melhor Comunica√ß√£o**: Facilita a comunica√ß√£o entre todos os membros da equipe, garantindo que todos entendam os requisitos de maneira clara e compartilhada.

   - **Desenvolvimento Orientado a Valor**: Foca no que realmente importa para os usu√°rios finais e stakeholders, ajudando a priorizar o desenvolvimento de funcionalidades de maior valor.

   - **Menos Retrabalho**: Reduz ambiguidades nos requisitos, diminuindo o risco de desenvolvimento de funcionalidades incorretas ou desnecess√°rias.

   - **Documenta√ß√£o Viva**: As especifica√ß√µes atuam como uma documenta√ß√£o viva que est√° sempre em sincronia com o comportamento atual do sistema.

## [QA] Automation testing
![Jest](https://img.shields.io/badge/-Jest-EF2D5E?style=badge&logo=jest&logoColor=white)
![Mocha](https://img.shields.io/badge/-Mocha-EF2D5E?style=badge&logo=mocha&logoColor=white)
![JUnit5](https://img.shields.io/badge/-JUnit5-EF2D5E?style=badge&logo=JUnit5&logoColor=white) 
![xUnit](https://img.shields.io/badge/-xUnit-EF2D5E?style=badge&logo=.NET&logoColor=white) 
![Cucumber](https://img.shields.io/badge/-Cucumber-23D96C?style=badge&logo=cucumber&logoColor=white)
![Selenium](https://img.shields.io/badge/-Selenium-limegreen?style=badge&logo=Selenium&logoColor=white)
![Appium](https://img.shields.io/badge/-Appium-EE376D?style=badge&logo=Appium&logoColor=white)
![Apache JMeter](https://img.shields.io/badge/-Apache--JMeter-D22128?style=badge&logo=apachejmeter&logoColor=white)
![Cypress](https://img.shields.io/badge/-Cypress-505050?style=badge&logo=cypress&logoColor=white)
![Robot Framework](https://img.shields.io/badge/-Robot_Framework-000000?style=badge&logo=robotframework&logoColor=white)

<img src="https://github.com/IsaacAlves7/DevSecOps/assets/61624336/7ae43145-a45f-49a5-98ae-693912faae5d" align="right" height="77">

Conforme o tempo passa a tecnologia segue avan√ßando e os sistemas que s√£o desenvolvidos por pessoas da √°rea de TI est√£o cada vez mais completos. Antigamente os testes manuais eram os mais utilizados, mas eles j√° n√£o suprem mais √†s demandas das empresas e acabam sendo suscet√≠veis a erros. Ent√£o, as organiza√ß√µes precisam desenvolver mais e com melhor qualidade, √© a√≠ que entram os **testes automatizados** que s√£o programas que executam testes em softwares que est√£o em constru√ß√£o de uma forma padronizada, sem ser necess√°rio a interven√ß√£o humana.

Pois, tais testes possuem funcionalidades capazes de testar de forma autom√°tica todos os aspectos de uma plataforma, com o intuito de assegurar um desempenho adequado. Ou seja, a automa√ß√£o de teste √© o uso de software para controlar a execu√ß√£o do teste de software, a compara√ß√£o dos resultados esperados com os resultados reais, a configura√ß√£o das pr√©-condi√ß√µes de teste e outras fun√ß√µes de controle e relat√≥rio de teste. 

Tal procedimento, gera muito mais efic√°cia e agilidade na etapa de testes, permitindo que o profissional encontre de uma maneira mais f√°cil as falhas de seguran√ßa, bugs e demais erros que possam comprometer o uso da aplica√ß√£o.

> Quando o profissional notar que est√° gastando muito tempo com tarefas repetitivas e quando o software est√° muito grande, pode ser a hora de automatizar. Mas, √© necess√°rio tamb√©m questionar a viabilidade dessa a√ß√£o, sendo essencial analisar se com a automa√ß√£o a equipe ir√° obter ganho de tempo e se conseguir√£o reduzir custos e manter a qualidade.

Testes automatizados s√£o uma das pr√°ticas mais fundamentais no desenvolvimento de software moderno, pois garantem confiabilidade, reduzem bugs em produ√ß√£o, facilitam refatora√ß√µes e melhoram a documenta√ß√£o viva do sistema. Para construir testes automatizados realmente bons, √© preciso compreender n√£o s√≥ as ferramentas, mas tamb√©m o processo como um todo ‚Äî desde a fase de planejamento at√© a execu√ß√£o cont√≠nua. Tudo come√ßa pela compreens√£o dos **n√≠veis de teste**: 

<img src="https://user-images.githubusercontent.com/61624336/128188070-c1fff724-f895-4501-bdca-dbab78dca6b1.png" height="177" align="right"> 

1. testes de unidade (isolam pequenas partes do c√≥digo),
2. testes de integra√ß√£o (verificam a comunica√ß√£o entre partes),
3. testes de sistema (validam o sistema como um todo) e
4. testes end-to-end (simulam o comportamento real do usu√°rio).

Cada n√≠vel exige aten√ß√£o diferente e ferramentas espec√≠ficas:

No in√≠cio do ciclo, o **desenho dos testes** precisa ser baseado em crit√©rios claros de cobertura: o que est√° sendo testado, por que est√° sendo testado e o que n√£o precisa ser testado. Bons testes n√£o s√£o s√≥ aqueles que passam, mas aqueles que falham quando o comportamento do c√≥digo foge do esperado. Para isso, as asser√ß√µes precisam ser claras, espec√≠ficas e rastre√°veis. Boas pr√°ticas incluem escrever testes que sejam r√°pidos, isolados, determin√≠sticos e leg√≠veis. Um teste bom √© aquele que algu√©m consegue entender o que ele verifica s√≥ de ler o seu nome e o corpo, sem necessidade de ir at√© a implementa√ß√£o testada.

<img src="https://github.com/IsaacAlves7/DevSecOps/assets/61624336/52a5bb6f-070c-4635-8de1-43db6d07500d" height="277" align="right"> 

A fase de **ferramentas** √© t√£o importante quanto o planejamento. Para testes de unidade, temos ferramentas como **JUnit** (Java), **xUnit** (C#), **pytest** (Python), **Jest** e **Vitest** (JavaScript/TypeScript), **Elixir ExUnit**, entre outras. Para mocks e test doubles, usamos bibliotecas como **Moq**, **Sinon**, **Mockito** ou **NSubstitute**, que ajudam a isolar depend√™ncias externas, como chamadas a APIs, bancos de dados e arquivos. Em testes de integra√ß√£o, frameworks como **TestContainers**, **WireMock** ou bancos de dados em mem√≥ria ajudam a montar ambientes realistas. Para testes de aceita√ß√£o e end-to-end, ferramentas como **Cypress**, **Playwright**, **Selenium** e **Puppeteer** s√£o as mais utilizadas, permitindo testes que interagem com o navegador ou sistema completo, validando fluxos reais.

Na constru√ß√£o de um bom teste automatizado, o primeiro passo √© **nomear corretamente o que est√° sendo testado**, depois criar um ambiente previs√≠vel para que os testes n√£o tenham falsos positivos ou negativos. Um teste que falha √†s vezes √© um teste ruim. Depois, **seguir o padr√£o AAA** (Arrange, Act, Assert) √© uma boa pr√°tica: configurar os dados e depend√™ncias, executar o comportamento que est√° sendo testado, e por fim verificar o resultado. Tamb√©m √© essencial n√£o testar l√≥gica interna demais (isso gera testes fr√°geis), mas focar no comportamento observ√°vel da fun√ß√£o ou componente.

Outro pilar crucial √© a **integra√ß√£o com pipelines de CI/CD**. Automatizar os testes via GitHub Actions, GitLab CI, Jenkins ou Azure DevOps garante que os testes rodam a cada push ou PR, evitando regress√µes. Um teste que s√≥ roda localmente √© praticamente in√∫til em um time com m√∫ltiplos desenvolvedores.

Al√©m disso, n√£o se deve esquecer do **relato dos testes**. Ferramentas de coverage (cobertura de c√≥digo) como **Istanbul**, **Coverlet** ou **Codecov** ajudam a visualizar o quanto do c√≥digo est√° sendo testado, embora **cobertura alta n√£o signifique qualidade alta** ‚Äî √© poss√≠vel ter 100% de cobertura e testes in√∫teis. O ideal √© buscar cobertura √∫til, ou seja, testes que validam fluxos importantes, limites, erros e casos reais de uso.

Por fim, construir um teste automatizado bom exige pr√°tica, disciplina e conhecimento. N√£o √© s√≥ sobre ferramentas, mas sobre escrever c√≥digo de teste que seja confi√°vel, f√°cil de manter e que reflita as regras de neg√≥cio do sistema. √â preciso ter clareza sobre o que vale a pena testar, manter a su√≠te de testes r√°pida e identificar o ponto de equil√≠brio entre cobertura e custo de manuten√ß√£o. Testes automatizados s√£o investimento ‚Äî e como todo investimento, precisam de foco, consist√™ncia e revis√£o cont√≠nua para darem retorno real.

O desenvolvimento, inspe√ß√£o e o teste de unidade s√£o as tr√™s partes do teste de c√≥digos. Numa era onde tudo √© automatizado, testadores de software tem demandado cada vez mais ferramentas de automa√ß√£o de testes. Veja algumas ferramentas para automa√ß√£o de testes:

1. **Selenium**: √© um framework port√°til para testar aplicativos web. O Selenium fornece uma ferramenta de reprodu√ß√£o para a cria√ß√£o de testes funcionais sem a necessidade de aprender uma linguagem de script de teste.
  
2. TestComplete:

3. Telerik Test Studio:

4. Robotium:

5. **Robot Framework**: √© uma estrutura gen√©rica de automa√ß√£o de teste para testes de aceita√ß√£o e desenvolvimento orientado a testes de aceita√ß√£o. √â uma estrutura de teste orientada por palavras-chave que usa a sintaxe de dados de teste tabular. 

6. HPE Unified Functional Testing:

7. Ranorex:

8. Cucumber:

9. Visual Studio Test Professional:

10. TestingWhiz:

Existem muitas ferramentas de testes automatizados dispon√≠veis para diversas linguagens de programa√ß√£o e tipos de testes. Aqui est√£o algumas das mais populares, categorizadas por seu prop√≥sito principal:

1. **Frameworks de Teste Unit√°rio**:
  
  - **JUnit**: Framework de testes unit√°rios para Java. 
  
  - **NUnit**: Framework de testes unit√°rios para .NET.

  - **PyTest**: Framework de testes para Python.

  - **Mocha**: Framework de testes para JavaScript e Node.js.
  
  - **RSpec**: Framework de testes para Ruby.

  - **TestNG**: Outro framework de testes para Java.

2. **Ferramentas de Teste de Integra√ß√£o e Funcional**:

  - **Selenium**: Automa√ß√£o de navegadores para testes de aplica√ß√µes web.
  
  - **Cypress**: Ferramenta de teste de front-end para aplica√ß√µes web modernas.
  
  - **Protractor**: Ferramenta de teste de end-to-end para aplica√ß√µes Angular.

  - **Watir**: Ferramenta de automa√ß√£o de testes para aplica√ß√µes web.

3. **Ferramentas de Teste de Interface de Usu√°rio (UI)**:
  
  - **Appium**: Framework de automa√ß√£o para aplica√ß√µes m√≥veis (iOS e Android).
  
  - **TestComplete**: Ferramenta de automa√ß√£o de testes para aplica√ß√µes desktop, web e m√≥veis.
  
  - **Ranorex**: Ferramenta de automa√ß√£o de testes para desktop, web e dispositivos m√≥veis.

4. **Ferramentas de Teste de Performance e Carga**:
  
  - **JMeter**: Ferramenta para testes de carga e performance.
  
  - **Gatling**: Ferramenta de teste de carga focada em aplica√ß√µes web.
  
  - **LoadRunner**: Ferramenta de teste de carga e performance da Micro Focus.

5. **Ferramentas de Teste de Seguran√ßa**:
  
  - **OWASP ZAP**: Ferramenta para testes de penetra√ß√£o de aplica√ß√µes web.
  
  - **Burp Suite**: Ferramenta de teste de seguran√ßa para aplica√ß√µes web.
  
  - **Acunetix**: Ferramenta de varredura de seguran√ßa para aplica√ß√µes web.

6. **Ferramentas de Teste de APIs**:
  
  - **Postman**: Ferramenta para teste de APIs RESTful.
  
  - **SoapUI**: Ferramenta de teste para servi√ßos web SOAP e REST.
  
  - **RestAssured**: Biblioteca para teste de APIs REST em Java.

7. **Ferramentas de Integra√ß√£o Cont√≠nua**:
  
  - **Jenkins**: Ferramenta de integra√ß√£o cont√≠nua que pode ser usada para executar testes automatizados.
  
  - **GitHub Actions**: Servi√ßo de integra√ß√£o e entrega cont√≠nua integrado ao GitHub.

  - **GitLab CI/CD**: Ferramenta de integra√ß√£o cont√≠nua e entrega cont√≠nua do GitLab.

  - **CircleCI**: Servi√ßo de integra√ß√£o cont√≠nua e entrega cont√≠nua.

8. **Ferramentas de An√°lise de C√≥digo e Cobertura de Testes**:

   - **SonarQube**: Ferramenta de an√°lise est√°tica de c√≥digo que tamb√©m mede a cobertura de testes.

   - **JaCoCo**: Ferramenta de cobertura de testes para Java.

   - **Cobertura**: Ferramenta de cobertura de testes para Java.

   - **Istanbul**: Ferramenta de cobertura de testes para JavaScript.

Essas ferramentas ajudam a automatizar diferentes tipos de testes, desde testes unit√°rios b√°sicos at√© testes de performance e seguran√ßa, garantindo a qualidade e a estabilidade do software durante todo o ciclo de desenvolvimento.

## [QA] Unit testing
<img src="https://img.shields.io/badge/Jest-fail-%23C21325?style=flat&logo=jest&logoColor=white"> <img src="https://img.shields.io/badge/Mock-pass-chocolate?style=flat&logo=Mock&logoColor=white"> <img src="https://img.shields.io/badge/Go-passing-00ADD8?style=flat&logo=Go&logoColor=white"> <img src="https://img.shields.io/badge/PHPUnit-8.2-777BB4?style=flat&logo=PHP&logoColor=white"> <img src="https://img.shields.io/badge/-Pytest-blue?style=badge&logo=Pytest&logoColor=white"> <img src="https://img.shields.io/badge/JUnit5-passing-25A162?style=flat&logo=JUnit5&logoColor=white"> <img src="https://img.shields.io/badge/xUnit.net-8_pass_0_fail-512BD4?style=flat&logo=DotNet&logoColor=white">

<img src="https://em-content.zobj.net/source/microsoft-teams/363/test-tube_1f9ea.png" height="77" align="right">

Os **testes unit√°rios** ou **testes de unidade** (unit tests) √© toda a aplica√ß√£o de teste nas assinaturas de entrada e sa√≠da de um sistema. Consiste em validar dados v√°lidos e inv√°lidos via I/O (entrada/sa√≠da) sendo aplicado por desenvolvedores ou analistas de teste (QA). Testes unit√°rios s√£o m√©todos que verificam o funcionamento de unidades de c√≥digo, vulgo m√©todos, e seus objetos associados. O grande objetivo, por incr√≠vel que pare√ßa, n√£o √© ter uma grande cobertura, e sim resultar em uma arquitetura melhor, menos acoplada, e de melhor manuten√ß√£o. Classes com muitas dep√™ndencias s√£o muito dif√≠ceis de testar. M√©trica utilizada: cobertura de c√≥digo. 

Portanto, s√£o testes que verificam se uma parte espec√≠fica do c√≥digo, costumeiramente a n√≠vel de fun√ß√£o, est√° funcionando corretamente. Em um ambiente orientado a objetos (OOP) √© usualmente a n√≠vel de classes e a m√≠nima unidade de testes inclui construtores e destrutores. 

> üß™ Os testes de unidade verificam unidades, como m√©todos, fun√ß√µes e componentes dentro do software. S√£o os testes mais r√°pidos, baratos de escrever e sua manuten√ß√£o √© simples. Para verificar o <a href="">comportamento</a> dessas pequenas partes isoladas do sistema sem depend√™ncias externas como banco de dados, APIs, arquivos ou rede. Por isso, eles s√£o r√°pidos de executar, baratos de manter e oferecem feedback imediato durante o desenvolvimento. Como testam unidades isoladas, s√£o fundamentais para garantir a estabilidade do c√≥digo √† medida que ele evolui.

Uma **unidade** (unit) √© a menor parte test√°vel de um programa de computador, no programa√ß√£o procedural uma unidade pode ser uma fun√ß√£o individual ou um procedimento do nosso c√≥digo, imagine que toda fun√ß√£o √© uma pequena f√°brica que fabrica alguma coisa que pode sair, sem a necessidade de entrar algo. Idealmente, cada teste de unidade √© independente dos demais, o que possibilita ao programador testar cada m√≥dulo isoladamente.

Rela√ß√£o de conceitos de testes de unidade: 

**I/O Input-Output** (Entrada e Sa√≠da): s√£o todas as entradas e sa√≠das existentes na programa√ß√£o. Portanto, os testes de unidade servem para front-end e back-end. Eles s√£o uma pr√°tica essencial no desenvolvimento de software, pois ajudam a garantir a qualidade do c√≥digo e a facilitar a manuten√ß√£o. Os testes de unidade s√£o realizados em pequenas unidades de c√≥digo, como fun√ß√µes, componentes ou m√≥dulos. Eles s√£o projetados para testar a funcionalidade e a l√≥gica dessas unidades de forma isolada. Isso significa que os testes de unidade n√£o dependem de outros componentes ou m√≥dulos para funcionar.

No **front-end**, os testes de unidade s√£o usados para testar a funcionalidade e a l√≥gica de componentes de interface do usu√°rio, como bot√µes, formul√°rios e listas. Eles tamb√©m s√£o usados para testar a intera√ß√£o entre componentes.

No **back-end**, os testes de unidade s√£o usados para testar a funcionalidade e a l√≥gica de servi√ßos, APIs e outros componentes de back-end. Eles tamb√©m s√£o usados para testar a integra√ß√£o entre componentes de back-end.

Os testes de unidade oferecem uma s√©rie de benef√≠cios, incluindo:

<img src="https://uploads.toptal.io/blog/image/91302/toptal-blog-image-1434578005589-4e6897ec04cc0b3c7075b9b011ee915c.gif" height="377" align="right">

- Aumento da qualidade do c√≥digo: Os testes de unidade ajudam a identificar erros e bugs no c√≥digo antes que eles sejam integrados ao sistema. Isso resulta em um c√≥digo mais confi√°vel e est√°vel.

- Facilidade de manuten√ß√£o: Os testes de unidade facilitam a manuten√ß√£o do c√≥digo, pois permitem verificar se as altera√ß√µes n√£o afetaram o funcionamento de outras partes do c√≥digo.

- Agilidade no desenvolvimento: Os testes de unidade permitem que os desenvolvedores tenham mais confian√ßa ao realizar refatora√ß√µes ou adicionar novos recursos. Isso permite que as equipes desenvolvam de forma mais r√°pida e eficiente.

Portanto, os testes de unidade s√£o uma pr√°tica importante para qualquer desenvolvedor, independentemente da √°rea de atua√ß√£o. 

Sobre os processos de desenvolvimento de software, no terceiro passo no n√≠vel de queda do modelo cascata e no quarto passo do modelo RAPID, entramos na parte de codifica√ß√£o e testes unit√°rios. Ou seja, √© a constru√ß√£o do sistema em si. Ent√£o, s√≥ depois de eu entender todo o problema, s√≥ depois de eu saber das necessidades e se √© poss√≠vel ou vi√°vel para come√ßar a desenvolver. Muitas vezes, para come√ßar a gente se pergunta se √© para pegar logo no processo de codifica√ß√£o, ou seja, a desenvolver logo a aplica√ß√£o o mais r√°pido poss√≠vel. No entanto, percebe-se que o tanto de retrabalho que isso gerava, fazia n√£o valer a pena. E fazia com que estourasse muito o or√ßamento nesse custo. Ent√£o, depois deu definir os requisitos, depois de realizar meus modelos de projetos e provar que aquilo √© vi√°vel, eu ent√£o come√ßo o desenvolvimento do meu software em si.

Ap√≥s o desenvolvimento e junto com o desenvolvimento, entram os testes unit√°rios (unit tests - testes de unidade) que s√£o definidos pelo pr√≥prio desenvolvedor onde eles tendem a testar a menor unidade do sistema. Por exemplo: Se eu estou desenvolvendo um sistema de cadastro de cliente, n√£o importa o tipo do sistema (mercadinho, farm√°cia, padaria, com√©rcio ou de uma grande empresa) e esse desenvolvedor que est√° escrevendo essas linhas de c√≥digo de cadastrar um √∫nico usu√°rio ou funcion√°rio, por exemplo, ele vai desenvolver um caso de teste para que dado uma entrada (input), ele possa receber uma sa√≠da (output) esperada que seria: "usu√°rio cadastrado com sucesso".

Os frameworks de teste de unidade mais populares para **React.js** s√£o:

- <a href="">Jest</a>: O Jest √© um framework de teste de unidade JavaScript criado pelo Facebook. Ele √© r√°pido, f√°cil de usar e oferece uma variedade de recursos, como testes de snapshot, mocking e asser√ß√µes.

- <a href="">Testing Library</a>: A Testing Library √© uma biblioteca de utilit√°rios para testes de componentes React. Ela fornece uma API simples e intuitiva que permite testar componentes sem depender dos detalhes de implementa√ß√£o.

- <a href="">Enzyme</a>: O Enzyme √© uma biblioteca de teste de componentes React que fornece uma API poderosa e flex√≠vel para manipular o DOM e testar eventos.

A escolha do framework de teste de unidade mais adequado depende das necessidades espec√≠ficas do projeto. O Jest √© uma boa op√ß√£o para projetos simples, enquanto frameworks como a Testing Library ou o Enzyme podem ser mais adequados para projetos mais complexos.

Os frameworks de teste de unidade mais populares para **Vue.js** s√£o:

- <a href="">Vue Test Utils</a>: O Vue Test Utils √© um conjunto de utilit√°rios para testes de componentes Vue.js. Ele fornece uma API simples e intuitiva que permite testar componentes sem depender dos detalhes de implementa√ß√£o.

- <a href="">Jest</a>: O Jest √© um framework de teste de unidade JavaScript criado pelo Facebook. Ele tamb√©m pode ser usado para testes de unidade em Vue.js.

- <a href="">Karma</a>: O Karma √© um framework de teste de unidade JavaScript que pode ser usado para executar testes em uma variedade de navegadores. Ele tamb√©m pode ser usado para testes de unidade em Vue.js.

A escolha do framework de teste de unidade mais adequado depende das necessidades espec√≠ficas do projeto. O Vue Test Utils √© uma boa op√ß√£o para projetos simples, enquanto frameworks como o Jest ou o Karma podem ser mais adequados para projetos mais complexos.

O framework Python para web back-end chamado **Django** fornece um framework de teste padr√£o, chamado de **unittest**. Esse framework √© baseado na biblioteca padr√£o unittest do Python e √© adequado para testes unit√°rios e de integra√ß√£o.

Al√©m do unittest, existem outros frameworks de teste de unidade dispon√≠veis para Django. Alguns dos frameworks mais populares incluem:

- <a href="">Pytest</a>: O Pytest √© um framework de teste de unidade completo e flex√≠vel que oferece uma variedade de recursos, como assertion fixtures, parametriza√ß√£o de testes e testes de desempenho.

- <a href="">Mock</a>: O Mock √© um framework de mocking que permite simular o comportamento de objetos externos. Isso pode ser √∫til para testar a funcionalidade de componentes que dependem de outros componentes ou APIs externas.

- <a href="">Selenium</a>: O Selenium √© um framework de automa√ß√£o de testes que permite testar a intera√ß√£o com um navegador web. Isso pode ser √∫til para testar a funcionalidade de componentes de front-end.

A escolha do framework de teste de unidade mais adequado depende das necessidades espec√≠ficas do projeto. O unittest √© uma boa op√ß√£o para projetos simples, enquanto frameworks como Pytest e Mock podem ser mais adequados para projetos mais complexos.

Sobre os conceitos t√©cnicos a respeito de testes de unidades, temos:

[![License](https://img.shields.io/badge/license-Apache%20License%202.0-blue.svg)](https://opensource.org/licenses/Apache-2.0)
[![Java](https://img.shields.io/badge/java-17%2B-blue)](https://www.oracle.com/java/technologies/javase/jdk17-archive-downloads.html)
[![Release](https://img.shields.io/github/release/rife2/tests-badge.svg)](https://github.com/rife2/tests-badge/releases/latest)
[![GitHub CI](https://github.com/rife2/tests-badge/actions/workflows/bld.yml/badge.svg)](https://github.com/rife2/tests-badge/actions/workflows/bld.yml)
[![Tests](https://rife2.com/tests-badge/badge/com.uwyn/tests-badge)](https://github.com/rife2/tests-badge/actions/workflows/bld.yml)

<img src="https://github.com/IsaacAlves7/DevSecOps/assets/61624336/f92b16ca-c0a0-40ab-ab33-f8ec9f4cf619" height="77" align="right">

‚úÖ **Testes V√°lidos** (`pass`): S√£o entradas e sa√≠das de dados comuns ao sistema e pertencem ao processo normal. N√£o apresentam tratamento al√©m do normal j√° programado. No caso de retorno dever√° seguir os padr√µes estabelecidos e n√£o permitir retornos fora das regras especificadas. Em testes unit√°rios, estamos nos referindo a casos de teste que exercitam o comportamento correto e esperado da unidade de c√≥digo sob condi√ß√µes normais (v√°lidas), ou seja: Situa√ß√µes em que tudo ocorre como deveria. S√£o aqueles testes que usam entradas v√°lidas e esperadas, esperam resultados corretos, sem exce√ß√µes ou erros. Confirmam que o comportamento da fun√ß√£o est√° conforme o esperado.

Caracter√≠sticas de testes v√°lidos:

| Caracter√≠stica              | Exemplo pr√°tico                                           |
| --------------------------- | --------------------------------------------------------- |
| Entrada no dom√≠nio esperado | CPF v√°lido, n√∫mero positivo, email formatado corretamente |
| Estado inicial v√°lido       | Usu√°rio existente, banco conectado, produto em estoque    |
| Fluxo normal do c√≥digo      | Sem exce√ß√µes, erros, ou retornos inesperados              |
| Resultado esperado          | Retorno certo, estado alterado corretamente               |

Exemplo simples em JavaScript: Aqui, `2` e `3` s√£o valores v√°lidos, e o retorno esperado (`5`) confirma o comportamento correto da fun√ß√£o.

<img src="https://img.shields.io/badge/Jest-1_pass_0_fail-limegreen?style=flat&logo=jest&logoColor=white">

```javascript
function somar(a: number, b: number): number {
  return a + b;
}

test("soma dois n√∫meros positivos", () => {
  expect(somar(2, 3)).toBe(5); // ‚úÖ teste v√°lido
});
```

<img src="https://github.com/IsaacAlves7/DevSecOps/assets/61624336/1e50bc84-048c-40c7-b7b8-98dfdeec38a2" height="77" align="right">

‚ùå **Testes Inv√°lidos** (`fail`): S√£o entradas e sa√≠das de dados n√£o comuns ao sistema. Apresentam tratamento para validar o tipo de dado inv√°lido ou situa√ß√£o. Pode apresentar at√© dois retornos, uma mensagem para um log no sistema e uma mensagem com formata√ß√£o e escrita adequada ao usu√°rio. S√£o t√£o importantes quanto os testes v√°lidos, porque ajudam a garantir que sua fun√ß√£o se defenda bem contra entradas erradas, estados incorretos ou fluxos inesperados. S√£o testes que usam entradas inv√°lidas, incorretas ou fora do esperado; Esperam que o c√≥digo falhe corretamente (com exce√ß√£o, erro, ou retorno de falha); Verificam se o sistema √© robusto contra dados errados ou uso indevido da fun√ß√£o.

Exemplo:

```txt
Dividir (x int,y int)=z int
```

Caso tenhamos `x=1` e `y=0`, `z` ser√° um valor com erro e dever√° retornar uma mensagem ao usu√°rio, avisando que a opera√ß√£o √© inv√°lida. Caso a express√£o seja um dado comum do sistema, a autoriza√ß√£o para tal valida√ß√£o dever√° ser do usu√°rio, pois faz parte do conjunto de regras de neg√≥cio. N√£o existe retorno inv√°lido sem um tratamento. O tratamento gen√©rico ser√° apenas para condi√ß√µes n√£o vis√≠veis na regra e uso do sistema.

<img src="https://github.com/IsaacAlves7/DevSecOps/assets/61624336/c0328294-f3e5-489f-8521-0d634275f7ae" height="77" align="right">

üëÅÔ∏è‚Äçüó®Ô∏è **Dom√≠nio**: No dom√≠nio de testes, usamos testes unit√°rios para validar a funcionalidade de cada componente do nosso dom√≠nio de neg√≥cio, refere-se √† parte do sistema que √© testada para garantir que a l√≥gica de neg√≥cio e a funcionalidade do c√≥digo est√£o corretas, os testes unit√°rios focam em componentes individuais desse dom√≠nio.

> [!Important]
> √â importante ressaltar sobre um termo muito conhecido em ci√™ncia da computa√ß√£o, chamado **dom√≠nio** (domain), cujo a diferen√ßa est√° no n√≠vel de abstra√ß√£o e no foco de cada conceito. A palavra "dom√≠nio" realmente aparece em contextos diferentes e pode causar confus√£o se n√£o for bem delimitada.
>
> No contexto de testes unit√°rios, "dom√≠nio" pode se referir genericamente √† camada de regras de neg√≥cio ou l√≥gica principal da aplica√ß√£o, que √© o alvo ideal desses testes ‚Äî ou seja, testar a l√≥gica do dom√≠nio sem envolver infraestrutura, banco de dados ou interface.
>
> J√° em DDD (Domain-Driven Design), "dom√≠nio" √© o conceito central: √© o conhecimento do neg√≥cio que est√° sendo modelado, e tudo gira em torno disso ‚Äî √© a √°rea de interesse do sistema, como log√≠stica, financeiro, sa√∫de, etc.
>
> No caso de arquiteturas como Clean Architecture ou Ports & Adapters, "dom√≠nio" √© uma camada bem definida e isolada que representa as regras puras do neg√≥cio, ou seja, aquilo que n√£o muda mesmo que a tecnologia mude; √© o n√∫cleo da aplica√ß√£o.
>
> J√° em TDD e BDD, o termo "dom√≠nio" aparece implicitamente quando voc√™ escreve testes voltados para comportamentos do sistema, especialmente no BDD que foca na linguagem ub√≠qua e no comportamento esperado do dom√≠nio de neg√≥cio, enquanto o TDD tende a atuar mais no detalhe t√©cnico e no design emergente.
>
> Por fim, em design de software e design patterns, o "dom√≠nio" pode surgir como contexto onde os padr√µes s√£o aplicados, mas o foco desses conceitos √© mais estrutural e de solu√ß√£o t√©cnica do que modelagem de neg√≥cio em si.
> 
> Ent√£o, "dom√≠nio" em DDD e arquiteturas limpas √© o cora√ß√£o das regras do neg√≥cio, enquanto em testes e padr√µes, √© mais o cen√°rio onde voc√™ aplica as pr√°ticas, muitas vezes sem foco expl√≠cito em representar o neg√≥cio como um modelo coeso.

Voc√™ pode dizer: 

> "Nos nossos testes de unidade, verificamos se os m√©todos da entidade `Pedido` calculam corretamente o total do pedido."

Focado na verifica√ß√£o da funcionalidade de unidades isoladas de c√≥digo (geralmente m√©todos ou fun√ß√µes), tem como objetivo garantir que cada parte do software funcione conforme esperado de maneira isolada. O contexto aqui √© mais t√©cnico e voltado para a qualidade do c√≥digo e a preven√ß√£o de regress√µes.

Pode ser um campo, uma assinatura, um I/O, ou qualquer tipo de local que receba valores externos ao sistema. Todo dom√≠nio deve realizar consist√™ncias de dados v√°lidos e inv√°lidos. Um dom√≠nio s√≥ permite dados com a formata√ß√£o igual ao que ser√° armazenado.

Ex.: Campo DDD dever√° permitir n√∫meros de at√© quatro casas n√£o negativas ou a base de dados deve impedir a entrada de valores inv√°lidos. Receber e guardar o mesmo tipo de dado, o tamanho do campo que recebe os dados deve ser menor ou igual ao campo que ir√° armazenar os dados (em raros casos os campos de armazenamento s√£o menores que os de exibi√ß√£o).

Em suma, dom√≠nio √© o tipo de valor v√°lido para cada campo. Como exemplo podemos citar: Campo nome: Dominio = tipo: string; tamanho:50. Ao aplicarmos o particionamento por equival√™ncia e a an√°lise por valor limite, poderemos criar as seguintes classes de testes.

Particionamento por Equival√™ncia: campo nome:

- valor em branco (BLANK); Cen√°rio Negativo
- `valor > 50`; Cen√°rio Negativo
- qualquer valor de `1` a `50`; Cen√°rio Positivo

An√°lise por Valor Limite:

campo nome: valor em branco; valores 49,50,51; 

Usamos um valor exatamente inferior e exatamente posterior ao valor do campo, devido ao fato dos erros aparecerem nas fronteiras da aplica√ß√£o.

O dom√≠nio de testes unit√°rios, o dom√≠nio de DDD (Domain-Driven Design) e o dom√≠nio de microsservi√ßos podem estar inter-relacionados, mas n√£o s√£o exatamente o mesmo dom√≠nio. Embora o dom√≠nio de testes unit√°rios, o dom√≠nio de DDD e o dom√≠nio de microsservi√ßos n√£o sejam exatamente o mesmo, eles est√£o inter-relacionados e podem se complementar. Testes unit√°rios verificam a funcionalidade do c√≥digo, DDD foca na modelagem do dom√≠nio de neg√≥cios, e microsservi√ßos organizam a aplica√ß√£o em componentes pequenos e independentes. Quando usados juntos, esses conceitos podem ajudar a criar sistemas robustos, bem projetados e testados. Voc√™ pode ter uma comunica√ß√£o mais assertiva com o seu time falando da maneira proposta acima que eles ir√£o entender de qual tipo de dom√≠nio se trata.

Quando voc√™ combina esses tr√™s conceitos, voc√™ pode comunicar algo como: 

> "No nosso sistema, utilizamos uma abordagem de Domain-Driven Design (DDD) para modelar nosso dom√≠nio de neg√≥cio. Cada parte do dom√≠nio de neg√≥cio √© implementada como um microsservi√ßo independente, permitindo escalabilidade e independ√™ncia de desenvolvimento. Al√©m disso, garantimos a qualidade e a corre√ß√£o da l√≥gica de neg√≥cio com testes unit√°rios abrangentes, que validam cada componente do nosso dom√≠nio de neg√≥cio."

<img src="https://github.com/IsaacAlves7/DevSecOps/assets/61624336/3963eb3d-ea61-4557-92cb-2f097cfed79a" height="77" align="right">

Os **Test doubles** s√£o objetos usados em testes de software para substituir componentes reais que um sistema ou m√≥dulo depende, permitindo que os testes sejam mais control√°veis, isolados, r√°pidos e confi√°veis. O nome ‚Äúdouble‚Äù vem da ideia de um ‚Äúdubl√™‚Äù no cinema: algu√©m que substitui o ator em cenas arriscadas. No c√≥digo, os test doubles substituem partes reais (como um banco de dados, uma API externa ou at√© um servi√ßo interno) que voc√™ n√£o quer ou n√£o pode usar diretamente durante o teste.

Eles s√£o fundamentais para testes automatizados, principalmente testes unit√°rios, e ajudam a focar apenas na l√≥gica que voc√™ est√° testando, sem interfer√™ncia de outras partes do sistema. 

Tipos comuns de Test Doubles:

<img src="https://github.com/user-attachments/assets/475699e2-bce6-4101-acad-741da09c5f68" height="277" align="right">

**Mocking** (Mockado) √© uma t√©cnica usada em testes de software para simular o comportamento de depend√™ncias externas, como servi√ßos, bancos de dados, ou APIs, dentro de uma unidade de c√≥digo que voc√™ est√° testando. Ao inv√©s de usar as implementa√ß√µes reais dessas depend√™ncias, voc√™ cria "mocks" (objetos falsos) que imitam o comportamento esperado, permitindo testar o c√≥digo de forma isolada. O principal benef√≠cio do mocking √© garantir que o teste foque apenas no comportamento da unidade de c√≥digo em quest√£o, sem se preocupar com o comportamento ou estado das depend√™ncias externas.

Exemplo: Se voc√™ estiver testando um servi√ßo que depende de um reposit√≥rio de dados, voc√™ pode usar um mock para simular as respostas do reposit√≥rio, em vez de acessar o banco de dados real.

Mocking e testes unit√°rios s√£o diferentes, mas se complementam para testar unidades isoladas do c√≥digo. Os testes unit√°rios tem o objetivo de testar uma unidade de c√≥digo (como uma fun√ß√£o ou m√©todo) de forma independente, garantindo que ela funcione corretamente em diferentes cen√°rios. Em um teste unit√°rio, voc√™ se preocupa apenas com o comportamento interno dessa unidade. J√° o mocking √© uma t√©cnica usada nos testes unit√°rios para simular (mockar) depend√™ncias externas da unidade que est√° sendo testada. Isso permite que voc√™ foque exclusivamente na l√≥gica interna da unidade, sem se preocupar com o comportamento ou estado de servi√ßos, bancos de dados ou APIs reais. Em resumo, os mocks ajudam a garantir que os testes unit√°rios sejam realmente isolados e focados na unidade de c√≥digo que est√° sendo testada, sem interfer√™ncias externas.
